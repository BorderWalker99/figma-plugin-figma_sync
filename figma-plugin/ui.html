<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ScreenSync</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Staatliches&family=Archivo+Black&display=swap" rel="stylesheet">
  <style>
    /*========================
      Design System: Lab / Apple Hybrid
    ========================*/
    :root {
      /* Colors */
      --bg-app: #F2F3F7; /* 拟物风格常用浅灰背景 */
      --bg-card: #F2F3F7;
      
      /* Neumorphism Colors (Light Theme) */
      --neu-shadow-light: rgba(255, 255, 255, 0.9);
      --neu-shadow-dark: rgba(0, 0, 0, 0.12);
      --neu-face: #E8ECF0;
      
      --neu-ring-gradient: linear-gradient(145deg, #FFFFFF, #E0E5E9);
      --neu-ring-inner-shadow: inset 1px 1px 2px rgba(255,255,255,0.9);
      --neu-face-bg: #E8ECF0;
      --neu-face-shadow: 
        inset 1px 1px 2px rgba(255,255,255,0.9), 
        inset -1px -1px 2px rgba(0,0,0,0.08);
      
      --neu-face-bg-hover: #EEF2F6;
      --neu-face-bg-active: #E0E4E8;
      --neu-face-shadow-active: 
        inset 3px 3px 6px rgba(0,0,0,0.15),
        inset -2px -2px 4px rgba(255,255,255,0.7);

      /* ==========================================================================
         Unified Green Token System
         Based on Realtime Sync Button Icon (#mainStartBtn.active .icon-on)
         ========================================================================== */
      --unified-green: #4DE34F; /* Match SVG fill */
      --unified-green-glow: rgba(77, 227, 79, 0.4); /* Match light theme drop-shadow */
      
      /* Status Pill Variables - Pressed (Recessed) Style */
      --pill-recessed-bg: #E8ECF0;
      --pill-recessed-shadow: 
          inset 3px 3px 6px rgba(0, 0, 0, 0.12),
          inset -2px -2px 5px rgba(255, 255, 255, 0.9);
      --pill-screen-text: var(--unified-green);
      --pill-screen-text-glow: var(--unified-green-glow);
      --pill-interactive-bg: #E8ECF0;
      
      /* Icon Colors */
      --icon-color: #666666;
      
      /* Active State */
      --power-green: var(--unified-green);
      --power-off: #5F6368;
      --icon-off-color: #000000;
      --neu-glow: var(--unified-green-glow);
      
      /* ... other vars ... */
      --bg-card-hover: #FDFDFD;
      --bg-app: #E8ECF0; /* Match Neumorphism background */
      --bg-card: #E8ECF0;
      
      /* Logo Colors */
      --logo-color-primary: #007AFF;
      --logo-color-secondary: #FFFFFF;

      --text-primary: #1D1D1F;
      --text-secondary: #86868B;
      --text-tertiary: #AEAEB2;
      --neu-text: #999999;
      --neu-text-active: var(--unified-green);
      
      /* Accent Blue: #0066FF (Contrast Ratio 4.67:1 with White, passes WCAG AA) */
      --accent: #0066FF;
      --accent-gradient: linear-gradient(135deg, #0066FF, #0052CC);
      --accent-soft: rgba(0, 102, 255, 0.1);
      
      /* Switch Green Gradient - Match status pill green */
      --switch-active-gradient: linear-gradient(145deg, var(--unified-green), #248A3D);
      
      --success: var(--unified-green);
      --success-bg: rgba(52, 199, 89, 0.1);
      
      --warning: #FF9500;
      --warning-bg: rgba(255, 149, 0, 0.1);
      
      --danger: #FF3B30;
      --danger-bg: rgba(255, 59, 48, 0.1);
      
      /* Focus Ring Color - Green for global consistency */
      --focus-ring-color: var(--unified-green);
      --focus-ring-glow: var(--unified-green-glow);
      
      --divider: rgba(0, 0, 0, 0.05);
      --border: rgba(0, 0, 0, 0.08);
      
      /* Shadows */
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.04);
      --shadow-md: 0 8px 24px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 15px 48px rgba(0, 0, 0, 0.1);
      --shadow-inner: inset 0 1px 1px rgba(255,255,255,0.5);
      
      /* Upload dropzone (Light) */
      --bg-inset: #E0E4E8;
      --dropzone-shadow: inset 2px 2px 5px #b8b9be, inset -3px -3px 7px #ffffff;
      --primary-bg: rgba(33, 150, 243, 0.08);
      
      /* Radius */
      --radius-s: 8px;
      --radius-m: 16px;
      --radius-l: 24px;
      
      /* Animation */
      --ease-spring: cubic-bezier(0.25, 0.8, 0.25, 1);
      --ease-out: cubic-bezier(0.33, 1, 0.68, 1);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg-app: #2C2C2E; /* Darker background for Dark Mode */
        --bg-card: #2C2C2E;
        --bg-card-hover: #3A3A3C;
        
        /* Neumorphism Colors (Dark Theme) */
        --neu-shadow-light: rgba(255, 255, 255, 0.06);
        --neu-shadow-dark: rgba(0, 0, 0, 0.5);
        --neu-face: #2C2C2E;
        
        --neu-ring-gradient: linear-gradient(145deg, #3A3A3C, #2C2C2E);
        --neu-ring-inner-shadow: inset 1px 1px 2px rgba(255,255,255,0.08);
        --neu-face-bg: #2C2C2E;
        --neu-face-shadow: 
          inset 1px 1px 2px rgba(255,255,255,0.08), 
          inset -1px -1px 2px rgba(0,0,0,0.3);
        
        --neu-face-bg-hover: #3A3A3C;
        --neu-face-bg-active: #2C2C2E;
        --neu-face-shadow-active: 
          inset 3px 3px 6px rgba(0,0,0,0.5),
          inset -2px -2px 4px rgba(255,255,255,0.05);
        
        --icon-off-color: #AAAAAA;
        
        /* Unified Green Token - Dark Theme Override */
        --unified-green-glow: rgba(77, 227, 79, 0.45); /* Increased for better visibility in dark mode */
        --neu-glow: var(--unified-green-glow);

        /* Status Pill Variables - Pressed Style (Dark) */
        --pill-recessed-bg: #2C2C2E;
        --pill-recessed-shadow: 
            inset 2px 2px 4px rgba(0, 0, 0, 0.25),
            inset -2px -2px 4px rgba(255, 255, 255, 0.06);
        --pill-screen-text: var(--unified-green);
        --pill-screen-text-glow: var(--unified-green-glow);
        --pill-interactive-bg: #2C2C2E;

        /* Icon Colors */
        --icon-color: #AAAAAA;
        
        /* Logo Colors Dark Mode */
        --logo-color-primary: #0A84FF;
        --logo-color-secondary: #1C1C1E;

        --text-primary: #F5F5F7;
        --text-secondary: #8E8E93;
        --text-tertiary: #48484A;
        --neu-text: #8E8E93;
        --neu-text-active: #30D158;
        
        --accent: #0A84FF;
        --accent-soft: rgba(10, 132, 255, 0.1);
        
        /* Switch Green Gradient (Dark) - Match status pill green */
        --switch-active-gradient: linear-gradient(145deg, var(--unified-green), #248A3D);
        
        /* Focus Ring Color - Green for global consistency (Dark) */
        --focus-ring-color: var(--unified-green);
        --focus-ring-glow: var(--unified-green-glow); /* Lower for dark theme */
        
        --divider: rgba(255, 255, 255, 0.08);
        --border: rgba(255, 255, 255, 0.12);
        
        --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
        --shadow-md: 0 8px 24px rgba(0, 0, 0, 0.4);
        
        /* Upload dropzone */
        --bg-inset: #1C1C1E;
        --dropzone-shadow: inset 2px 2px 5px rgba(0,0,0,0.5), inset -3px -3px 7px rgba(255,255,255,0.05);
        --primary-bg: rgba(33, 150, 243, 0.15);
      }
    }

    /* CSS Refactoring: Settings Content */
    .settings-section {
        margin-bottom: 16px;
        padding: 0;
    }

    /* Add extra space for the first section to avoid clipping hover effects */
    .tab-content > .settings-section:first-child {
        padding-top: 4px;
    }

    .settings-section:last-child {
        margin-bottom: 0;
    }

    .settings-section h3 {
        font-size: 13px;
        margin: 0 0 8px 0;
        font-weight: 600;
        color: var(--neu-text);
        opacity: 0.8;
    }
    
    /* Inline styled titles in modal - override inline styles */
    #userIdTitle, #shortcutGuideTitle {
        color: var(--neu-text) !important;
        opacity: 0.8;
    }

    * {
      box-sizing: border-box;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    
    /* Global Skeuomorphism Text Shadow - Applied to all text elements */
    button, .modal-title, .section-title, .tab-btn, .hero-mode-title, 
    .metric-value, .metric-label, .settings-section h3, .toast, .log-title,
    .btn span, .control-label, .card-title, .card-desc, .input-prefix,
    .update-banner-text, .user-id-display #displayUserId, .connection-pill,
    h1, h2, h3, h4, h5, h6, p, span, label {
        text-shadow: 0 1px 1px rgba(255, 255, 255, 0.5);
    }
    
    @media (prefers-color-scheme: dark) {
        button, .modal-title, .section-title, .tab-btn, .hero-mode-title, 
        .metric-value, .metric-label, .settings-section h3, .toast, .log-title,
        .btn span, .control-label, .card-title, .card-desc, .input-prefix,
        .update-banner-text, .user-id-display #displayUserId, .connection-pill,
        h1, h2, h3, h4, h5, h6, p, span, label {
            text-shadow: 0 1px 1px rgba(0, 0, 0, 0.3);
        }
    }
    
    /* Exceptions - Remove text shadow from input fields and their content */
    .input-wrapper input,
    .input-wrapper input::placeholder {
        text-shadow: none;
    }
    
    /* Global Skeuomorphism Icon Shadow - Applied to all icons */
    svg, .icon-btn svg, .neumorphic-btn svg, .close-btn svg,
    .toast-icon svg, .connection-pill svg, .card-icon svg,
    .update-banner-icon svg, .btn svg {
        filter: drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
    }
    
    @media (prefers-color-scheme: dark) {
        svg, .icon-btn svg, .neumorphic-btn svg, .close-btn svg,
        .toast-icon svg, .connection-pill svg, .card-icon svg,
        .update-banner-icon svg, .btn svg {
            filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
        }
    }
    
    /* Special handling for icons that already have specific filters */
    .connection-pill.connected svg {
        filter: drop-shadow(0 0 6px var(--neu-glow)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
    }
    
    @media (prefers-color-scheme: dark) {
        .connection-pill.connected svg {
            /* Reduce glow spread in dark theme for subtler effect */
            filter: drop-shadow(0 0 4px var(--neu-glow)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
        }
    }
    
    #mainStartBtn.active .icon-on,
    #mainStartBtn.active:hover .icon-on {
        /* Stronger double-layer glow */
        filter: drop-shadow(0 0 6px var(--unified-green-glow)) drop-shadow(0 0 12px var(--unified-green-glow)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
    }
    
    @media (prefers-color-scheme: dark) {
        #mainStartBtn.active .icon-on,
        #mainStartBtn.active:hover .icon-on {
            /* Stronger double-layer glow for dark mode */
            filter: drop-shadow(0 0 8px var(--unified-green-glow)) drop-shadow(0 0 16px var(--unified-green-glow)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
        }
    }
    
    .progress-ring__circle {
        filter: drop-shadow(0 0 3px var(--unified-green-glow)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
    }
    
    @media (prefers-color-scheme: dark) {
        .progress-ring__circle {
            filter: drop-shadow(0 0 2px var(--unified-green-glow)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
        }
    }

    @font-face {
        font-family: 'Alibaba PuHuiTi 2.0';
        src: url('https://puhuiti.oss-cn-hangzhou.aliyuncs.com/AlibabaPuHuiTi-2-55-Regular/AlibabaPuHuiTi-2-55-Regular.woff2') format('woff2');
        font-weight: 400;
        font-style: normal;
        font-display: swap;
    }
    
    @font-face {
        font-family: 'Alibaba PuHuiTi 2.0';
        src: url('https://puhuiti.oss-cn-hangzhou.aliyuncs.com/AlibabaPuHuiTi-2-65-Medium/AlibabaPuHuiTi-2-65-Medium.woff2') format('woff2');
        font-weight: 500;
        font-style: normal;
        font-display: swap;
    }

    @font-face {
        font-family: 'Alibaba PuHuiTi 2.0';
        src: url('https://puhuiti.oss-cn-hangzhou.aliyuncs.com/AlibabaPuHuiTi-2-85-Bold/AlibabaPuHuiTi-2-85-Bold.woff2') format('woff2');
        font-weight: 700;
        font-style: normal;
        font-display: swap;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: 'Alibaba PuHuiTi 2.0', "SF Pro Text", "SF Pro Icons", "Helvetica Neue", Helvetica, Arial, sans-serif;
      background: var(--bg-app);
      color: var(--text-primary);
      font-size: 13px;
      line-height: 1.4;
      overflow: visible; /* Fixed height app */
      user-select: none;
    }

    /* Layout */
    .app {
      display: flex;
      flex-direction: column;
      height: 100vh;
      padding: 16px;
      gap: 8px;
      transition: all 0.4s var(--ease-spring);
      overflow: visible;
    }

    .app.minimized {
      padding: 0;
      background: transparent;
    }
    
    /* 最小化时隐藏 toast */
    .app.minimized .toast {
      display: none !important;
      opacity: 0 !important;
      pointer-events: none !important;
    }
    
    .app.minimized .main-content,
    .app.minimized .status-bar {
      display: none;
    }

    /* Header */
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-shrink: 0;
      height: 32px; /* Fixed header height */
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 8px;
      height: 24px;
      
      /* Fade-in animation on load */
      animation: fadeInScale 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
      animation-delay: 0.05s;
      opacity: 0;
    }

    .logo-box {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
    }
    
    .logo-box svg {
        display: block;
        width: 24px;
        height: 24px;
        /* Enhanced Skeuomorphism - Embossed/Inset effect */
        filter: drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5)) drop-shadow(0 -0.5px 0.5px rgba(0, 0, 0, 0.15));
    }

    @media (prefers-color-scheme: dark) {
        .logo-box svg {
            filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3)) drop-shadow(0 -0.5px 0.5px rgba(255, 255, 255, 0.05));
        }
    }
    

    .app-title {
      font-family: 'Archivo Black', sans-serif;
      font-weight: 400;
      font-size: 18px;
      letter-spacing: -0.01em;
      line-height: 1;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      /* Skeuomorphic text shadow - embedded/engraved effect */
      text-shadow: 0 1px 1px rgba(255, 255, 255, 0.5);
    }
    
    @media (prefers-color-scheme: dark) {
      .app-title {
        text-shadow: 0 1px 1px rgba(0, 0, 0, 0.3);
    }
    }

    /* Legacy .connection-pill styles removed to prevent conflicts with new Neumorphic styles */
    .connection-pill:empty {
        display: none;
    }
    
    /* 减少右箭头和文字之间的间距 */

    @media (prefers-color-scheme: dark) {
        .connection-pill {
            background: var(--pill-recessed-bg);
            color: var(--text-secondary);
        }
        .connection-pill.connected {
            background: var(--pill-recessed-bg); /* Remove green tint, keep neutral recessed look */
        }
        .connection-pill.waiting {
            background: var(--pill-recessed-bg); /* Keep neutral recessed background like other states */
        }
        .connection-pill.reconnect {
            background: rgba(255, 59, 48, 0.2);
        }
        .connection-pill.reconnect:hover {
            background: rgba(255, 59, 48, 0.3);
        }
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: 16px; /* Increased gap for neumorphic button shadows */
    }

    /* Neumorphic Icon Button (Top Toolbar & Small Actions) */
    .icon-btn {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: none;
      outline: none;
      background: var(--neu-ring-gradient);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      z-index: 100; /* Ensure icon buttons and their tooltips are above other elements */
      padding: 2px; /* Space for the inner face */
      overflow: visible;
      
      /* Outer Shadow + Ring Inner Shadow */
      box-shadow: 
        -3px -3px 6px var(--neu-shadow-light),
        3px 3px 6px var(--neu-shadow-dark),
        var(--neu-ring-inner-shadow);
      
      /* Pop-out animation on load */
      animation: iconPopOut 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
      opacity: 0;
    }
    
    /* Toolbar icons appear together */
    #openFolder,
    #openSettings,
    #toggleMinimize { 
      animation-delay: 0.4s; 
    }
    
    /* Inner Face */
    .neu-icon-inner {
        width: 100%;
        height: 100%;
        border-radius: 50%;
        background: var(--neu-face-bg);
        box-shadow: var(--neu-face-shadow);
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        pointer-events: none;
    }

    /* Icon Styling */
    .icon-btn svg {
      width: 16px;
      height: 16px;
      color: var(--icon-color);
      opacity: 0.6;
      transition: all 0.2s ease;
      /* Skeuomorphic depth for icon */
      filter: drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
      /* Ensure stroke width is respected if set in SVG */
      stroke-width: inherit; 
    }

    /* Force specific stroke width for folder icon */
    #openFolder svg {
        stroke-width: 3px !important;
    }
    
    @media (prefers-color-scheme: dark) {
        .icon-btn svg {
            filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
        }
    }

    /* Hover State */
    .icon-btn:hover {
      transform: none;
    }
    
    .icon-btn:hover .neu-icon-inner {
        background: var(--neu-face-bg-hover);
    }
    
    .icon-btn:hover svg {
      opacity: 1;
        color: var(--icon-off-color);
    }

    /* Active/Pressed State */
    .icon-btn:active {
      box-shadow: 
        -2px -2px 4px var(--neu-shadow-light),
        2px 2px 4px var(--neu-shadow-dark),
        var(--neu-ring-inner-shadow);
    }
    
    .icon-btn:active .neu-icon-inner {
        background: var(--neu-face-bg-active);
        box-shadow: var(--neu-face-shadow-active);
    }
    
    @media (prefers-color-scheme: dark) {
        .icon-btn:hover .neu-icon-inner {
            background: rgba(255,255,255,0.1);
        }
    }
    
    @media (prefers-color-scheme: dark) {
        .icon-btn:hover {
            background: rgba(255,255,255,0.1);
        }
    }
    
    /* Custom Select - Skeuomorphic */
    .settings-select {
      appearance: none;
      -webkit-appearance: none;
      background-color: var(--bg-secondary);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-s);
      padding: 6px 28px 6px 10px;
      font-size: 13px;
      color: var(--text-secondary); /* Grey text */
      cursor: pointer;
      /* Raised Style (凸起) */
      box-shadow:
        -2px -2px 5px var(--neu-shadow-light),
        2px 2px 5px var(--neu-shadow-dark);
      /* Chevron Down SVG */
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 8px center;
      background-size: 14px;
      transition: all 0.2s ease, width 0.15s ease;
    }

    .settings-select:hover {
      border-color: var(--border-hover);
      transform: none;
    }

    .settings-select:focus,
    .settings-select:active {
      outline: none;
      border-color: var(--border-light);
      /* Active state: Inset (凹陷) */
      box-shadow: 
        inset 2px 2px 5px var(--neu-shadow-dark),
        inset -2px -2px 5px var(--neu-shadow-light);
      transform: translateY(0);
    }
    
    /* Tooltip 样式 */
    .icon-btn[data-tooltip]:not(.no-tooltip)::after {
      content: attr(data-tooltip);
      position: absolute;
      top: calc(100% + 7px);
      left: 50%;
      transform: translateX(-50%) scale(0.9);
      background: var(--bg-card);
      color: var(--text-primary);
      padding: 5px 10px;
      border-radius: 6px;
      font-size: 12px;
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease 0s, transform 0.2s ease 0s;
      z-index: 1000;
      font-weight: 400;
      letter-spacing: 0.01em;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12), 0 1px 3px rgba(0, 0, 0, 0.08);
    }
    
    /* Tooltip 小尖角 */
    .icon-btn[data-tooltip]:not(.no-tooltip)::before {
      content: '';
      position: absolute;
      top: calc(100% + 3px);
      left: 50%;
      transform: translateX(-50%) scale(0.9);
      width: 0;
      height: 0;
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
      border-bottom: 4px solid var(--bg-card);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease 0s, transform 0.2s ease 0s;
      z-index: 1001;
      filter: drop-shadow(0 -1px 1px rgba(0, 0, 0, 0.06));
    }
    
    .icon-btn[data-tooltip]:not(.no-tooltip):hover::after,
    .icon-btn[data-tooltip]:not(.no-tooltip):hover::before {
      opacity: 1;
      transform: translateX(-50%) scale(1);
      transition-delay: 0.5s;
    }

    /* Update Banner - Neumorphic Style */
    .update-banner {
      display: none;
      background: var(--neu-face-bg);
      color: var(--text-secondary);
      padding: 12px;
      font-size: 11px;
      line-height: 1.4;
      border-radius: var(--radius-m);
      animation: slideDown 0.3s ease;
      flex-shrink: 0;
      margin: 12px 2px;
      /* Raised effect */
      box-shadow: 
        -2px -2px 5px var(--neu-shadow-light),
        2px 2px 5px var(--neu-shadow-dark);
      border: 1px solid rgba(255,255,255,0.1);
    }

    @media (prefers-color-scheme: dark) {
      .update-banner {
        background: var(--neu-face-bg);
        border-color: rgba(255,255,255,0.05);
      }
    }

    .update-banner.show {
      display: block;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    /* Button Pop-out Animation: From flat/recessed to raised neumorphic */
    @keyframes iconPopOut {
      0% {
        opacity: 0;
        box-shadow: 
          inset 2px 2px 4px rgba(0, 0, 0, 0.15),
          inset -2px -2px 4px rgba(255, 255, 255, 0.7);
        transform: scale(0.9);
      }
      60% {
        transform: scale(1.05);
      }
      100% {
        opacity: 1;
        transform: scale(1);
      }
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .spinner {
      border: 2px solid var(--bg-secondary);
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    
    /* Recessed element push-in animation: From raised to recessed */
    @keyframes pushInRecessed {
      0% {
        opacity: 0;
        box-shadow: 
          -2px -2px 4px var(--neu-shadow-light),
          2px 2px 4px var(--neu-shadow-dark);
        transform: scale(1.05) translateY(-2px);
      }
      60% {
        transform: scale(0.98) translateY(1px);
      }
      100% {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }
    
    /* Simple fade-in scale for flat elements */
    @keyframes fadeInScale {
      0% {
        opacity: 0;
        transform: scale(0.95);
      }
      100% {
        opacity: 1;
        transform: scale(1);
      }
    }
    
    /* Rotate animation for loading spinner */
    @keyframes rotate {
      from {
        transform: rotate(-90deg);
      }
      to {
        transform: rotate(270deg);
      }
    }
    
    /* Icon completion glow animation - blink twice like physical LED button */
    @keyframes iconCompletionGlow {
      /* First blink - Fast rise, slower decay (LED characteristic) */
      0% {
        filter: drop-shadow(0 0 0px rgba(77, 227, 79, 0)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
        color: var(--icon-off-color); /* Original color */
        opacity: 0.5; /* Original opacity */
      }
      8% {
        /* Quick rise to peak brightness - Concentrated glow + GREEN color */
        filter: drop-shadow(0 0 6px rgba(77, 227, 79, 1)) drop-shadow(0 0 12px rgba(77, 227, 79, 0.9)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
        color: var(--unified-green); /* Bright green fill */
        opacity: 1; /* Full brightness */
      }
      12% {
        /* Hold at peak briefly */
        filter: drop-shadow(0 0 6px rgba(77, 227, 79, 1)) drop-shadow(0 0 12px rgba(77, 227, 79, 0.9)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
        color: var(--unified-green); /* Bright green fill */
        opacity: 1; /* Full brightness */
      }
      25% {
        /* Gradual decay with afterglow */
        filter: drop-shadow(0 0 3px rgba(77, 227, 79, 0.5)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
        color: var(--unified-green); /* Still green */
        opacity: 1; /* Full brightness */
      }
      32% {
        /* Complete fade */
        filter: drop-shadow(0 0 0px rgba(77, 227, 79, 0)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
        color: var(--icon-off-color); /* Back to original */
        opacity: 0.5; /* Back to original */
      }
      
      /* Brief pause between blinks */
      40% {
        filter: drop-shadow(0 0 0px rgba(77, 227, 79, 0)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
        color: var(--icon-off-color); /* Original color */
        opacity: 0.5; /* Original opacity */
      }
      
      /* Second blink - Same pattern */
      48% {
        filter: drop-shadow(0 0 6px rgba(77, 227, 79, 1)) drop-shadow(0 0 12px rgba(77, 227, 79, 0.9)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
        color: var(--unified-green); /* Bright green fill */
        opacity: 1; /* Full brightness */
      }
      52% {
        filter: drop-shadow(0 0 6px rgba(77, 227, 79, 1)) drop-shadow(0 0 12px rgba(77, 227, 79, 0.9)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
        color: var(--unified-green); /* Bright green fill */
        opacity: 1; /* Full brightness */
      }
      65% {
        filter: drop-shadow(0 0 3px rgba(77, 227, 79, 0.5)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
        color: var(--unified-green); /* Still green */
        opacity: 1; /* Full brightness */
      }
      72%, 100% {
        filter: drop-shadow(0 0 0px rgba(77, 227, 79, 0)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
        color: var(--icon-off-color); /* Back to original */
        opacity: 0.5; /* Back to original */
      }
    }
    
    @media (prefers-color-scheme: dark) {
      @keyframes iconCompletionGlow {
        /* First blink - More pronounced for dark theme */
        0% {
          filter: drop-shadow(0 0 0px rgba(77, 227, 79, 0)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
          color: var(--icon-off-color); /* Original color */
          opacity: 0.5; /* Original opacity */
        }
        8% {
          /* Concentrated bright glow + GREEN color - Use unified green values */
          filter: drop-shadow(0 0 5px rgba(77, 227, 79, 1)) drop-shadow(0 0 10px rgba(77, 227, 79, 0.8)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
          color: var(--unified-green); /* Unified green fill */
          opacity: 1; /* Full brightness */
        }
        12% {
          filter: drop-shadow(0 0 5px rgba(77, 227, 79, 1)) drop-shadow(0 0 10px rgba(77, 227, 79, 0.8)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
          color: var(--unified-green); /* Unified green fill */
          opacity: 1; /* Full brightness */
        }
        25% {
          filter: drop-shadow(0 0 3px rgba(77, 227, 79, 0.4)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
          color: var(--unified-green); /* Still green */
          opacity: 1; /* Full brightness */
        }
        32% {
          filter: drop-shadow(0 0 0px rgba(77, 227, 79, 0)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
          color: var(--icon-off-color); /* Back to original */
          opacity: 0.5; /* Back to original */
        }
        
        /* Brief pause */
        40% {
          filter: drop-shadow(0 0 0px rgba(77, 227, 79, 0)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
          color: var(--icon-off-color); /* Original color */
          opacity: 0.5; /* Original opacity */
        }
        
        /* Second blink */
        48% {
          filter: drop-shadow(0 0 5px rgba(77, 227, 79, 1)) drop-shadow(0 0 10px rgba(77, 227, 79, 0.8)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
          color: var(--unified-green); /* Unified green fill */
          opacity: 1; /* Full brightness */
        }
        52% {
          filter: drop-shadow(0 0 5px rgba(77, 227, 79, 1)) drop-shadow(0 0 10px rgba(77, 227, 79, 0.8)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
          color: var(--unified-green); /* Unified green fill */
          opacity: 1; /* Full brightness */
        }
        65% {
          filter: drop-shadow(0 0 3px rgba(77, 227, 79, 0.4)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
          color: var(--unified-green); /* Still green */
          opacity: 1; /* Full brightness */
        }
        72%, 100% {
          filter: drop-shadow(0 0 0px rgba(77, 227, 79, 0)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
          color: var(--icon-off-color); /* Back to original */
          opacity: 0.5; /* Back to original */
        }
      }
    }
    
    /* Apply animation class with custom easing for LED-like effect */
    .icon-completion-glow {
      animation: iconCompletionGlow 1.4s cubic-bezier(0.22, 1, 0.36, 1);
    }

    .update-banner-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .update-banner-info {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .update-banner-icon {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
      color: var(--text-secondary);
    }

    .update-banner-text {
      flex: 1;
      font-weight: 500;
      font-size: 13px;
      color: var(--text-secondary);
    }

    .update-banner-actions {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-shrink: 0;
    }

    .update-banner-btn {
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
      /* Neumorphic Button Style */
      background: var(--neu-face-bg);
      color: var(--text-secondary);
      box-shadow: 
        -2px -2px 5px var(--neu-shadow-light),
        2px 2px 5px var(--neu-shadow-dark);
    }

    .update-banner-btn.primary {
      color: var(--accent);
      font-weight: 600;
    }

    .update-banner-btn.primary:hover {
      filter: brightness(1.1);
    }
    
    .update-banner-btn:active {
      box-shadow: 
        inset 2px 2px 5px var(--neu-shadow-dark),
        inset -2px -2px 5px var(--neu-shadow-light);
    }
    
    /* 透明状态：去除拟物效果，仅显示文字 */
    .update-banner-btn.primary.transparent {
      background: transparent;
      color: var(--text-secondary);
      font-weight: 500;
      cursor: default;
      pointer-events: none;
      box-shadow: none;
    }
    
    .update-banner-btn.primary.transparent:hover {
      filter: none;
      box-shadow: none;
    }

    .update-banner-btn.secondary {
      /* Uses default neumorphic style defined in .update-banner-btn */
    }

    .update-banner-btn.secondary:hover {
      color: var(--text-primary);
    }

    .update-banner-btn:disabled {
      /* opacity: 0.5; */ /* Disable default opacity reduction */
      opacity: 1; /* Keep full opacity */
      cursor: not-allowed;
      /* box-shadow: none; */ /* Keep the shadow (button style) */
      color: var(--text-tertiary); /* Optional: make text lighter to indicate disabled, but user said 'maintain button style' */
      /* Actually user wants to maintain button style during download, so maybe keep original color or slight change */
    }

    .update-banner-close {
      width: 24px;
      height: 24px;
      padding: 0;
      background: var(--neu-face-bg);
      border: none;
      border-radius: 50%;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      flex-shrink: 0;
      /* Neumorphic Style */
      box-shadow: 
        -2px -2px 5px var(--neu-shadow-light),
        2px 2px 5px var(--neu-shadow-dark);
    }

    .update-banner-close svg {
      width: 10px;
      height: 10px;
    }

    .update-banner-close:hover {
      color: var(--text-primary);
    }

    .update-banner-close:active {
      box-shadow: 
        inset 2px 2px 5px var(--neu-shadow-dark),
        inset -2px -2px 5px var(--neu-shadow-light);
    }

    /* Main Content Area */
    .main-content {
      flex: 1;
      position: relative;
      overflow: visible;
    }

    /* Mode Selection View */
    .mode-selection {
      display: flex;
      flex-direction: column;
      gap: 12px;
      height: 100%;
      animation: zoomIn 0.4s var(--ease-out);
      text-align: center;
    }

    .section-title {
      font-size: 15px;
      font-weight: 700;
      margin: 0 0 4px 0;
      letter-spacing: -0.02em;
      color: var(--neu-text);
      opacity: 0.8;
    }

    .section-desc {
      color: var(--text-secondary);
        font-size: 12px;
        margin-bottom: 8px;
    }

    .card-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .feature-card {
      background: var(--bg-card);
      border: 1px solid transparent;
      border-radius: var(--radius-m);
      padding: 15px;
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: space-between;
      text-align: left;
      gap: 0;
      cursor: pointer;
      transition: all 0.3s var(--ease-spring);
      box-shadow: var(--shadow-sm);
      position: relative;
      overflow: visible; /* Allow glow effects */
    }

    .feature-card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .card-icon {
      width: 40px;
      height: 40px;
      border-radius: 50%; /* Circular icons */
      /* background: var(--bg-app); */
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      transition: all 0.3s ease;
      margin-bottom: 0;
      margin-right: 12px;
    }
    
    .card-icon img {
        width: 24px;
        height: 24px;
    }

    .card-content {
      flex: 1;
      width: 100%;
    }

    .card-title {
      font-weight: 600;
      font-size: 14px;
      margin-bottom: 2px;
      color: var(--text-primary);
    }

    .card-desc {
      font-size: 12px;
      color: var(--text-secondary);
      line-height: 1.4;
    }

    /* Upload mode cards - centered titles */
    .feature-card.mode-card {
      align-items: center;
    }
    
    .feature-card.mode-card .card-icon {
      margin-right: 0;
      margin-bottom: 4px;
    }
    
    .feature-card.mode-card .card-content {
      text-align: center;
    }
    
    .feature-card.mode-card .card-title {
      text-align: center;
    }
    
    .feature-card.mode-card .card-desc {
      text-align: center;
    }

    /* Selected Checkmark */
    .checkmark {
      position: absolute;
      top: 0;
      right: 0;
      background: var(--accent);
      width: 24px;
      height: 24px;
      border-bottom-left-radius: calc(var(--radius-m) - 1px);
      border-top-right-radius: calc(var(--radius-m) - 1px); /* Match card radius */
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    .checkmark svg {
      width: 14px;
      height: 14px;
      color: white;
    }

    .feature-card.selected .checkmark {
      display: flex;
    }
    
    .chevron {
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-tertiary);
      margin-left: 8px;
    }
    
    .chevron svg {
        width: 20px; 
        height: 20px;
    }

    /* Main Content Reset */
    .main-content {
      height: 100%;
      display: flex;
      flex-direction: column;
    }

    /* Realtime Header & Status Pill Alignment */
    .realtime-header {
      width: 100%;
      display: flex;
      justify-content: flex-end;
      padding: 24px 24px 0 0; /* Padding prevents shadow clipping */
      box-sizing: border-box;
      overflow: visible; /* Allow close button to extend outside */
    }
    
    /* Status Pill - Convex Neumorphic Style */
    .connection-pill {
        /* Default State: Pressed (Recessed) Style like reference image */
        background: var(--pill-recessed-bg);
        box-shadow: var(--pill-recessed-shadow);

        border-radius: 999px; /* Pill shape */
        padding: 0 14px; /* Horizontal padding */
        height: 34px;    /* Fixed Height */
        
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px; /* Gap between dot and text */
        
        position: relative;
        z-index: 10; /* Ensure high z-index */
        overflow: visible; /* Prevent internal clipping */
            
        color: var(--pill-screen-text); /* Green text */
        font-weight: 600;
        font-size: 13px;
        /* 丝滑过渡效果 */
        transition: background 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), 
                    box-shadow 0.4s cubic-bezier(0.34, 1.56, 0.64, 1),
                    color 0.4s cubic-bezier(0.34, 1.56, 0.64, 1),
                    transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1),
                    width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        border: none; /* Reset */
        white-space: nowrap; /* Prevent text wrapping during transition */
        
        /* Push-in recessed animation on load */
        animation: pushInRecessed 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        animation-delay: 0.15s;
        opacity: 0;
    }

    /* Subtle inner highlight for pressed look */
    .connection-pill::before {
        content: "";
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        border-radius: 999px;
        background: linear-gradient(145deg, transparent 0%, rgba(255,255,255,0.1) 100%);
        pointer-events: none;
        z-index: -1;
        opacity: 0.5;
    }
    
    /* Interactive State - Becomes Physical Button (Raised) */
    .connection-pill.interactive {
        background: var(--pill-interactive-bg);
        /* Convex Shadows (Physical Button - Raised) */
        box-shadow: 
            -5px -5px 10px var(--neu-shadow-light),
            5px 5px 10px var(--neu-shadow-dark);
        cursor: pointer;
    }

    /* Interactive - Change to raised look */
    .connection-pill.interactive::before {
        background: linear-gradient(145deg, rgba(255,255,255,0.5) 0%, transparent 100%);
        opacity: 1;
    }
    
    /* Bezel (Outer Ring) - Only visible when interactive */
    .connection-pill .bezel {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        border-radius: 999px;
        background: var(--neu-ring-gradient);
        box-shadow: var(--neu-ring-inner-shadow);
        z-index: -2;
        opacity: 0;
        transition: opacity 0.4s ease;
    }
    
    .connection-pill.interactive .bezel {
        opacity: 1;
    }
    
    /* Face (Inner Surface) - Only visible when interactive */
    .connection-pill .face {
        position: absolute;
        top: 3px; left: 3px; right: 3px; bottom: 3px;
        border-radius: 999px;
        background: var(--neu-face-bg);
        box-shadow: var(--neu-face-shadow);
        z-index: -1;
        opacity: 0;
        transition: opacity 0.4s ease;
    }

    .connection-pill.interactive .face {
        opacity: 1;
    }

    /* Status Dot Style */
    .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background-color: currentColor; /* Inherit color from parent by default */
        flex-shrink: 0;
        transition: all 0.3s ease;
    }

    /* Connected State - Screen text color */
    .connection-pill.connected {
        color: var(--pill-screen-text);
        /* text-shadow inherited from global rule */
    }
    
    .connection-pill.connected .status-dot {
        background-color: var(--pill-screen-text);
        /* Only the dot glows - single layer is enough */
        box-shadow: 0 0 6px var(--pill-screen-text), 0 0 12px var(--pill-screen-text-glow);
    }
    
    @media (prefers-color-scheme: dark) {
        .connection-pill.connected .status-dot {
            /* Reduce glow spread in dark theme */
            box-shadow: 0 0 5px var(--pill-screen-text), 0 0 10px var(--pill-screen-text-glow);
        }
        
        /* Interactive button in dark theme - remove white edge glow */
        .connection-pill.interactive {
            /* Only use dark shadows, no white highlights */
            box-shadow: 
                5px 5px 10px var(--neu-shadow-dark),
                -2px -2px 6px rgba(255, 255, 255, 0.02); /* Minimal highlight */
        }
        
        /* Reduce white highlights on bezel and face in dark theme */
        .connection-pill.interactive .bezel {
            box-shadow: inset 1px 1px 2px rgba(255,255,255,0.02); /* Much darker */
        }
        
        .connection-pill.interactive .face {
            box-shadow: 
                inset 1px 1px 2px rgba(255,255,255,0.03),
                inset -1px -1px 2px rgba(0,0,0,0.3);
        }
        
        .connection-pill.interactive::before {
            /* Reduce screen gloss in dark theme */
            background: linear-gradient(145deg, rgba(255,255,255,0.03) 0%, transparent 100%);
        }
    }
    
    /* Apply glow to SVGs inside connected pill - handled by global rule now */
    
    /* Disconnected State - Red Text & Red Glowing Dot */
    .connection-pill.reconnect {
        color: var(--danger);
    }

    .connection-pill.reconnect .status-dot {
        background-color: var(--danger);
        box-shadow: 0 0 6px var(--danger), 0 0 12px rgba(255, 59, 48, 0.6);
    }
    
    @media (prefers-color-scheme: dark) {
        .connection-pill.reconnect .status-dot {
             box-shadow: 0 0 5px var(--danger), 0 0 10px rgba(255, 69, 58, 0.4);
        }
    }

    /* Offline State - Gray Text & Gray Dot (No Glow) */
    .connection-pill.offline {
        color: var(--neu-text);
    }
    
    .connection-pill.offline .status-dot {
        background-color: var(--neu-text);
        box-shadow: none; /* No glow for offline */
    }

    /* Waiting / Warning State */
    .connection-pill.waiting {
        color: #007AFF; /* Blue instead of Orange */
        /* Keep recessed style - no button shadow override */
        box-shadow: var(--pill-recessed-shadow);
    }
    
    .connection-pill.waiting .status-dot {
         background-color: #007AFF;
         box-shadow: 0 0 6px #007AFF, 0 0 12px rgba(0, 122, 255, 0.4);
    }
    
    @media (prefers-color-scheme: dark) {
        .connection-pill.waiting .status-dot {
             box-shadow: 0 0 5px #007AFF, 0 0 10px rgba(0, 122, 255, 0.3); /* Subtler for dark theme */
        }
    }

    /* Status Pill Close Button - Neumorphic Style */
    .connection-pill .pill-close-btn {
        position: absolute;
        top: -7px;
        right: -7px;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: transparent;
        border: none;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        opacity: 0;
        transform: scale(0.8);
        transition: opacity 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
        z-index: 10;
        /* Neumorphic Shadow */
        box-shadow: 
            -2px -2px 4px var(--neu-shadow-light),
            2px 2px 4px var(--neu-shadow-dark);
    }

    /* Close Button Ring */
    .connection-pill .pill-close-btn::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: 50%;
        background: var(--neu-ring-gradient);
        box-shadow: var(--neu-ring-inner-shadow);
        z-index: -2;
        pointer-events: none;
    }

    /* Close Button Face */
    .connection-pill .pill-close-btn::after {
        content: "";
        position: absolute;
        inset: 2px;
        border-radius: 50%;
        background: var(--neu-face-bg);
        box-shadow: var(--neu-face-shadow);
        z-index: -1;
        transition: all 0.2s ease;
        pointer-events: none;
    }

    .connection-pill .pill-close-btn svg {
        width: 8px;
        height: 8px;
        position: relative;
        z-index: 1;
        opacity: 0.5;
        color: var(--icon-color);
        stroke: currentColor;
        transition: opacity 0.2s ease, color 0.2s ease;
        filter: drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
    }

    .connection-pill.interactive:hover .pill-close-btn {
        opacity: 1;
        transform: scale(1);
    }

    .connection-pill .pill-close-btn:hover {
        box-shadow: 
            -3px -3px 6px var(--neu-shadow-light),
            3px 3px 6px var(--neu-shadow-dark);
    }

    .connection-pill .pill-close-btn:hover::after {
        background: var(--neu-face-bg-hover);
    }

    .connection-pill .pill-close-btn:hover svg {
        opacity: 1;
        color: var(--icon-off-color);
    }

    .connection-pill .pill-close-btn:active {
        box-shadow: 
            -1px -1px 2px var(--neu-shadow-light),
            1px 1px 2px var(--neu-shadow-dark);
    }

    .connection-pill .pill-close-btn:active::after {
        background: var(--neu-face-bg-active);
        box-shadow: var(--neu-face-shadow-active);
    }

    @media (prefers-color-scheme: dark) {
        .connection-pill .pill-close-btn {
            box-shadow: 
                2px 2px 4px var(--neu-shadow-dark),
                -1px -1px 3px rgba(255, 255, 255, 0.02);
        }

        .connection-pill .pill-close-btn:hover {
            box-shadow: 
                3px 3px 6px var(--neu-shadow-dark),
                -1px -1px 4px rgba(255, 255, 255, 0.02);
        }

        .connection-pill .pill-close-btn svg {
            filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
        }
    }

    /* Realtime Center Layout */
    .realtime-center {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      padding: 0 32px 60px 32px; /* Side padding prevents button shadow clipping */
      box-sizing: border-box;
      overflow: visible; /* Ensure glow effects are not clipped */
    }

    .controls-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 24px; /* Tighter spacing between buttons */
      width: 100%;
      overflow: visible; /* Ensure glow effects are not clipped */
    }

    .control-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      overflow: visible;
    }

    .control-label {
      font-size: 13px;
      font-weight: 600;
      color: var(--neu-text); /* Use variable for dark mode */
      opacity: 0.8;
      letter-spacing: 0.5px;
      /* text-shadow inherited from global rule */
    }

    #realtimeLabel.control-label {
        font-size: 15px; /* Realtime label becomes 15px */
    }

    /* Neumorphic Buttons - Physical Style (Raised/Convex) */
    .neumorphic-btn {
      border: none;
      outline: none;
      background: transparent;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      color: var(--icon-color);
      transition: all 0.2s ease;
      padding: 0;
      overflow: visible;
      
      /* Outer Drop Shadow - Softer, more refined */
      box-shadow: 
        -6px -6px 14px var(--neu-shadow-light),
        6px 6px 14px var(--neu-shadow-dark);
      
      /* Pop-out animation on load (same as icon buttons) */
      animation: iconPopOut 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
      opacity: 0;
    }
    
    /* Stagger animation delays for main buttons */
    .neumorphic-btn:nth-of-type(1) { animation-delay: 0.1s; }
    .neumorphic-btn:nth-of-type(2) { animation-delay: 0.2s; }
    .neumorphic-btn:nth-of-type(3) { animation-delay: 0.3s; }
    
    /* The Ring (Outer Bezel) */
    .neumorphic-btn::before {
        content: "";
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        border-radius: 50%;
        
        /* Ring Gradient - Subtle */
        background: var(--neu-ring-gradient);
        box-shadow: var(--neu-ring-inner-shadow);
        
        z-index: -2;
        pointer-events: none;
    }
    
    /* The Face (Inner Button Cap) */
    .neumorphic-btn::after {
        content: "";
        position: absolute;
        top: 4px; left: 4px; right: 4px; bottom: 4px; 
        border-radius: 50%;
        background: var(--neu-face-bg);
        
        /* Face Relief - Subtle inner shadows */
        box-shadow: var(--neu-face-shadow);
            
        z-index: -1;
        transition: all 0.2s ease;
        pointer-events: none;
    }
    
    /* Hover State */
    .neumorphic-btn:hover {
      transform: none;
    }
    
    .neumorphic-btn:hover::after {
        background: var(--neu-face-bg-hover);
    }

    /* Pressed / Active State */
    .neumorphic-btn:active, .neumorphic-btn.pressed {
      transform: none;
      box-shadow: 
        -4px -4px 8px var(--neu-shadow-light),
        4px 4px 8px var(--neu-shadow-dark);
    }
    
    .neumorphic-btn:active::after, .neumorphic-btn.pressed::after {
        background: var(--neu-face-bg-active);
        box-shadow: var(--neu-face-shadow-active);
    }

    /* Button Sizes */
    .neumorphic-btn.large {
      width: 120px;
      height: 120px;
    }
    
    /* Adjust ring size for large button if needed */
    .neumorphic-btn.large::after {
        top: 8px; left: 8px; right: 8px; bottom: 8px;
    }

    .neumorphic-btn.small {
      width: 60px;
      height: 60px;
    }

    /* Icon Styling - Must be above layers */
    .neumorphic-btn svg, 
    .neumorphic-btn .btn-text,
    .neumorphic-btn .progress-ring {
      position: relative;
      z-index: 1;
      transition: all 0.2s ease;
    }
    
    .neumorphic-btn svg {
      opacity: 0.6; /* Match icon-btn opacity */
      color: var(--icon-color); /* Match icon-btn color */
    }
    
    .neumorphic-btn:hover svg {
        opacity: 1; /* Full opacity on hover */
        color: var(--icon-off-color); /* Keep same color, just more visible */
    }
    
    .neumorphic-btn:active svg {
        opacity: 1;
        color: var(--icon-off-color);
    }

    .neumorphic-btn.large svg {
      width: 52px;
      height: 52px;
      stroke-width: 3;
    }

    .neumorphic-btn.small svg {
      width: 20px;
      height: 20px;
      stroke-width: 2.5;
    }

    /* Active State (Running) - Green Glow & Light */
    .neumorphic-btn.large.active::after {
       /* Keep pressed state or just light up? 
          Usually light up. Let's keep it convex but glowing icon. */
       background: var(--neu-face-bg);
       box-shadow: var(--neu-face-shadow);
    }

    /* Override standard active styles for main button since we toggle SVGs */
    #mainStartBtn.active svg {
      filter: none;
    }
    
    /* Glow for icon-on - handled by global rule now */
    
    /* Main Start Button Icons Toggle */
    #mainStartBtn .icon-off {
        display: block;
        width: 50px; /* Updated size for new icon */
        height: 50px;
        opacity: 0.6; /* Match other icons */
        color: var(--icon-color); /* Match other icons */
        transition: opacity 0.3s ease;
    }
    
    #mainStartBtn:hover .icon-off {
        opacity: 1; /* Darken on hover */
        color: var(--icon-off-color); /* Darken on hover */
    }
    
    #mainStartBtn .icon-on {
        display: none;
        width: 50px; /* Updated size for new icon */
        height: 50px;
    }

    #mainStartBtn.active .icon-off {
        display: none;
    }

    #mainStartBtn.active .icon-on {
        display: block;
        opacity: 1 !important; /* Always full brightness when active, even without hover */
        color: var(--power-green); /* Green color when active */
    }
    
    /* Ensure icon-on stays bright even on hover */
    #mainStartBtn.active:hover .icon-on {
        opacity: 1 !important;
        color: var(--power-green);
    }

    /* Special styling for Manual Sync Icon */
    .neumorphic-btn.small svg.icon-manual-sync {
      width: 20px; /* Slightly larger for better visibility */
      height: 20px;
    }
    
    /* Special styling for GIF Text Icon */
    .neumorphic-btn.small svg.icon-gif-text {
      width: 24px; /* Restore to previous size */
      height: 24px;
    }

    .icon-gif-text path {
        fill: currentColor; /* Use text color */
        stroke: none !important; /* No stroke for text path */
    }

    /* Work Area View */
    .work-area {
      display: none;
      flex-direction: column;
      height: 100%;
      animation: zoomIn 0.4s var(--ease-spring);
      overflow: visible;
    }
    
    .work-area.active {
      display: flex;
    }

    /* Compact Status Hero - Optimized Layout */
    .status-hero {
      background: var(--bg-card);
      border-radius: var(--radius-m);
      padding: 16px 16px 20px 16px;
      /* border: 1px solid var(--border); */
      box-shadow: var(--shadow-sm);
      position: relative;
      overflow: visible; /* Allow glow effects */
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .hero-header {
      display: flex;
      align-items: center;
        justify-content: space-between;
        width: 100%;
    }
    
    .hero-mode-info {
      display: flex;
      align-items: center;
        gap: 8px;
    }
    
    /* New compact mode icon */
    .hero-icon-sm {
        width: 22px;
        height: 22px;
        border-radius: 50%;
      display: flex;
      align-items: center;
        justify-content: center;
        flex-shrink: 0;
    }
    
    .hero-icon-sm svg {
        width: 12px;
        height: 12px;
    }

    .hero-mode-title {
        font-size: 15px;
        font-weight: 600;
        color: var(--text-primary);
    }

    /* Main metric layout */
    .hero-main-metric {
      display: flex;
        align-items: baseline;
        justify-content: center;
        gap: 8px;
        padding: 8px 0;
    }

    .count-display {
      font-size: 48px;
      font-weight: 700;
      letter-spacing: -0.02em;
      color: var(--text-primary);
      line-height: 1;
      font-variant-numeric: tabular-nums;
    }

    .metric-label {
        font-size: 13px;
        color: var(--text-secondary);
        font-weight: 500;
    }

    /* Action buttons container */
    .action-buttons {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: auto; /* Push to bottom */
    }

    .btn {
      width: 100%;
      padding: 12px;
      border-radius: var(--radius-m);
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: all 0.2s ease;
      position: relative;
      background: transparent;
      color: var(--text-primary); /* Ensure text color adapts to theme */
      
      /* Softer Neumorphic Shadow */
      box-shadow: 
        -5px -5px 10px var(--neu-shadow-light),
        5px 5px 10px var(--neu-shadow-dark);
    }

    /* Button Ring */
    .btn::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: var(--radius-m);
        background: var(--neu-ring-gradient);
        box-shadow: var(--neu-ring-inner-shadow);
        z-index: -2;
        pointer-events: none;
    }
    
    /* Button Face */
    .btn::after {
        content: "";
        position: absolute;
        inset: 3px;
        border-radius: calc(var(--radius-m) - 3px);
        background: var(--neu-face-bg);
        box-shadow: var(--neu-face-shadow);
        z-index: -1;
        transition: all 0.2s ease;
        pointer-events: none;
    }
    
    .btn span, .btn svg {
        position: relative;
        z-index: 1;
    }

    .btn:active {
      box-shadow: 
        -3px -3px 6px var(--neu-shadow-light),
        3px 3px 6px var(--neu-shadow-dark);
    }
    
    .btn:active::after {
        background: var(--neu-face-bg-active);
        box-shadow: var(--neu-face-shadow-active);
    }

        .btn-primary {
      color: var(--neu-text);
        }
    
        .btn-primary:hover {
      box-shadow: 
        -6px -6px 12px var(--neu-shadow-light),
        6px 6px 12px var(--neu-shadow-dark);
        }
    
    .btn-primary:hover::after {
        background: var(--neu-face-bg-hover);
    }

    .btn-secondary {
      color: var(--text-primary);
    }

    .btn-secondary:hover {
      box-shadow: 
        -7px -7px 14px var(--neu-shadow-light),
        7px 7px 14px var(--neu-shadow-dark);
        }
    
    .btn-secondary:hover::after {
        background: var(--neu-face-bg-hover);
    }

    .btn-danger {
        color: var(--danger);
    }
    
    .btn-danger:hover {
        box-shadow: 
          -7px -7px 14px var(--neu-shadow-light),
          7px 7px 14px var(--neu-shadow-dark);
    }
    
    .btn-danger:hover::after {
        background: var(--neu-face-bg-hover);
    }
    
    @media (prefers-color-scheme: dark) {
        .btn-danger {
            color: #FF6B6B;
        }
    }

    /* Log Area */
    .log-wrapper {
        flex: 1;
        min-height: 0;
        /* border: 1px solid var(--border); */
        border-radius: var(--radius-s);
        background: var(--bg-card);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        margin-bottom: 12px;
    }
    
    .log-header {
        padding: 6px 12px;
        background: rgba(0,0,0,0.02);
        /* border-bottom: 1px solid var(--border); */
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        height: 28px;
    }
    
    .log-title {
        font-size: 12px;
        font-weight: 600;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    .log-content {
        flex: 1;
        padding: 8px 12px;
        overflow-y: auto;
        font-family: "SF Mono", Menlo, monospace;
        font-size: 12px;
        line-height: 1.6;
        color: var(--text-secondary);
        white-space: pre-wrap;
        transition: all 0.3s ease;
    }
    
    .log-wrapper.collapsed .log-content {
        display: none;
    }
    .log-wrapper.collapsed {
        flex: 0 0 auto;
    }

    /* Info Box */
    .info-box {
      background: var(--accent-soft);
      /* border: 1px solid rgba(0, 122, 255, 0.1); */
      color: var(--accent);
      padding: 12px;
      border-radius: var(--radius-s);
      font-size: 12px;
      margin-bottom: 8px;
      display: none;
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0);
      backdrop-filter: blur(0px);
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
      
      /* Hidden state properties */
      opacity: 0;
      visibility: hidden; /* Use visibility instead of display:none */
      pointer-events: none;
      
      /* Transitions including visibility delay */
      transition: opacity 0.25s cubic-bezier(0.33, 1, 0.68, 1),
                  background 0.25s cubic-bezier(0.33, 1, 0.68, 1),
                  backdrop-filter 0.25s cubic-bezier(0.33, 1, 0.68, 1),
                  visibility 0s linear 0.25s; /* Delay hiding visibility */
    }

    /* Modal Overlay - Show State */
    .modal-overlay.show {
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(8px);
      transition-delay: 0s; /* No delay when showing */
    }

    .modal {
      width: 90%;
      max-width: 360px;
      background: var(--bg-card);
      border-radius: var(--radius-l);
      padding: 0;
      transform: scale(0.92) translateY(20px);
      opacity: 0;
      transition: transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1),
                  opacity 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      overflow: visible; /* Allow glow effects to extend beyond modal */
      position: relative;
      
      /* Subtle Glass Morphism Shadow */
      box-shadow: 
        0 12px 40px rgba(0, 0, 0, 0.15),
        0 0 1px rgba(255, 255, 255, 0.1) inset;
      
      /* Subtle border for definition */
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .modal-overlay:not(.hidden) .modal {
      transform: scale(1) translateY(0);
      opacity: 1;
    }

    .modal-content {
        padding: 20px;
        overflow-y: auto;
        overflow-x: visible; /* Allow glow effects to show */
        flex: 0 1 auto;
        position: relative;
        z-index: 1;
        opacity: 0;
        transform: translateY(10px);
        transition: opacity 0.4s cubic-bezier(0.33, 1, 0.68, 1) 0.1s,
                    transform 0.4s cubic-bezier(0.33, 1, 0.68, 1) 0.1s;
        scrollbar-width: thin;
        scrollbar-color: var(--text-tertiary) transparent;
    }
    
    .modal-content::-webkit-scrollbar {
        width: 6px;
    }
    
    .modal-content::-webkit-scrollbar-track {
        background: transparent;
    }
    
    .modal-content::-webkit-scrollbar-thumb {
        background-color: var(--text-tertiary);
        border-radius: 3px;
    }
    
    .modal-content::-webkit-scrollbar-thumb:hover {
        background-color: var(--text-secondary);
    }

    .modal-overlay:not(.hidden) .modal-content {
        opacity: 1;
        transform: translateY(0);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 20px 8px 20px; 
      border-bottom: 1px solid var(--divider);
      background: transparent;
      z-index: 10;
      position: relative;
      flex-shrink: 0;
      opacity: 0;
      transform: translateY(-10px);
      transition: opacity 0.3s cubic-bezier(0.33, 1, 0.68, 1) 0.05s,
                  transform 0.3s cubic-bezier(0.33, 1, 0.68, 1) 0.05s;
    }

    .modal-overlay:not(.hidden) .modal-header {
        opacity: 1;
        transform: translateY(0);
    }

    .modal-title {
      font-size: 15px;
      font-weight: 700;
      color: var(--neu-text);
      opacity: 0.8;
    }
    
    /* Modal Tabs */
    .modal-tabs {
        display: flex;
        gap: 20px;
        align-items: center;
    }

    .tab-btn {
        background: transparent;
        border: none;
        padding:  0;
        font-size: 14px;
        font-weight: 600;
        color: var(--text-tertiary);
        cursor: pointer;
        position: relative;
        transition: color 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .tab-btn::after {
        content: '';
        position: absolute;
        bottom: -9px; /* Adjust based on header padding */
        left: 50%;
        right: 50%;
        height: 2px;
        background: var(--text-primary);
        border-radius: 2px;
        opacity: 0;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .tab-btn:hover {
        color: var(--text-secondary);
    }

    .tab-btn.active {
        color: var(--text-primary);
    }
    
    .tab-btn.active::after {
        left: 0;
        right: 0;
        opacity: 1;
    }
    
    /* Tab Content Animation */
    .tab-content {
        opacity: 0;
        transform: translateX(-20px);
        transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1), 
                    transform 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                    height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        display: none;
        overflow: visible; /* Allow glow effects */
    }
    
    .tab-content.active {
        opacity: 1;
        transform: translateX(0);
    }
    
    .tab-content.slide-out-left {
        opacity: 0;
        transform: translateX(-20px);
    }
    
    .tab-content.slide-out-right {
        opacity: 0;
        transform: translateX(20px);
    }
    
    .tab-content.slide-in-left {
        animation: slideInLeft 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }
    
    .tab-content.slide-in-right {
        animation: slideInRight 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }
    
    @keyframes slideInLeft {
        from {
            opacity: 0;
            transform: translateX(-20px);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }
    
    @keyframes slideInRight {
        from {
            opacity: 0;
            transform: translateX(20px);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }
    
    /* Modal buttons - proper height */
    .modal .btn {
      padding: 14px 16px;
      height: auto;
      min-height: 44px;
    }
    
    .close-btn {
        width: 28px;
        height: 28px;
        padding: 0;
      border-radius: 50%;
        background: transparent;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
        color: var(--icon-color);
      transition: all 0.2s ease;
      /* opacity: 0.6; Remove opacity on button to let icon handle it */
      transform: scale(1);
        position: relative;
        font-weight: 500;
        
        /* Softer Neumorphic Shadow */
        box-shadow: 
          -4px -4px 8px var(--neu-shadow-light),
          4px 4px 8px var(--neu-shadow-dark);
    }
    
    /* Close Button Ring */
    .close-btn::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: 50%;
        background: var(--neu-ring-gradient);
        box-shadow: var(--neu-ring-inner-shadow);
        z-index: -2;
        pointer-events: none;
    }
    
    /* Close Button Face */
    .close-btn::after {
        content: "";
        position: absolute;
        inset: 2px;
        border-radius: 50%;
        background: var(--neu-face-bg);
        box-shadow: var(--neu-face-shadow);
        z-index: -1;
        transition: all 0.2s ease;
        pointer-events: none;
    }
    
    .close-btn svg {
        position: relative;
        z-index: 1;
        opacity: 0.6;
        transition: all 0.2s ease;
        color: var(--icon-color);
        stroke: currentColor;
    }
    
    .close-btn:hover {
        box-shadow: 
          -5px -5px 10px var(--neu-shadow-light),
          5px 5px 10px var(--neu-shadow-dark);
    }
    
    .close-btn:hover svg {
        opacity: 1;
        color: var(--icon-off-color) !important;
    }
    
    .close-btn:hover::after {
        background: var(--neu-face-bg-hover);
    }
    
    .close-btn:active {
        box-shadow: 
          -2px -2px 4px var(--neu-shadow-light),
          2px 2px 4px var(--neu-shadow-dark);
    }
    
    .close-btn:active::after {
        background: var(--neu-face-bg-active);
        box-shadow: var(--neu-face-shadow-active);
    }
    
    /* Upload Modal Icon - Large Neumorphic */
    .neu-icon-large {
        box-shadow: 
            -5px -5px 10px var(--neu-shadow-light),
            5px 5px 10px var(--neu-shadow-dark);
        background: var(--neu-ring-gradient);
    }
    
    .neu-icon-large svg {
        color: var(--icon-color);
        stroke: currentColor;
        opacity: 0.6;
        filter: drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
    }

    @media (prefers-color-scheme: dark) {
        .neu-icon-large svg {
            filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
        }
    }
    
    /* Upload Modal Button Styling */
    #select-files-btn::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: 8px;
        background: var(--neu-ring-gradient);
        box-shadow: var(--neu-ring-inner-shadow);
        z-index: -2;
        pointer-events: none;
    }
    
    #select-files-btn::after {
        content: "";
        position: absolute;
        inset: 2px;
        border-radius: 6px;
        background: var(--neu-face-bg);
        box-shadow: var(--neu-face-shadow);
        z-index: -1;
        transition: all 0.2s ease;
        pointer-events: none;
    }
    
    #select-files-btn:hover {
        box-shadow: 
            -5px -5px 10px var(--neu-shadow-light),
            5px 5px 10px var(--neu-shadow-dark);
    }
    
    #select-files-btn:hover::after {
        background: var(--neu-face-bg-hover);
    }
    
    #select-files-btn:active {
        box-shadow: 
            -2px -2px 4px var(--neu-shadow-light),
            2px 2px 4px var(--neu-shadow-dark);
    }
    
    #select-files-btn:active::after {
        background: var(--neu-face-bg-active);
        box-shadow: var(--neu-face-shadow-active);
    }
    
    /* Upload Modal - Prevent scroll */
    #uploadGifOverlay .modal {
        max-height: 90vh;
        overflow: visible;
    }

    #uploadGifOverlay .modal-content {
        overflow: visible;
    }

    /* QR Code Zoom Modal */
    #qrZoomOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.25s ease, visibility 0.25s ease;
      cursor: zoom-out;
    }

    #qrZoomOverlay.show {
      opacity: 1;
      visibility: visible;
    }

    #qrZoomOverlay .qr-zoom-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      transform: scale(0.9);
      transition: transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    #qrZoomOverlay.show .qr-zoom-content {
      transform: scale(1);
    }

    #qrZoomOverlay .qr-zoom-image {
      width: 200px;
      height: 200px;
      border-radius: 12px;
      background: white;
      padding: 12px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
    }

    #qrZoomOverlay .qr-zoom-label {
      font-size: 14px;
      color: rgba(255, 255, 255, 0.9);
      font-weight: 500;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    /* QR Code clickable style */
    .qr-clickable {
      cursor: zoom-in;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .qr-clickable:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .qr-clickable:active {
      transform: scale(1.02);
    }
    
    /* Hide number input spinners */
    input[type=number]::-webkit-inner-spin-button, 
    input[type=number]::-webkit-outer-spin-button { 
        -webkit-appearance: none; 
        margin: 0; 
    }

    /* Input Styles - Pressed/Recessed Style like reference */
    .input-wrapper {
      display: flex;
      align-items: center;
        background: var(--pill-recessed-bg);
        border-radius: var(--radius-s);
        padding: 0 14px;
        height: 36px;
        border: none;
        transition: all 0.3s ease;
        position: relative;
        
        /* Pressed shadow (凹陷) */
        box-shadow: var(--pill-recessed-shadow);
    }
    
    /* Subtle inner highlight for depth */
    .input-wrapper::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: var(--radius-s);
        background: linear-gradient(145deg, transparent 0%, rgba(255,255,255,0.1) 100%);
        pointer-events: none;
        z-index: -1;
        opacity: 0.5;
    }
    
    @media (prefers-color-scheme: dark) {
        .input-wrapper::before {
            background: linear-gradient(145deg, transparent 0%, rgba(255,255,255,0.05) 100%);
        }
    }
    
    .input-wrapper:focus-within {
        box-shadow: 
            inset 3px 3px 6px rgba(0, 0, 0, 0.12),
            inset -2px -2px 5px rgba(255, 255, 255, 0.9),
            0 0 0 2px var(--logo-color-primary), /* Changed to blue */
            0 0 8px var(--accent-soft); /* Changed to blue glow */
    }
    
    @media (prefers-color-scheme: dark) {
        .input-wrapper:focus-within {
            box-shadow: 
                inset 3px 3px 6px rgba(0, 0, 0, 0.5),
                inset -2px -2px 5px rgba(255, 255, 255, 0.06),
                0 0 0 2px var(--logo-color-primary), /* Changed to blue */
                0 0 6px var(--accent-soft); /* Changed to blue glow */
        }
    }

    .input-prefix {
        color: var(--neu-text);
        opacity: 0.8;
        font-size: 13px;
        margin-right: 8px;
        font-weight: 500;
        white-space: nowrap;
        position: relative;
        z-index: 1;
    }

    /* Reset default input styles for use inside wrapper */
    .input-wrapper input {
        border: none;
        background: transparent;
        position: relative;
        z-index: 1;
        color: var(--text-secondary); /* Changed to grey */
        font-weight: 400;
        padding: 0;
        margin: 0;
        width: 100%;
        height: 100%;
        outline: none;
        box-shadow: none;
        font-size: 13px;
    }
    
    /* Focus state for input wrapper (applied via JS or :focus-within if wrapper supported it, 
       but here we likely target the wrapper based on input focus if structure allows, 
       or target input itself if wrapper style is on input) */
    /* Assuming .input-wrapper styles the container, we need to see how it's defined.
       Searching for .input-wrapper definition... */
    
    /* Placeholder color */
    .input-wrapper input::placeholder {
        color: var(--text-tertiary);
    }
    
    /* User ID Display Container - Screen Style */
    .user-id-display {
        background: var(--pill-recessed-bg);
        padding: 0 14px;
        height: 36px;
        border-radius: var(--radius-s);
        display: flex;
        align-items: center;
        justify-content: space-between;
        position: relative;
        box-shadow: var(--pill-recessed-shadow);
    }
    
    /* Hide scrollbar in User ID display */
    .user-id-display .id-content {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none; /* Firefox */
        -ms-overflow-style: none; /* IE/Edge */
        margin-right: 8px;
        white-space: nowrap;
        flex: 1; /* Allow content to take available space */
        position: relative;
        z-index: 1;
    }
    
    .user-id-display .id-content::-webkit-scrollbar {
        display: none; /* Chrome/Safari/Webkit */
        width: 0;
        height: 0;
    }
    
    .user-id-display::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: var(--radius-s);
        background: linear-gradient(145deg, transparent 0%, rgba(255,255,255,0.1) 100%);
        pointer-events: none;
        z-index: -1;
        opacity: 0.5;
    }
    
    @media (prefers-color-scheme: dark) {
        .user-id-display::before {
            background: linear-gradient(145deg, transparent 0%, rgba(255,255,255,0.05) 100%);
        }
    }
    
    .user-id-display #displayUserId {
        color: var(--logo-color-primary); /* Changed to blue */
        font-family: 'SF Mono', 'Menlo', monospace;
        font-size: 13px;
        font-weight: 500;
        letter-spacing: 0.5px;
        position: relative;
        z-index: 1;
    }
    
    .user-id-display button {
        position: relative;
        z-index: 1;
    }

    /* Toast */
    .toast {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%) translateY(-100px);
      background: var(--bg-card);
      /* border: 1px solid var(--border); */
      border-radius: var(--radius-m);
      padding: 8px 12px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12), 0 0 1px rgba(0, 0, 0, 0.1);
      font-size: 13px;
      font-weight: 500;
      color: #1D1D1F;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: all 0.5s var(--ease-spring);
      white-space: nowrap;
      width: fit-content;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    @media (prefers-color-scheme: dark) {
        .toast {
            color: #F5F5F7;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4), 0 0 1px rgba(255, 255, 255, 0.1);
        }
    }
    
    .toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
      pointer-events: auto;
    }
    
    .toast-icon {
      width: 14px;
      height: 14px;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .toast-icon svg {
      width: 100%;
      height: 100%;
    }
    
    .toast.success .toast-icon {
      color: var(--success);
    }
    
    .toast.error .toast-icon {
      color: var(--danger);
    }
    
    .toast.loading .toast-icon {
      color: var(--text-secondary);
    }
    
    .toast.loading .toast-icon svg {
      stroke: currentColor;
    }
    
    .toast-action {
      cursor: pointer;
      text-decoration: underline;
      text-underline-offset: 2px;
      margin-left: 6px;
      transition: opacity 0.2s ease;
    }
    
    .toast-action:hover {
      opacity: 0.8;
    }

    /* Utilities */
    .hidden { display: none !important; }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    @keyframes zoomIn {
      from { opacity: 0; transform: scale(0.92); }
      to { opacity: 1; transform: scale(1); }
    }
    
    /* Minimized State Styles */
    .minimized-toolbar {
        display: none;
        background: transparent;
        border: none;
        padding: 4px 4px 4px 12px;
        align-items: center;
        justify-content: space-between;
        box-shadow: none;
        height: 100%;
        animation: zoomIn 0.3s var(--ease-spring);
    }
    
    .app.minimized .minimized-toolbar {
        display: flex;
    }

    .minimized-brand {
      display: flex;
        align-items: center;
        gap: 6px;
        color: var(--text-primary);
    }
    
    .minimized-logo-box {
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .minimized-logo-box svg {
      display: block;
        width: 18px;
        height: 18px;
      /* Skeuomorphism - Embossed/Inset effect at path level */
      filter: drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5)) drop-shadow(0 -0.5px 0.5px rgba(0, 0, 0, 0.15));
    }

    @media (prefers-color-scheme: dark) {
      .minimized-logo-box svg {
        filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3)) drop-shadow(0 -0.5px 0.5px rgba(255, 255, 255, 0.05));
      }
    }
    
    .minimized-title {
      font-family: 'Archivo Black', sans-serif;
      font-weight: 400;
      font-size: 15px;
      margin-top: 2px;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      /* Skeuomorphic text shadow - embedded/engraved effect */
      text-shadow: 0 1px 1px rgba(255, 255, 255, 0.5);
    }
    
    @media (prefers-color-scheme: dark) {
      .minimized-title {
        text-shadow: 0 1px 1px rgba(0, 0, 0, 0.3);
      }
    }
    
    /* Minimized Toolbar Button - Neumorphic Style */
    .minimized-btn {
        width: 32px; /* Match icon-btn size */
        height: 32px;
      border-radius: 50%;
        border: none;
        outline: none;
        background: var(--neu-ring-gradient);
      display: flex;
      align-items: center;
      justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        position: relative;
        padding: 2px; /* Space for inner face */
        overflow: visible;
        
        /* Neumorphic Shadows */
        box-shadow: 
            -3px -3px 6px var(--neu-shadow-light),
            3px 3px 6px var(--neu-shadow-dark),
            var(--neu-ring-inner-shadow);
    }
    
    /* Reuse neu-icon-inner from icon-btn */
    
    /* Icon Styling */
    .minimized-btn svg {
        width: 15px; 
        height: 15px;
        color: var(--icon-color);
        opacity: 0.6;
        transition: all 0.2s ease;
        filter: drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
    }
    
    @media (prefers-color-scheme: dark) {
        .minimized-btn svg {
            filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
    }
    }
    
    /* Hover State */
    .minimized-btn:hover {
        transform: none;
    }
    
    .minimized-btn:hover .neu-icon-inner {
        background: var(--neu-face-bg-hover);
    }
    
    .minimized-btn:hover svg {
        opacity: 1;
        color: var(--icon-off-color);
    }
    
    /* Active State */
    .minimized-btn:active {
        box-shadow: 
            -2px -2px 4px var(--neu-shadow-light),
            2px 2px 4px var(--neu-shadow-dark),
            var(--neu-ring-inner-shadow);
    }
    
    .minimized-btn:active .neu-icon-inner {
        background: var(--neu-face-bg-active);
        box-shadow: var(--neu-face-shadow-active);
    }
    
    @media (prefers-color-scheme: dark) {
        .minimized-btn:hover .neu-icon-inner {
            background: rgba(255,255,255,0.1);
        }
    }
    
    .app.minimized .header {
        display: none;
    }
    
    /* Theme Specific Images */
    img.no-invert {
        filter: none !important;
      }

    /* SVG Icons */
    .svg-icon {
        width: 16px;
        height: 16px;
        stroke-width: 2;
        stroke: currentColor;
        fill: none;
        stroke-linecap: round;
        stroke-linejoin: round;
    }
    
    .svg-icon-sm {
        width: 15px;
        height: 15px;
    }

    /* Apple Switch - Neumorphic Style */
    .switch {
      position: relative;
      display: inline-block;
      width: 46px;
      height: 28px;
      flex-shrink: 0;
    }

    .switch input { 
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--pill-recessed-bg);
      transition: .3s ease;
      border-radius: 34px;
      /* Recessed track shadow */
      box-shadow: var(--pill-recessed-shadow);
    }

    /* Track subtle highlight */
    .slider::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 34px;
      background: linear-gradient(145deg, transparent 0%, rgba(255,255,255,0.1) 100%);
      pointer-events: none;
      z-index: -1;
      opacity: 0.5;
    }

    .slider::after {
      position: absolute;
      content: "";
      height: 24px;
      width: 24px;
      left: 2px;
      bottom: 2px;
      background: var(--neu-face-bg);
      transition: .3s ease;
      border-radius: 50%;
      z-index: 2;
      /* Neumorphic button shadow - softer */
      box-shadow: 
        -3px -3px 6px var(--neu-shadow-light),
        3px 3px 6px var(--neu-shadow-dark),
        inset 1px 1px 1px rgba(255,255,255,0.5);
    }

    input:checked + .slider {
      background: var(--switch-active-gradient);
      box-shadow: 
        inset 2px 2px 4px rgba(0, 0, 0, 0.25),
        inset -1px -1px 2px rgba(255, 255, 255, 0.15),
        0 0 8px var(--pill-screen-text-glow); /* Match status pill glow */
    }

    input:checked + .slider::before {
      background: linear-gradient(145deg, transparent 0%, rgba(255,255,255,0.2) 100%);
      opacity: 1;
    }

    input:checked + .slider::after {
      transform: translateX(18px);
      box-shadow: 
        -3px -3px 6px rgba(255, 255, 255, 0.2),
        3px 3px 6px rgba(0, 0, 0, 0.3),
        inset 1px 1px 1px rgba(255,255,255,0.7);
    }

    @media (prefers-color-scheme: dark) {
      /* Adjust thumb (::after) reflection for dark theme */
      .slider::after {
        box-shadow: 
          -3px -3px 6px var(--neu-shadow-light),
          3px 3px 6px var(--neu-shadow-dark),
          inset 1px 1px 1px rgba(255,255,255,0.08); /* Much subtler inner highlight */
      }
      
      input:checked + .slider {
        box-shadow: 
          inset 2px 2px 4px rgba(0, 0, 0, 0.4),
          inset -1px -1px 2px rgba(255, 255, 255, 0.08),
          0 0 5px var(--pill-screen-text-glow); /* Match status pill glow */
      }
      
      input:checked + .slider::before {
        background: linear-gradient(145deg, transparent 0%, rgba(255,255,255,0.08) 100%);
        opacity: 0.6;
      }
      
      input:checked + .slider::after {
        box-shadow: 
          -3px -3px 6px rgba(255, 255, 255, 0.1),
          3px 3px 6px rgba(0, 0, 0, 0.4),
          inset 1px 1px 1px rgba(255,255,255,0.15); /* Much subtler inner highlight */
      }
      
      .slider::before {
        background: linear-gradient(145deg, transparent 0%, rgba(255,255,255,0.05) 100%);
      }
    }

    /* Export GIF Button & Animations */
    /* Export GIF Button & Animations */
    #exportGifBtn {
        position: relative;
        overflow: visible; 
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.4s cubic-bezier(0.33, 1, 0.68, 1); /* Apple easeOut */
        color: var(--text-primary); /* Match other .icon-btn */
        padding: 0; /* Remove padding to center content exactly */
    }
    
    #exportGifBtn:hover {
        background: rgba(0,0,0,0.05);
    }
    
    /* 导出中的悬停状态 - 显示停止按钮 */
    #exportGifBtn.exporting:hover {
        /* Keep consistent hover style - no red color */
        background: rgba(0,0,0,0.08);
    }
    
    @media (prefers-color-scheme: dark) {
        #exportGifBtn:hover {
            background: rgba(255,255,255,0.1);
        }
        
        #exportGifBtn.exporting:hover {
            /* Keep consistent hover style - no red color */
            background: rgba(255,255,255,0.12);
        }
    }

    /* Progress Ring */
    .progress-ring {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.4s ease-out; /* Smooth fade out */
        z-index: 10;
    }
    
    /* 确保非导出状态下进度环完全隐藏 */
    #exportGifBtn:not(.exporting) .progress-ring {
        opacity: 0 !important;
    }
    
    .progress-ring__circle {
        fill: transparent;
        stroke: var(--unified-green); /* Green color */
        stroke-width: 4; /* Increased by 1px */
        stroke-linecap: round;
        transition: stroke-dashoffset 0.2s linear, stroke 0.3s ease;
        /* filter handled by global rule now */
    }
    
    /* Keep progress ring green on hover */
    #exportGifBtn.exporting:hover .progress-ring__circle {
        stroke: var(--unified-green); /* Keep green color */
    }

    /* Success State */
    #exportGifBtn.success {
        background-color: var(--success) !important;
        color: white !important;
        transform: scale(1.05); /* Subtle pulse */
        opacity: 1 !important; /* Force opacity to 100% in success state */
    }
    
    #exportGifBtn.success:hover {
        opacity: 1 !important; /* Maintain 100% opacity on hover in success state */
    }
    
    #exportGifBtn.success .progress-ring {
        opacity: 0;
    }

    /* Icon Morphing */
    .icon-wrapper {
        position: relative;
        width: 16px;
        height: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .icon-gif, .icon-stop, .icon-folder {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1); /* Bouncy spring */
        pointer-events: none;
        transform-origin: center center;
    }

    .icon-stop {
        opacity: 0;
        transform: scale(0.55) rotate(45deg);
        stroke-width: 2.5 !important; /* 更明显的加粗效果 */
    }
    
    /* 导出中且悬停时显示停止图标 */
    #exportGifBtn.exporting:hover .icon-gif {
        opacity: 0;
        transform: scale(0.6) rotate(-45deg);
    }
    
    #exportGifBtn.exporting:hover .icon-stop {
        opacity: 1;
        transform: scale(0.91) rotate(0deg);
    }

    .icon-folder {
        opacity: 0;
        transform: scale(0.4) rotate(45deg);
    }
    
    #exportGifBtn.success .icon-gif {
        opacity: 0;
        transform: scale(0.4) rotate(-45deg);
    }
    
    #exportGifBtn.success .icon-folder {
        opacity: 1;
        transform: scale(1) rotate(0deg);
    }

    /* Splash Effect */
    .splash-particle {
        position: absolute;
        width: 3px; /* Smaller particles */
        height: 3px;
        background: var(--success);
        border-radius: 50%;
        pointer-events: none;
        opacity: 0;
        z-index: 100;
      }
    
    @keyframes splash-anim {
        0% { transform: translate(0, 0) scale(1); opacity: 0.8; }
        50% { opacity: 1; }
        100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
    }
    /* ========================================
       Start Screen / Realtime Mode UI (Neumorphic)
       ======================================== */
    .realtime-header {
        display: flex;
        justify-content: flex-end; /* Right align status */
        padding: 16px 0px;
        top: 0;
        left: 0;
        right: 0;
        z-index: 10;
        pointer-events: none;
        overflow: visible; /* Allow close button to extend outside */
    }
    
    .realtime-header > * {
        pointer-events: auto;
    }
    
    .realtime-center {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 32px;
        margin-top: -20px; /* Optical centering adjustment */
        overflow: visible; /* Ensure glow effects are not clipped */
    }
    
    /* Controls Row - 3 Buttons Layout */
    .controls-row {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 24px; /* Tighter spacing between buttons */
        overflow: visible; /* Ensure glow effects are not clipped */
    }
    
    .control-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        overflow: visible; /* Ensure glow effects are not clipped */
    }
    
    /* .control-label duplicate removed */
    .control-item:hover .control-label {
        color: var(--text-secondary);
    }
    
    /* Duplicated styles removed */
  </style>
  <script>
    // GitHub 图片资源基础 URL
    const IMAGE_BASE_URL = 'https://raw.githubusercontent.com/BorderWalker99/figma-plugin-figma_sync/refs/heads/main/images/';
    
    // 根据主题获取二维码（使用 GitHub URL）
    function getQRCodeURI(isDark) {
      return {
        google: IMAGE_BASE_URL + (isDark ? 'qr-google-white.png' : 'qr-google-black.png'),
        googleScreenshot: IMAGE_BASE_URL + (isDark ? 'qr-google-white.png' : 'qr-google-black.png'),
        googleAlbum: IMAGE_BASE_URL + (isDark ? 'qr-google-album-white.png' : 'qr-google-album-black.png'),
        icloud: IMAGE_BASE_URL + (isDark ? 'qr-icloud-white.png' : 'qr-icloud-black.png'),
        icloudScreenshot: IMAGE_BASE_URL + (isDark ? 'qr-icloud-white.png' : 'qr-icloud-black.png'),
        icloudAlbum: IMAGE_BASE_URL + (isDark ? 'qr-icloud-album-white.png' : 'qr-icloud-album-black.png')
      };
    }
  </script>
</head>

<body>
  <div class="app">
    <!-- Header -->
    <div class="header">
      <div class="brand">
        <div class="logo-box">
          <svg width="18" height="18" viewBox="0 0 39 39" fill="none" xmlns="http://www.w3.org/2000/svg">
            <g clip-path="url(#clip0_1184_47)">
              <path d="M22.6328 0.916016H10.1807C4.65782 0.916016 0.180664 5.39317 0.180664 10.916V23.3681C0.180664 28.891 4.65782 33.3681 10.1807 33.3681H22.6328C28.1556 33.3681 32.6328 28.891 32.6328 23.3681V10.916C32.6328 5.39317 28.1556 0.916016 22.6328 0.916016Z" fill="#007AFF" fill-opacity="0.5"/>
              <path d="M28.6328 5.91602H16.1807C10.6578 5.91602 6.18066 10.3932 6.18066 15.916V28.3681C6.18066 33.891 10.6578 38.3681 16.1807 38.3681H28.6328C34.1556 38.3681 38.6328 33.891 38.6328 28.3681V15.916C38.6328 10.3932 34.1556 5.91602 28.6328 5.91602Z" fill="#007AFF"/>
              <g clip-path="url(#clip1_1184_47)">
                <path d="M22.4443 22.4091C22.4443 20.5015 23.9907 18.9551 25.8983 18.9551C27.8059 18.9551 29.3523 20.5015 29.3523 22.4091C29.3523 24.3167 27.8059 25.8631 25.8983 25.8631C23.9907 25.8631 22.4443 24.3167 22.4443 22.4091Z" fill="white"/>
                <path d="M25.8593 11.5872C25.9486 11.5803 26.0391 11.5762 26.1301 11.5762C28.0375 11.5763 29.5835 13.123 29.5835 15.0305C29.5833 16.9379 28.0374 18.4837 26.1301 18.4839C26.039 18.4839 25.9486 18.4789 25.8593 18.472V18.4848H22.8638C22.76 18.4848 22.6758 18.4006 22.6758 18.2968V11.7642C22.6758 11.6603 22.76 11.5762 22.8638 11.5762H25.8593V11.5872Z" fill="white"/>
                <path d="M19.023 11.5872C18.9338 11.5803 18.8433 11.5762 18.7522 11.5762C16.8448 11.5763 15.2988 13.123 15.2988 15.0305C15.299 16.9379 16.8449 18.4837 18.7522 18.4839C18.8433 18.4839 18.9337 18.4789 19.023 18.472V18.4848H22.0185C22.1224 18.4848 22.2065 18.4006 22.2065 18.2968V11.7642C22.2065 11.6603 22.1224 11.5762 22.0185 11.5762H19.023V11.5872Z" fill="white"/>
                <path d="M19.023 18.9661C18.9338 18.9592 18.8433 18.9551 18.7522 18.9551C16.8448 18.9553 15.2988 20.502 15.2988 22.4094C15.299 24.3168 16.8449 25.8626 18.7522 25.8628C18.8433 25.8628 18.9337 25.8578 19.023 25.8509V25.8637H22.0185C22.1224 25.8637 22.2065 25.7795 22.2065 25.6757V19.1431C22.2065 19.0392 22.1224 18.9551 22.0185 18.9551H19.023V18.9661Z" fill="white"/>
                <path d="M19.023 26.3489C18.9338 26.342 18.8433 26.3379 18.7522 26.3379C16.8448 26.3381 15.2988 27.8848 15.2988 29.7922C15.299 31.6996 16.8449 33.2454 18.7522 33.2456C20.5442 33.2456 22.018 31.8813 22.19 30.1346H22.2065V26.5259C22.2065 26.4221 22.1224 26.3379 22.0185 26.3379H19.023V26.3489Z" fill="white"/>
              </g>
            </g>
            <defs>
              <clipPath id="clip0_1184_47">
                <rect width="39" height="39" fill="white"/>
              </clipPath>
              <clipPath id="clip1_1184_47">
                <rect width="15.98" height="22.56" fill="white" transform="translate(14.416 10.8633)"/>
              </clipPath>
            </defs>
          </svg>
      </div>
        <div>
          <div class="app-title">SYNC</div>
        </div>
      </div>
      <div class="header-actions">
        <button id="openFolder" class="icon-btn" data-tooltip="打开文件夹">
           <div class="neu-icon-inner">
           <!-- Increased stroke-width to 3 and added style attribute to force it -->
           <svg class="svg-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" style="transform: scale(0.85); stroke-width: 2.5px !important;">
             <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
           </svg>
           </div>
        </button>
        <button id="openSettings" class="icon-btn" data-tooltip="设置">
           <div class="neu-icon-inner">
           <svg class="svg-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" style="stroke-width: 2px !important;">
             <circle cx="12" cy="12" r="3"></circle>
             <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
           </svg>
           </div>
        </button>
        <button id="toggleMinimize" class="icon-btn" data-tooltip="最小化窗口">
            <!-- Icon will be updated by JS, but default is minimize -->
            <div class="neu-icon-inner">
            <svg id="minimizeIcon" class="svg-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" style="stroke-width: 2px !important;">
              <polyline points="4 14 10 14 10 20"></polyline>
              <polyline points="20 10 14 10 14 4"></polyline>
            </svg>
            </div>
        </button>
      </div>
    </div>
    
    <!-- Update Banner -->
    <div class="update-banner" id="updateBanner">
      <div class="update-banner-content">
        <div class="update-banner-info">
          <svg class="update-banner-icon" viewBox="0 0 24 24" fill="currentColor">
            <path d="M19 9l1.25-2.75L23 5l-2.75-1.25L19 1l-1.25 2.75L15 5l2.75 1.25L19 9zm-7.5.5L9 4 6.5 9.5 1 12l5.5 2.5L9 20l2.5-5.5L17 12l-5.5-2.5z"/>
          </svg>
          <div class="update-banner-text" id="updateBannerText">发现新版本 v1.0.2</div>
        </div>
        <div class="update-banner-actions">
          <button class="update-banner-btn primary" id="updateBannerNow">立即更新</button>
          <button class="update-banner-close" id="updateBannerClose">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
        </div>
      </div>
    </div>
    
    <!-- Minimized Toolbar (Visible only when minimized) -->
    <div class="minimized-toolbar">
        <div class="minimized-brand">
          <div class="minimized-logo-box">
            <svg width="18" height="18" viewBox="0 0 39 39" fill="none" xmlns="http://www.w3.org/2000/svg">
              <g clip-path="url(#clip0_1184_47_min)">
                <path d="M22.6328 0.916016H10.1807C4.65782 0.916016 0.180664 5.39317 0.180664 10.916V23.3681C0.180664 28.891 4.65782 33.3681 10.1807 33.3681H22.6328C28.1556 33.3681 32.6328 28.891 32.6328 23.3681V10.916C32.6328 5.39317 28.1556 0.916016 22.6328 0.916016Z" fill="#007AFF" fill-opacity="0.5"/>
                <path d="M28.6328 5.91602H16.1807C10.6578 5.91602 6.18066 10.3932 6.18066 15.916V28.3681C6.18066 33.891 10.6578 38.3681 16.1807 38.3681H28.6328C34.1556 38.3681 38.6328 33.891 38.6328 28.3681V15.916C38.6328 10.3932 34.1556 5.91602 28.6328 5.91602Z" fill="#007AFF"/>
                <g clip-path="url(#clip1_1184_47_min)">
                  <path d="M22.4443 22.4091C22.4443 20.5015 23.9907 18.9551 25.8983 18.9551C27.8059 18.9551 29.3523 20.5015 29.3523 22.4091C29.3523 24.3167 27.8059 25.8631 25.8983 25.8631C23.9907 25.8631 22.4443 24.3167 22.4443 22.4091Z" fill="white"/>
                  <path d="M25.8593 11.5872C25.9486 11.5803 26.0391 11.5762 26.1301 11.5762C28.0375 11.5763 29.5835 13.123 29.5835 15.0305C29.5833 16.9379 28.0374 18.4837 26.1301 18.4839C26.039 18.4839 25.9486 18.4789 25.8593 18.472V18.4848H22.8638C22.76 18.4848 22.6758 18.4006 22.6758 18.2968V11.7642C22.6758 11.6603 22.76 11.5762 22.8638 11.5762H25.8593V11.5872Z" fill="white"/>
                  <path d="M19.023 11.5872C18.9338 11.5803 18.8433 11.5762 18.7522 11.5762C16.8448 11.5763 15.2988 13.123 15.2988 15.0305C15.299 16.9379 16.8449 18.4837 18.7522 18.4839C18.8433 18.4839 18.9337 18.4789 19.023 18.472V18.4848H22.0185C22.1224 18.4848 22.2065 18.4006 22.2065 18.2968V11.7642C22.2065 11.6603 22.1224 11.5762 22.0185 11.5762H19.023V11.5872Z" fill="white"/>
                  <path d="M19.023 18.9661C18.9338 18.9592 18.8433 18.9551 18.7522 18.9551C16.8448 18.9553 15.2988 20.502 15.2988 22.4094C15.299 24.3168 16.8449 25.8626 18.7522 25.8628C18.8433 25.8628 18.9337 25.8578 19.023 25.8509V25.8637H22.0185C22.1224 25.8637 22.2065 25.7795 22.2065 25.6757V19.1431C22.2065 19.0392 22.1224 18.9551 22.0185 18.9551H19.023V18.9661Z" fill="white"/>
                  <path d="M19.023 26.3489C18.9338 26.342 18.8433 26.3379 18.7522 26.3379C16.8448 26.3381 15.2988 27.8848 15.2988 29.7922C15.299 31.6996 16.8449 33.2454 18.7522 33.2456C20.5442 33.2456 22.018 31.8813 22.19 30.1346H22.2065V26.5259C22.2065 26.4221 22.1224 26.3379 22.0185 26.3379H19.023V26.3489Z" fill="white"/>
                </g>
              </g>
              <defs>
                <clipPath id="clip0_1184_47_min">
                  <rect width="39" height="39" fill="white"/>
                </clipPath>
                <clipPath id="clip1_1184_47_min">
                  <rect width="15.98" height="22.56" fill="white" transform="translate(14.416 10.8633)"/>
                </clipPath>
              </defs>
            </svg>
          </div>
          <span class="minimized-title">SYNC</span>
          </div>
         <button class="minimized-btn" onclick="toggleMinimize()">
       <div class="neu-icon-inner">
           <svg class="svg-icon" style="width: 15px; height: 15px;" viewBox="0 0 24 24"><polyline points="13 5 19 5 19 11"></polyline><polyline points="11 19 5 19 5 13"></polyline></svg>
       </div>
        </button>
    </div>

    <!-- Main Content -->
    <div class="main-content">

    <!-- Mode Selection (隐藏，默认实时模式) -->
    <div class="mode-selection hidden" id="modeSelection">
        <div>
          <h2 class="section-title">选择同步模式</h2>
          <!-- <div class="section-desc">同步后将自动清理源文件以释放空间</div> -->
      </div>
        
        <div class="card-grid">
          <div class="feature-card" id="realtimeBtn">
            <div class="card-icon" style="color: #FFCC00; background: rgba(255, 204, 0, 0.15);">
              <!-- Realtime: Lightning/Sync (Filled + Rounded) -->
              <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linejoin="round">
              <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"></path>
            </svg>
          </div>
            <div class="card-content">
              <div class="card-title">实时模式</div>
              <div class="card-desc">手机截图 实时导入</div>
            </div>
            <div class="chevron">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>
            </div>
        </div>

          <div class="feature-card" id="manualBtn">
            <div class="card-icon" style="color: var(--accent); background: var(--accent-soft);">
               <!-- Manual: Download (Arrow + Bar) - Adjusted for visual weight -->
               <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="0">
                 <path d="M19 9h-4V3H9v6H5l7 8 7-8zM5 19v3h14v-3H5z"></path>
            </svg>
          </div>
            <div class="card-content">
              <div class="card-title">手动模式</div>
              <div class="card-desc">云端截图 批量导入</div>
            </div>
            <div class="chevron">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>
            </div>
        </div>
      </div>
    </div>

    <!-- Work Area -->
      <div class="work-area" id="workArea">
        <div class="realtime-header">
                <div id="status" class="connection-pill">等待中</div>
        </div>

        <div class="realtime-center">
            
            <div class="controls-row">
                <!-- Left: Manual Sync -->
                <div class="control-item">
                    <button id="manualSyncBtn" class="neumorphic-btn small">
                        <!-- Custom Download Arrow Icon (Redesigned with Stroke for Better Visual Weight) -->
                        <svg class="icon-manual-sync" viewBox="0 0 381 375" fill="currentColor">
                            <path d="M152.866 0H211.604V272.717C211.604 288.937 198.455 302.086 182.235 302.086C166.015 302.086 152.866 288.937 152.866 272.717V0Z"/>
                            <path d="M34.2637 166.963L75.7979 125.429L223.846 273.477L182.312 315.011L34.2637 166.963Z"/>
                            <path d="M328.998 168.326L287.464 126.792L140.782 273.474L182.316 315.008L328.998 168.326Z"/>
                            <path d="M0 319.688H380.493V374.471H0V319.688Z"/>
                        </svg>
            
                        <!-- Progress Ring (Overlay on Edge) -->
                        <svg class="progress-ring progress-ring-manual" viewBox="0 0 60 60" style="position:absolute; width:100%; height:100%; top:0; left:0; pointer-events:none; z-index: 10; transform: rotate(-90deg); overflow: visible;">
                             <!-- Progress Circle -->
                             <circle class="progress-ring__circle" r="27.5" cx="30" cy="30" 
                                style="
                                    stroke-width: 4; 
                                    stroke: var(--unified-green); 
                                    fill: transparent; 
                                    stroke-linecap: round;
                                "/>
                        </svg>
                    </button>
                    <span class="control-label">手动同步</span>
        </div>

                <!-- Center: Realtime Sync -->
                <div class="control-item">
                    <button id="mainStartBtn" class="neumorphic-btn large">
                        <!-- Off State Icon (Updated SVG) -->
                        <svg class="icon-off" viewBox="0 0 360 360" fill="currentColor">
                            <path d="M360 180C360 279.3 279.3 360 180 360C80.7 360 0 279.3 0 180C0 140.7 12.599 103.5 36 72.001C41.7 64.501 50.399 60 60 60C66.599 60 72.9 62.1 77.999 66C91.199 75.901 93.9 94.799 83.999 107.999C68.401 129 60 153.9 60 180C60 246.301 113.699 300 180 300C246.301 300 300 246.301 300 180C300 153.9 291.599 129 276 107.999C266.099 94.799 268.8 76.199 282 66C287.099 62.1 293.4 60 299.999 60C309.599 60 318.299 64.501 323.999 72.001C347.401 103.5 360 140.7 360 180Z"/>
                            <path d="M210 30V140C210 156.5 196.5 170 180 170C163.5 170 150 156.5 150 140V30C150 13.5 163.5 0 180 0C196.5 0 210 13.5 210 30Z"/>
                        </svg>

                        <!-- On State Icon (Updated SVG) -->
                        <svg class="icon-on" viewBox="0 0 360 360" fill="#4DE34F" fill-opacity="0.75">
                            <path d="M360 180C360 279.3 279.3 360 180 360C80.7 360 0 279.3 0 180C0 140.7 12.599 103.5 36 72.001C41.7 64.501 50.399 60 60 60C66.599 60 72.9 62.1 77.999 66C91.199 75.901 93.9 94.799 83.999 107.999C68.401 129 60 153.9 60 180C60 246.301 113.699 300 180 300C246.301 300 300 246.301 300 180C300 153.9 291.599 129 276 107.999C266.099 94.799 268.8 76.199 282 66C287.099 62.1 293.4 60 299.999 60C309.599 60 318.299 64.501 323.999 72.001C347.401 103.5 360 140.7 360 180Z"/>
                            <path d="M210 30V140C210 156.5 196.5 170 180 170C163.5 170 150 156.5 150 140V30C150 13.5 163.5 0 180 0C196.5 0 210 13.5 210 30Z"/>
                        </svg>
                    </button>
                    <span id="realtimeLabel" class="control-label" style="transition: color 0.3s ease;">实时同步</span>
        </div>

                <!-- Right: Export GIF -->
                <div class="control-item">
                    <button id="exportGifBtn" class="neumorphic-btn small">
                        <!-- Custom GIF Text Icon (Updated SVG) -->
                        <svg class="icon-gif-text" viewBox="0 0 512 512" fill="currentColor">
                            <path d="M146.286 146.285H36.571C14.629 146.285 0 164.57 0 182.856V329.142C0 347.428 14.629 365.713 36.571 365.713H146.285C168.228 365.713 182.856 347.427 182.856 329.142V255.999H128V310.856H54.857V201.142H182.857V182.856C182.857 164.57 168.229 146.285 146.286 146.285Z"/>
                            <path d="M512 201.142V146.285H347.429V365.713H402.286V292.57H475.429V237.713H402.286V201.142H512Z"/>
                            <path d="M292.571 146.285H237.714V365.714H292.571V146.285Z"/>
                        </svg>
                        
                        <!-- Progress Ring (Overlay on Edge) -->
                        <svg class="progress-ring" viewBox="0 0 60 60" style="position:absolute; width:100%; height:100%; top:0; left:0; pointer-events:none; z-index: 10; transform: rotate(-90deg); overflow: visible;">
                             <!-- Progress Circle -->
                             <circle class="progress-ring__circle" r="27.5" cx="30" cy="30" 
                                style="
                                    stroke-width: 4; 
                                    stroke: var(--unified-green); 
                                    fill: transparent; 
                                    stroke-linecap: round;
                                "/>
                        </svg>
            </button>
                    <span class="control-label">导出 GIF</span>
    </div>
  </div>

      </div>

        <!-- Hidden elements needed for logic but not UI -->
        <div class="info-box" id="infoBox" style="display:none;"></div>
        <div class="count-display" id="count" style="display:none;">0</div>
        <div id="modeSubtitle" style="display:none;"></div>
        <div class="log-wrapper" id="logContainer" style="display: none;">
          <div class="log-header" id="logHeader">
                <span class="log-title">系统日志</span>
                <span id="logToggleText" style="font-size:12px; color:var(--text-tertiary);">收起</span>
            </div>
          <div class="log-content" id="log"></div>
        </div>

        <!-- Legacy buttons (hidden) - KEEP THESE IDs for existing JS logic -->
        <button id="syncBtn" style="display:none;"></button>
        <button id="stopBtn" style="display:none;"></button>
        <button id="locateFrameBtn" style="display:none;"></button>
        <button id="backBtn" style="display:none;"></button>
          </div>
    </div>
  </div>


  <!-- Settings Modal -->
  <div id="settingsOverlay" class="modal-overlay">
    <div class="modal">
      <div class="modal-header">
        <div class="modal-tabs">
            <button class="tab-btn active" id="tabDesktop">插件端</button>
            <button class="tab-btn" id="tabMobile">手机端</button>
        </div>
        <button id="settingsClose" class="close-btn">
          <div class="neu-icon-inner" style="width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center;">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.25" stroke-linecap="round" stroke-linejoin="round">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </div>
        </button>
      </div>
      <div class="modal-content" id="settingsContent">
        
        <!-- Tab Content: Desktop -->
        <div id="contentDesktop" class="tab-content active">
        <!-- Cloud Provider Selection (开发者模式下显示) -->
        <div id="modeSwitchSection" class="settings-section" style="display: none;">
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px;">
                <div class="feature-card mode-card" id="switchToDrive" style="padding: 12px; flex-direction: column; height: 100%;">
                    <div class="checkmark">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 7 9 18 4 13"></polyline></svg>
                </div>
                    <div class="card-icon" style="width:32px; height:32px;">
                        <img class="no-invert" src="https://raw.githubusercontent.com/BorderWalker99/figma-plugin-figma_sync/refs/heads/main/images/google.svg" width="20" height="20">
              </div>
                    <div class="card-content" style="width:100%">
                        <div class="card-title" style="margin-bottom:2px;">Google Cloud</div>
                        <div class="card-desc">无需 iCloud</div>
            </div>
                </div>
                 <div class="feature-card mode-card" id="switchToAliyun" style="display:none; padding: 12px; flex-direction: column; height: 100%;">
                     <div class="checkmark">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>
              </div>
                     <div class="card-icon" style="width:32px; height:32px;">
                        <img class="no-invert" src="https://raw.githubusercontent.com/BorderWalker99/figma-plugin-figma_sync/refs/heads/main/images/aliyun.svg" width="20" height="20">
            </div>
                    <div class="card-content" style="width:100%">
                        <div class="card-title" style="margin-bottom:2px;">阿里云 OSS</div>
                        <div class="card-desc">对象存储</div>
                </div>
              </div>
                 <!-- iCloud 模式 -->
                 <div class="feature-card mode-card" id="switchToIcloud" style="padding: 12px; flex-direction: column; height: 100%;">
                     <div class="checkmark">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>
            </div>
                     <div class="card-icon" style="width:32px; height:32px;">
                        <img class="no-invert" src="https://raw.githubusercontent.com/BorderWalker99/figma-plugin-figma_sync/refs/heads/main/images/icloud.svg" width="20" height="20">
          </div>
                    <div class="card-content" style="width:100%">
                        <div class="card-title" style="margin-bottom:2px;">iCloud</div>
                        <div class="card-desc">iCloud 需有空间</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Size Settings -->
        <div class="settings-section">
            <h3>截图尺寸</h3>
             <div style="display: flex; gap: 8px;">
                <div class="input-wrapper" style="flex: 1;">
                  <span class="input-prefix">宽</span>
                  <input type="number" id="imageWidthInput" placeholder="自适应">
            </div>
                <div class="input-wrapper" style="flex: 1;">
                  <span class="input-prefix">高</span>
                  <input type="number" id="imageHeightInput" placeholder="自适应">
            </div>
          </div>
        </div>

        <!-- Layout Settings -->
        <div class="settings-section">
            <h3>画板布局</h3>
            <div>
                <div class="input-wrapper">
                    <span class="input-prefix">每行</span>
                    <input type="number" id="frameColumnsInput" placeholder="一直横排">
          </div>
            </div>
        </div>

        <!-- Backup Settings -->
        <div class="settings-section" id="backupSection" style="display: flex; align-items: center; justify-content: space-between;">
            <h3 style="margin: 0;">备份到本地</h3>
            <select id="backupModeSelect" class="settings-select">
                <option value="none">仅视频</option>
                <option value="gif_only">视频 + GIF</option>
                <option value="all">视频 + GIF + 图片</option>
            </select>
        </div>

                <!-- Global Save Button -->
                <div style="margin-top: 12px;">
                    <button id="globalSaveBtn" class="btn btn-primary" style="width: 100%;" disabled>保存设置</button>
                  </div>
              </div>

        <!-- Tab Content: Mobile -->
        <div id="contentMobile" class="tab-content" style="display:none;">
             <div style="display: flex; flex-direction: column; gap: 14px;">
              <div id="shortcutGuideSection"  style="display: flex; flex-direction: column; gap: 8px;">
                 <div id="shortcutGuideTitle" style="font-weight: 600; margin-bottom: 6px; font-size: 13px;">01 配置快捷指令</div>
                 <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;" id="qrCodesContainer">
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 5px;" id="qrGoogleScreenshotContainer">
                      <img id="qrGoogleScreenshot" style="width: 72px; height: 72px;">
                      <div style="font-size: 11px; color: var(--text-secondary); text-align: center;">直接截图</div>
                      </div>
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 5px;" id="qrGoogleAlbumContainer">
                      <img id="qrGoogleAlbum" style="width: 72px; height: 72px;">
                      <div style="font-size: 11px; color: var(--text-secondary); text-align: center;">相册选择</div>
                  </div>
                    <!-- iCloud 二维码（隐藏） -->
                    <div style="display: none; flex-direction: column; align-items: center; gap: 5px;" id="qrIcloudScreenshotContainer">
                      <img id="qrIcloudScreenshot" style="width: 72px; height: 72px;">
                      <div style="font-size: 11px; color: var(--text-secondary); text-align: center;">直接截图</div>
              </div>
                    <div style="display: none; flex-direction: column; align-items: center; gap: 5px;" id="qrIcloudAlbumContainer">
                      <img id="qrIcloudAlbum" style="width: 72px; height: 72px;">
                      <div style="font-size: 11px; color: var(--text-secondary); text-align: center;">相册选择</div>
                      </div>
                    </div>
                 <div id="noModeMessage" style="font-size: 12px; color: var(--text-secondary); line-height: 1.6; display: none;">
                    请在"电脑端"中选择储存方式
                  </div>
              </div>

                        <div id="userIdDisplaySection">
                          <div id="userIdTitle" style="font-weight: 600; margin-bottom: 6px; font-size: 13px;">02 您的 User ID</div>
                          <div id="userIdSubtitle" style="font-size: 12px; color: var(--text-secondary); margin-top: 4px; margin-bottom: 6px;">
                            请在快捷指令的文本框中填入此 ID:
                      </div>
                          <div class="user-id-display">
                            <div class="id-content">
                              <span id="displayUserId">正在获取...</span>
                    </div>
                    <button id="copyUserIdBtn" class="icon-btn" style="width: 24px; height: 24px; flex-shrink: 0;" title="复制 User ID">
                      <div class="neu-icon-inner">
                        <svg class="svg-icon" style="width: 14px; height: 14px;" viewBox="0 0 24 24"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                      </div>
                    </button>
                  </div>
                </div>
                  </div>
                </div>

                      </div>
                    </div>
  </div>

  <!-- QR Code Zoom Modal -->
  <div id="qrZoomOverlay">
    <div class="qr-zoom-content">
      <img id="qrZoomImage" class="qr-zoom-image" src="" alt="QR Code">
      <div id="qrZoomLabel" class="qr-zoom-label"></div>
    </div>
  </div>

  <!-- Upload GIF Modal -->
  <div id="uploadGifOverlay" class="modal-overlay" style="display: none;">
    <div class="modal" style="max-width: 420px;">
      <!-- 关闭按钮 -->
      <button id="uploadGifClose" class="close-btn" style="position: absolute; top: 16px; right: 16px; z-index: 10;">
        <div class="neu-icon-inner" style="width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center;">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </div>
                    </button>
      
      <div class="modal-content" style="padding: 36px 32px; text-align: center;">
        <!-- 上传 Icon -->
        <div style="margin-bottom: 8px;">
          <div class="neu-icon-large" style="display: inline-flex; align-items: center; justify-content: center; width: 56px; height: 56px; border-radius: 50%; margin-bottom: 14px;">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
              <polyline points="17 8 12 3 7 8"></polyline>
              <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
          </div>
          <h2 style="font-size: 16px; font-weight: 600; margin: 0; color: var(--text); letter-spacing: -0.01em;">检测到需手动上传的录屏</h2>
        </div>

        <!-- 副标题 -->
        <div id="unsynced-gifs-subtitle" style="margin-bottom: 16px; color: var(--text-secondary); font-size: 13px; line-height: 1.5;">
          <!-- 动态填充文件名列表 -->
        </div>

        <!-- 隐藏的文件选择器 -->
        <input type="file" id="multi-file-input" accept=".gif,.mov,.mp4" multiple style="display: none;">

        <!-- 拖拽上传区域 -->
        <div id="upload-dropzone" style="
          width: 100%;
          min-height: 120px;
          border: none;
          border-radius: var(--radius-m);
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          gap: 4px;
          padding: 24px 16px;
          cursor: pointer;
          transition: all 0.2s ease;
          background: var(--pill-recessed-bg);
          box-shadow: var(--pill-recessed-shadow);
          box-sizing: border-box;
        ">
          <!-- 主文案 -->
          <div id="dropzone-text" style="text-align: center;">
            <div style="font-size: 12px; color: var(--text-secondary);">
              <span style="color: var(--primary);">点击上传 或 拖拽文件到此处</span>
            </div>
          </div>
          
          <!-- 支持格式提示 -->
          <div style="font-size: 11px; color: var(--text-tertiary);">
            支持 .gif .mov .mp4 格式
          </div>
        </div>

        <!-- 上传进度（隐藏） -->
        <div id="upload-progress-container" style="display: none; margin-top: 20px;">
          <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px; font-weight: 500;" id="upload-progress-text">正在上传...</div>
          <div style="width: 100%; height: 5px; background: var(--bg-inset); border-radius: 3px; overflow: hidden; box-shadow: inset 0 1px 2px rgba(0,0,0,0.08);">
            <div id="upload-progress-bar" style="width: 0%; height: 100%; background: linear-gradient(90deg, var(--unified-green) 0%, #4ADE80 100%); transition: width 0.3s ease;"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Toast -->
  <div id="toast" class="toast">
    <div class="toast-icon"></div>
    <span class="toast-message"></span>
  </div>

  <!-- Logic Script (Preserved) -->
  <script>
    // ========================================
    // Google Drive 模式开关（默认启用）
    // ========================================
    const ENABLE_GOOGLE_DRIVE = true;
    const ENABLE_ALIYUN = false;
    
    // ========================================
    // 开发者模式（控制模式切换区域显示）
    // ========================================
    const DEVELOPER_MODE = false; // 设置为 true 显示模式切换，false 隐藏
    
    const SERVER_URL = 'ws://localhost:8888';
    const connectionId = 'sync-session-1';
    
    let ws = null;
    let screenshotCount = 0;
    let manualDragCount = 0;
    let skippedFilesSet = new Set(); // 用于去重
    let heartbeatTimer = null;
    let updateCheckTimer = null; // 定期检查更新的定时器
    // isManualSyncing moved to progress variables section
    let currentMode = null;
    let currentSyncMode = null;
    let serverInstallPath = null;
    let isMinimized = false;
    let gifBackupCount = 0;
    let exportedGifCount = 0; // New counter for exported GIFs
    let justFinishedExport = false; // Flag to prioritize export status display
    
    // ✅ 新的状态管理系统：支持多状态队列
    // 每个状态可以独立存在，用户需要分别点击才能清除
    // 但导出状态会立即清除所有"已保存"状态
    let pendingStates = {
      exported: { count: 0, active: false },    // 已导出 X 段 GIF
      savedVideo: { count: 0, active: false },  // 已保存 X 段视频
      savedGif: { count: 0, active: false }     // 已保存 X 段 GIF
    };
    
    // 兼容旧代码的变量（后续会逐步移除）
    let currentButtonState = null; // 'exported', 'video', 'gif-backup', or null - locks the pill state until user clicks
    let currentPluginVersion = null; // 当前插件版本（初始为 null，等待 code.js 返回真实版本）
    let latestPluginVersion = null; // 最新版本
    let pluginUpdateUrl = null; // 更新下载地址
    let dismissedPluginVersion = null; // 用户点击"稍后"后记录的版本
    let dismissedServerVersion = null; // 用户点击"稍后"后记录的服务器版本
    let pendingPluginUpdateInfo = null; // 暂存的插件更新信息（等待版本信息到达后处理）
    
    // ✅ 新增：缓存手机同步的Video/大GIF的元数据（用于导出时自动关联）
    // 键：文件名，值：{ gifCacheId, driveFileId, ossFileId, timestamp }
    const skippedFileCache = new Map();
    
    // 从 localStorage 读取已安装的服务器版本（防止更新后 banner 再次弹出）
    // 注意：Figma 插件环境可能不支持 localStorage，需要 try-catch 保护
    let installedServerVersion = null;
    try {
      installedServerVersion = localStorage.getItem('currentServerVersion') || null;
      if (installedServerVersion) {
        console.log(`📌 从 localStorage 读取已安装版本: v${installedServerVersion}`);
      }
    } catch (error) {
      console.log('⚠️ localStorage 不可用（可能在 data: URL 环境下）:', error.message);
    }
    
    // 配置：定期检查更新的间隔（毫秒）
    const UPDATE_CHECK_INTERVAL = 60 * 60 * 1000; // 1小时检查一次
    
    // 日志配置：设为 false 可减少 Figma 控制台日志（降低 Datadog 警告）
    const ENABLE_CONSOLE_LOG = false; // 生产环境建议设为 false

    // ========== 日志函数 ==========
    function log(msg) {
      // 🛡️ 防止初始化未完成时崩溃
      try {
        // 只在开发模式下输出到控制台，减少 Datadog 数据量
        if (ENABLE_CONSOLE_LOG) {
          console.log(msg);
        }
        const logEl = document.getElementById('log');
        if (!logEl) return;
        
        const time = new Date().toLocaleTimeString();
        logEl.innerHTML = `[${time}] ${msg}\n` + logEl.innerHTML;

        const lines = logEl.innerText.split('\n');
        if (lines.length > 200) {
          logEl.innerText = lines.slice(0, 200).join('\n');
        }
      } catch (error) {
        // 静默处理日志错误，避免递归
      }
    }

    // ========== WebSocket连接 ==========
    // 重新连接功能（包含自动修复）
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 3; // 🚀 减少重试次数，快速失败
    let isExplicitlyDisconnected = false; // 用户是否手动断开（暂未用到，但预留）
    let isFirstConnection = true; // 🚀 标记是否是首次连接
    
    function attemptReconnect() {
      reconnectAttempts++;
      log(`🔄 尝试重新连接 (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
      updateStatus('waiting', '正在连接');
      
      // 清理心跳定时器
      if (heartbeatTimer) {
        clearInterval(heartbeatTimer);
        heartbeatTimer = null;
      }
      
      // 🚀 优化：缩短等待时间（从 1500ms 减少到 300ms）
      setTimeout(() => {
        connect();
        
        // 🚀 优化：缩短检查时间（从 3s 减少到 1.5s）
        setTimeout(() => {
          if (!ws || ws.readyState !== WebSocket.OPEN) {
            if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
              // 🚀 只在最后一次尝试时才启动服务器修复
              if (reconnectAttempts === MAX_RECONNECT_ATTEMPTS - 1) {
                log('⚠️ 连接失败，尝试自动启动服务器...');
                repairServerConnection();
              } else {
                // 快速重试
                attemptReconnect();
              }
            } else {
              log('❌ 多次重连失败，请手动操作');
              updateStatus('disconnected', '点击重连');
              showServerStartHelp();
            }
          } else {
            reconnectAttempts = 0;
            log('✅ 重新连接成功');
          }
        }, 1500);
      }, 300);
    }
    
    // 修复服务器连接（自动启动服务器）
    function repairServerConnection() {
      log('🔧 正在尝试自动启动服务器...');
      // showToast('正在启动服务器...', 'loading'); // 移除 loading toast，避免视觉干扰
      
      // 触发后端自动启动服务器
      parent.postMessage({
        pluginMessage: {
          type: 'repair-server',
          installPath: serverInstallPath || '/Applications/ScreenSync - SourceCode'
        }
      }, '*');
      
      // 🚀 优化：缩短等待时间（从 7s 减少到 3s）
      setTimeout(() => {
        log('🔄 服务器已启动，正在连接...');
        connect();
        
        // 🚀 优化：缩短检查时间（从 3s 减少到 2s）
        setTimeout(() => {
          if (!ws || ws.readyState !== WebSocket.OPEN) {
            if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
              log('⚠️  仍未连接，继续尝试...');
              reconnectAttempts++;
              attemptReconnect();
            } else {
              log('❌ 自动修复失败');
              updateStatus('disconnected', '点击重连');
              reconnectAttempts = 0;
            }
          } else {
            reconnectAttempts = 0;
            log('✅ 服务器已启动并连接成功');
            showToast('服务器已自动启动', 'success');
          }
        }, 2000);
      }, 3000);
    }
    
    // 显示服务器启动帮助
    function showServerStartHelp() {
      const helpHtml = `
        <div style="padding: 20px; text-align: center;">
          <div style="font-size: 48px; margin-bottom: 16px;">⚠️</div>
          <div style="font-size: 16px; font-weight: 600; margin-bottom: 12px; color: var(--text-primary);">
            服务器未运行
          </div>
          <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 20px; line-height: 1.6;">
            无法连接到本地服务器。<br/>
            请尝试以下解决方案：
          </div>
          <button onclick="retryStartServer()" style="
            padding: 10px 24px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            margin-bottom: 12px;
            width: 200px;
          ">
            🔄 重新尝试启动
          </button>
          <div style="font-size: 12px; color: var(--text-tertiary); margin-top: 16px; padding: 12px; background: var(--bg-secondary); border-radius: 8px; text-align: left;">
            <div style="font-weight: 600; margin-bottom: 8px;">💡 如果仍无法连接：</div>
            <div>1. 检查"系统偏好设置 → 用户与群组 → 登录项"</div>
            <div>2. 确保 ScreenSync 服务已启用</div>
            <div>3. 重启电脑后重试</div>
          </div>
        </div>
      `;
      
      // 替换主界面内容
      document.querySelector('.container').innerHTML = helpHtml;
      
      // 定义重试函数
      window.retryStartServer = function() {
        // 恢复原始界面
        location.reload();
      };
    }

    function connect() {
      // 不要在连接开始时立即更新status，避免重连时频繁切换
      // 只有在真正连接成功后才更新status

      // 🔧 关键修复：在创建新连接之前，彻底关闭旧连接
      if (ws) {
        try {
          log('🧹 清理旧连接...');
          // 移除所有事件监听器，防止触发 onclose 导致自动重连
          ws.onopen = null;
          ws.onmessage = null;
          ws.onerror = null;
          ws.onclose = null;
          
          // 如果连接还未完全关闭，强制关闭
          if (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) {
            ws.close();
            log('   已关闭旧 WebSocket 连接');
          }
          
          ws = null;
        } catch (error) {
          log('   ⚠️ 关闭旧连接时出错: ' + error.message);
          ws = null;
        }
      }

      // ✅ 用 try-catch 包裹 WebSocket 初始化，确保服务器未启动时不会阻止页面加载
      try {
        ws = new WebSocket(SERVER_URL + '?id=' + connectionId + '&type=figma');
        
        // 🚀 添加连接超时（2秒），避免无限等待
        const connectionTimeout = setTimeout(() => {
          if (ws && ws.readyState === WebSocket.CONNECTING) {
            console.log('⏱️ 连接超时，关闭并重试...');
            ws.close();
          }
        }, 2000);
        
        // 连接成功时清除超时
        const originalOnOpen = ws.onopen;
        ws.onopen = function(event) {
          clearTimeout(connectionTimeout);
          if (originalOnOpen) originalOnOpen.call(ws, event);
        };
        
      } catch (error) {
        console.error('❌ WebSocket 初始化失败:', error);
        log('❌ 无法连接到服务器');
        
        // 🚀 优化：缩短重试延迟（从 2s 减少到 500ms）
        if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
           updateStatus('disconnected', '点击重连');
        } else {
           updateStatus('waiting', '正在连接');
           setTimeout(() => {
             reconnectAttempts++;
             connect();
           }, 500);
        }
        return;
      }

      ws.onopen = function () {
        log('✅ 已连接');
        reconnectAttempts = 0; // 重置重试计数
        
        // 所有模式统一显示"已连接"
        updateStatus('connected', '已连接');

        if (ws.readyState === 1) {
          // 注册插件实例（用于单实例限制）
          ws.send(JSON.stringify({ 
            type: 'register-instance',
            connectionId: connectionId,
            timestamp: Date.now()
          }));
          
          ws.send(JSON.stringify({ type: 'get-sync-mode' }));
          ws.send(JSON.stringify({ type: 'get-server-info' }));
          ws.send(JSON.stringify({ type: 'get-backup-screenshot-setting' }));
          // 自动检测更新（不需要打开设置）
          ws.send(JSON.stringify({ type: 'check-update' }));
        }
        
        if (heartbeatTimer) clearInterval(heartbeatTimer);
        heartbeatTimer = setInterval(function () {
          if (ws.readyState === 1) {
            ws.send(JSON.stringify({ type: 'ping' }));
          }
        }, 5000);
        
        // 启动定期检查更新（每小时检查一次）
        if (updateCheckTimer) clearInterval(updateCheckTimer);
        updateCheckTimer = setInterval(function () {
          if (ws.readyState === 1) {
            console.log('🔄 定期检查更新...');
            ws.send(JSON.stringify({ type: 'check-update' }));
          }
        }, UPDATE_CHECK_INTERVAL);
        
        console.log(`⏰ 已启动定期更新检查，间隔: ${UPDATE_CHECK_INTERVAL / 1000 / 60} 分钟`);
        
        // 自动进入实时模式（如果尚未选择模式）
        if (!currentMode) {
          console.log('🚀 自动进入实时模式');
          showWorkArea('realtime');
        }
        
        // 🚀 如果实时模式已激活，重连后自动恢复实时同步
        if (currentMode === 'realtime' && isRealtimeActive) {
          console.log('🔄 重连后自动恢复实时同步');
          setTimeout(() => {
            if (ws && ws.readyState === 1) {
              ws.send(JSON.stringify({ type: 'start-realtime' }));
              log('⚡ 实时同步已恢复');
            }
          }, 500);
        }
      };

      ws.onmessage = function (event) {
        // 🛡️ 安全解析 JSON，防止解析失败导致错误
        var data;
        try {
          data = JSON.parse(event.data);
        } catch (parseError) {
          console.error('❌ WebSocket 消息解析失败:', parseError);
          return;
        }
        
        if (!data || !data.type) return;
        if (data.type === 'pong') { return; }

        // 🛡️ 包裹所有消息处理逻辑，防止错误导致插件崩溃
        try {
        // 处理强制关闭（单实例限制）
        if (data.type === 'force-close') {
          log('⚠️  检测到您在其他文件中打开了插件，当前插件将自动关闭');
          // 延迟 2 秒关闭，让用户看到提示
          setTimeout(() => {
            parent.postMessage({
              pluginMessage: { type: 'close-plugin' }
            }, '*');
          }, 2000);
          return;
        }

        if (data.type === 'server-info') {
          if (data.path) {
            serverInstallPath = data.path;
            
            // 保存路径到本地存储
            parent.postMessage({
              pluginMessage: {
                type: 'save-server-path',
                path: data.path
              }
            }, '*');

            const pathEl = document.getElementById('server-path-placeholder');
            if (pathEl) {
              pathEl.textContent = serverInstallPath;
              // 移除占位符的特殊样式，使用普通文本样式
              pathEl.style.color = 'inherit';
            }
          }
        } else if (data.type === 'screenshot') {
          // ✅ 标记同步已开始（收到了服务器响应）
          if (isManualSyncing) {
            syncStarted = true;
          }
          if (data.backedUpLocally || data.keptInIcloud) {
             // ✅ 根据文件类型分别计数
             // 只有 GIF 才增加 gifBackupCount，图片不计入（iCloud 模式下图片保留是正常行为）
             if (data.isGif) {
               gifBackupCount++;
             }
             // Don't reset state - let currentButtonState handle locking
             updateStatus('connected', '');
          }
          handleScreenshot(data);
        } else if (data.type === 'file-skipped') {
          // ✅ 标记同步已开始（收到了服务器响应）
          if (isManualSyncing) {
            syncStarted = true;
          }
          // 确定原因文本
          let reasonText = '未知原因';
          if (data.reason === 'mp4' || data.reason === 'video') {
            const ext = (data.filename || '').toLowerCase();
            if (ext.endsWith('.mov')) {
              reasonText = 'MOV视频';
            } else {
              reasonText = 'MP4视频';
            }
          } else if (data.reason === 'gif-too-large') {
            reasonText = 'GIF过大';
          }

          // ✅ 缓存文件的元数据（用于导出时自动关联）
          if (data.filename && (data.gifCacheId || data.driveFileId || data.ossFileId)) {
            skippedFileCache.set(data.filename, {
              gifCacheId: data.gifCacheId || null,
              driveFileId: data.driveFileId || null,
              ossFileId: data.ossFileId || null,
              timestamp: Date.now()
            });
            console.log(`💾 已缓存跳过文件的元数据: ${data.filename}`);
            console.log(`   gifCacheId: ${data.gifCacheId || '无'}`);
            console.log(`   driveFileId: ${data.driveFileId || '无'}`);
            console.log(`   ossFileId: ${data.ossFileId || '无'}`);
          }

          // 去重检查：如果文件名已存在，则不增加计数，也不显示重复的日志
          if (!skippedFilesSet.has(data.filename)) {
            skippedFilesSet.add(data.filename);
            manualDragCount++;
            log(`⚠️  ${data.filename} 需手动导入（${reasonText}）`);
            
            // ✅ 立即更新状态pill，确保显示"已保存 X 段视频"
            // 只有在当前没有更高优先级的状态锁定时才设置
            if (!justFinishedExport && currentButtonState !== 'exported') {
              currentButtonState = 'video'; // 锁定为video状态
            }
          }
          
          // 即使重复，也尝试发送确认消息以确保后台状态同步（可选，但为了保险起见）
          if (ws && ws.readyState === WebSocket.OPEN) {
            try {
              ws.send(JSON.stringify({
                type: 'screenshot-failed',
                filename: data.filename,
                error: reasonText,
                keepFile: true
              }));
            } catch (error) {
              console.error('发送失败消息失败:', error);
            }
          }
          
          // ✅ 触发状态更新，显示video状态pill
          updateStatus('connected', '');
        } else if (data.type === 'manual-sync-complete') {
          // Complete manual sync with animation
          console.log('🎉 手动同步完成！');
          
          // ✅ 清除超时定时器
          if (manualSyncTimeoutId) {
            clearTimeout(manualSyncTimeoutId);
            manualSyncTimeoutId = null;
          }
          syncStarted = false; // 重置同步开始标记

          const manualSyncBtn = document.getElementById('manualSyncBtn');
          
          // ✅ 立即停止旋转动画和进度环
          if (progressRingManual) {
            progressRingManual.style.animation = '';
            progressRingManual.style.opacity = 0;
          }
          
          // ✅ 触发 icon 闪烁动画
          if (manualSyncBtn) {
            const syncIcon = manualSyncBtn.querySelector('.icon-manual-sync');
            if (syncIcon) {
              syncIcon.classList.add('icon-completion-glow');
              setTimeout(() => {
                syncIcon.classList.remove('icon-completion-glow');
              }, 1400);
            }
            
            // Remove syncing state
            manualSyncBtn.classList.remove('exporting');
            manualSyncBtn.setAttribute('data-tooltip', '手动同步');
          }
          
          // ✅ 构建 toast 消息
          // imageCount = 成功导入 Figma 的纯图片数量
          // gifCount = 所有 GIF 数量（用于 toast 显示）
          // videoCount = 所有视频数量（用于 toast 显示）
          // savedGifCount = 实际保存到本地的 GIF 数量（用于 status pill）
          // savedVideoCount = 实际保存到本地的视频数量（用于 status pill）
          const imageCount = data.imageCount || 0;
          const gifCount = data.gifCount || 0;
          const videoCount = data.videoCount || 0;
          const savedGifCount = data.savedGifCount || 0;
          const savedVideoCount = data.savedVideoCount || 0;
          
          let toastMessage;

          // ✅ 更新 status pill 状态：只显示实际保存到本地的文件
          // 注意：使用 savedGifCount 和 savedVideoCount，而不是 gifCount 和 videoCount
          // 因为当备份模式为"无"时，GIF 不会被保存到本地
          if (savedVideoCount > 0) {
            manualDragCount = savedVideoCount;
            pendingStates.savedVideo.active = true;
            pendingStates.savedVideo.count = savedVideoCount;
            currentButtonState = 'video';
          }
          if (savedGifCount > 0) {
            gifBackupCount = savedGifCount;
            pendingStates.savedGif.active = true;
            pendingStates.savedGif.count = savedGifCount;
            if (!pendingStates.savedVideo.active) {
              currentButtonState = 'gif-backup';
            }
          }

          // ✅ 构建 toast 消息：显示所有同步的文件类型（不管是否保存到本地）
          const parts = [];
          if (imageCount > 0) parts.push(`${imageCount} 张图片`);
          if (gifCount > 0) parts.push(`${gifCount} 段 GIF`);
          if (videoCount > 0) parts.push(`${videoCount} 段视频`);
          
          if (parts.length === 0) {
            toastMessage = '已同步 0 张图片';
          } else {
            toastMessage = `已同步 ${parts.join('，')}`;
          }
          
          // ✅ 显示 toast（延迟一点等 icon 开始闪烁）
          setTimeout(() => {
            showToast(toastMessage, 'success');
            log(toastMessage);
          }, 200);
          
          // Reset state
          isManualSyncing = false;
          
          // 恢复同步按钮状态（保持旧的 syncBtn 逻辑以防万一）
          const syncBtn = document.getElementById('syncBtn');
          if (syncBtn) {
            // 清除超时定时器
            if (syncBtn.dataset.syncTimeout) {
              clearTimeout(parseInt(syncBtn.dataset.syncTimeout));
              delete syncBtn.dataset.syncTimeout;
            }
            
            // 重置标志和按钮状态
            syncBtn.disabled = false;
            syncBtn.textContent = '立即同步';
          }
          
          // 检查连接状态，只有在连接时才更新status
          if (!ws || ws.readyState !== 1) {
            updateStatus('disconnected', '点击重连');
            return;
          }
          
          // 检查是否有真正的错误消息（如用户文件夹未初始化、网络错误等）
          // 注意：如果 total === 0 且没有 message，说明是文件夹为空，这是正常情况，不是错误
          if (data.message && data.total === 0 && data.count === 0) {
            log(`❌ ${data.message}`);
            // 根据不同的错误消息给出友好提示
            if (data.message.includes('未初始化') || data.message.includes('未连接')) {
              alert(`同步失败：${data.message}\n\n💡 建议：\n1. 确保服务器正在运行\n2. 先在手机端上传至少一个文件\n3. 等待几秒后重试\n4. 如仍无法解决，请重启服务器`);
            } else {
              alert(`同步失败：${data.message}`);
            }
            updateStatus('connected', '同步失败');
            return;
          }
          
          if (manualDragCount > 0) {
            log(`⚠️  有 ${manualDragCount} 个文件需手动导入`);
            updateStatus('connected', '');
             return;
          }
          
          // 优化后的逻辑：支持显示部分失败和具体错误详情
          if (data.total === 0) {
            // 没有文件，但不是错误（message 为空）
            log('✅ 同步完成：0 张截图（文件夹为空）');
            updateStatus('connected', '同步完成');
          } else if (data.count === data.total) {
            // 全部成功
            log(`✅ 同步完成：全部 ${data.count} 张截图`);
            if (gifBackupCount > 0) {
              updateStatus('connected', '');
            } else {
            updateStatus('connected', '同步完成');
            }
          } else {
            // 部分或全部失败
            const failed = data.total - data.count;
            if (data.count > 0) {
               log(`⚠️  同步完成，但有 ${failed} 张失败 (成功 ${data.count}/${data.total})`);
            } else {
               log(`⚠️  同步失败，${data.total} 张全部处理失败`);
            }
            
            // 显示详细错误信息
            if (data.errors && data.errors.length > 0) {
              log(`🔍 错误详情:`);
              data.errors.slice(0, 5).forEach(err => {
                log(`   ❌ ${err.filename}: ${err.error}`);
              });
              if (data.errors.length > 5) {
                log(`   ... 以及其他 ${data.errors.length - 5} 个错误`);
              }
              
              // 延迟弹窗显示第一个错误，帮助调试
              setTimeout(() => {
                const firstErr = data.errors[0];
                alert(`❌ 截图处理失败\n\n文件名: ${firstErr.filename}\n错误信息: ${firstErr.error}\n\n请将此错误信息截图发给开发者。`);
              }, 200);
            } else {
              log(`   ❌ 未知错误 (无详细信息)`);
            }
            updateStatus('connected', '同步完成');
          }
        } else if (data.type === 'error') {
          // 处理服务器通用错误消息
          console.error('❌ Server Error:', data.message);
          showToast(data.message || '未知错误', 'error');
          
          // 如果手动同步正在进行中，重置状态
          if (isManualSyncing) {
            isManualSyncing = false;
            const manualSyncBtn = document.getElementById('manualSyncBtn');
            if (manualSyncBtn) {
              manualSyncBtn.classList.remove('exporting');
              manualSyncBtn.setAttribute('data-tooltip', '手动同步');
            }
            if (progressRingManual) {
              progressRingManual.style.opacity = 0;
              progressRingManual.style.animation = '';
            }
            updateStatus('connected', '同步失败');
          }
        } else if (data.type === 'sync-mode-changed') {
          currentSyncMode = data.mode;
          updateSyncModeDisplay();
          if (checkQRCodeVisibility()) {
          updateQRCodeDisplay();
          }
          log('✅ 储存方式已切换');
        } else if (data.type === 'gif-compose-progress') {
          // 处理服务器推送的真实进度
          if (data.progress) {
             updateRealProgress(data.progress, data.message);
          }
        } else if (data.type === 'gif-compose-success') {
          // Update Progress
          console.log('✅ 收到服务器成功响应');
          console.log('   输出路径:', data.outputPath);
          console.log('   是否跳过:', data.skipped ? '是（文件已存在）' : '否（新导出）');
          console.log('   完成数量:', completedExports + 1, '/', totalExports);
          
          // ⏱️ 显示导出耗时
          if (data.exportDurationSeconds) {
            console.log(`   ⏱️  导出耗时: ${data.exportDurationSeconds} 秒 (${data.exportDuration} ms)`);
          }
          
          handleExportSuccess();
          
          // 只有在真正导出新文件时才增加计数（跳过的不计数）
          if (!data.skipped) {
            exportedGifCount++;
            console.log('   📊 导出计数增加:', exportedGifCount);
            
            // ⏱️ 在最后一个导出完成时显示耗时 toast
            if (completedExports >= totalExports && data.exportDurationSeconds) {
              showToast(`导出完成，耗时 ${data.exportDurationSeconds} 秒`, 'success');
            }
          } else {
            console.log('   ⏭️  文件已存在，计数不变:', exportedGifCount);
          }
          
          // 标记刚完成导出，这样即使计数没增加，也会优先显示导出状态
          justFinishedExport = true;
          updateStatus('connected', '');
        } else if (data.type === 'gif-compose-error') {
          // Update Progress (count as done but failed)
          console.error('❌ 收到服务器错误响应');
          console.error('   错误消息:', data.message || data.error || '未知错误');
          console.error('   完整错误详情:', data.details || '无');
          
          // ✅ 如果是因为取消导出导致的错误，忽略错误 toast
          if (isCancellingExport) {
            console.log('   ℹ️  忽略取消导出后的错误消息');
            handleExportError();
            isCancellingExport = false; // 重置标志
            return;
          }
          
          // 检查是否是"未找到文件"的错误
          const errorMsg = data.message || data.error || '';
          if (errorMsg.includes('未找到 GIF/视频文件')) {
            console.log('   🔍 检测到文件未找到错误，通知 code.js 清除 pluginData 并重新检测...');
            handleExportError();
            showToast('未找到文件，请重新上传', 'error');
            
            // 通知 code.js 清除相关 GIF 的 pluginData
            parent.postMessage({
              pluginMessage: { 
                type: 'clear-gif-data-and-retry'
              }
            }, '*');
          } else {
            handleExportError();
            // 只在 toast 显示简短错误提示，详细信息在 console
            showToast('导出失败，请查看控制台了解详情', 'error');
          }
        } else if (data.type === 'gif-compose-cancelled') {
          // 处理取消确认消息
          console.log('🛑 收到服务器取消确认');
          // UI 已经在 cancelGifExport 中处理了重置，这里不需要额外操作
        } else if (data.type === 'sync-mode-info') {
          currentSyncMode = data.mode;
          updateSyncModeDisplay();
          // 如果设置界面是打开的，确保立即更新显示
          if (settingsOverlay && settingsOverlay.classList.contains('show')) {
            // updateSyncModeDisplay() 已经在上面的调用中更新了，这里不需要再次调用
            // 但可以确保显示是最新的
          }
          if (checkQRCodeVisibility()) {
            updateQRCodeDisplay();
          }
        } else if (data.type === 'cache-existence-result') {
          // ✅ 处理服务器返回的缓存检查结果
          console.log('📥 收到服务器缓存检查结果:', data.results ? data.results.length : 0, '个文件');
          
          // 转发给 code.js 处理（转换消息类型以匹配 code.js 期望的格式）
          // ✅ 只有在导出流程中的缓存检查才需要继续触发导出
          parent.postMessage({
            pluginMessage: {
              type: 'server-cache-check-result',
              results: data.results || [],
              fromExport: pendingExportCacheCheck // 标记是否来自导出流程
            }
          }, '*');
          // 重置标志
          pendingExportCacheCheck = false;
        } else if (data.type === 'switch-sync-mode-result') {
          if (data.success) {
            // 简化消息：从"储存方式已切换为 XXX"改为"已切换为 XXX方式"
            let modeName = '未知模式';
            if (data.mode === 'drive' || data.mode === 'google') {
              modeName = 'Google Drive';
            } else if (data.mode === 'aliyun' || data.mode === 'oss') {
              modeName = '阿里云';
            } else if (data.mode === 'icloud') {
              modeName = 'iCloud';
            }
            showToast('切换至 ' + modeName + ' 模式', 'success');
            currentSyncMode = data.mode;
            updateSyncModeDisplay();
            if (useCaseOverlay && useCaseOverlay.classList.contains('show')) {
              updateQRCodeDisplay();
            }
            
            // 重新启动实时同步（而不是显示模式选择）
            stopRealtimeSync();
            setTimeout(() => {
              showWorkArea('realtime');
              closeSettings();
            }, 1000);
          } else {
            // 如果是空间不足错误，显示特定的错误消息
            if (data.isSpaceError) {
              showToast('iCloud 无空间', 'error');
            } else {
              showToast(data.message || '切换失败', 'error');
            }
          }
        } else if (data.type === 'user-id-info') {
            const el = document.getElementById('displayUserId');
            if (el) el.textContent = data.userId || '未知';
        } else if (data.type === 'plugin-update-info') {
          // 处理插件更新信息
          handlePluginUpdateInfo(data);
        } else if (data.type === 'server-update-info') {
          // 处理服务器更新信息
          handleServerUpdateInfo(data);
        } else if (data.type === 'plugin-version-info') {
          // 处理插件版本信息
          handlePluginVersionInfo(data);
        } else if (data.type === 'plugin-update-progress') {
          // 处理插件更新进度（已废弃，兼容旧版）
          handleUpdateProgress(data);
        } else if (data.type === 'server-update-progress') {
          // 处理服务器更新进度（已废弃，兼容旧版）
          handleUpdateProgress(data);
        } else if (data.type === 'update-progress') {
          // 处理统一更新进度
          handleUpdateProgress(data);
        } else if (data.type === 'backup-screenshot-setting-info') {
          // 接收备份截图设置信息
          if (typeof backupModeSelect !== 'undefined' && backupModeSelect) {
            const mode = data.mode || (data.enabled ? 'all' : 'none');
            backupModeSelect.value = mode;
            originalSettings.backupMode = mode;
            currentSettings.backupMode = mode;
            checkSettingsChanges();
            // 调整宽度以适应当前选项
            if (typeof adjustSelectWidth === 'function') {
              adjustSelectWidth(backupModeSelect);
            }
          }
        } else if (data.type === 'backup-screenshot-setting-updated') {
          // 备份截图设置已更新
          if (data.success) {
            if (typeof backupModeSelect !== 'undefined' && backupModeSelect) {
              const mode = data.mode || (data.enabled ? 'all' : 'none');
              originalSettings.backupMode = mode;
              currentSettings.backupMode = mode;
            }
          } else {
            showToast('备份设置更新失败', 'error');
          }
        }
        } catch (msgError) {
          // 🛡️ 捕获消息处理错误，防止插件崩溃
          console.error('❌ WebSocket 消息处理错误:', msgError);
          console.error('   消息类型:', (data && data.type) ? data.type : '未知');
        }
      };

      ws.onerror = function (error) {
        console.error('❌ WebSocket 连接错误:', error);
        log('❌ 连接失败');
        
        // ✅ 清除所有状态锁定，确保显示断开状态
        currentButtonState = null;
        justFinishedExport = false;
        exportedGifCount = 0;
        manualDragCount = 0;
        gifBackupCount = 0;
        // ✅ 重置新的状态系统
        pendingStates.exported = { count: 0, active: false };
        pendingStates.savedVideo = { count: 0, active: false };
        pendingStates.savedGif = { count: 0, active: false };
        
        // 重置同步标志，防止按钮永久禁用
        isManualSyncing = false;
        syncStarted = false;
        if (manualSyncTimeoutId) {
          clearTimeout(manualSyncTimeoutId);
          manualSyncTimeoutId = null;
        }
      };

      ws.onclose = function () {
        log('⚠️ 连接断开');
        
        // ✅ 清除所有状态锁定，确保显示断开状态
        currentButtonState = null;
        justFinishedExport = false;
        exportedGifCount = 0;
        manualDragCount = 0;
        gifBackupCount = 0;
        // ✅ 重置新的状态系统
        pendingStates.exported = { count: 0, active: false };
        pendingStates.savedVideo = { count: 0, active: false };
        pendingStates.savedGif = { count: 0, active: false };
        
        if (heartbeatTimer) clearInterval(heartbeatTimer);
        if (updateCheckTimer) clearInterval(updateCheckTimer); // 清除更新检查定时器
        // 重置同步标志，防止按钮永久禁用
        isManualSyncing = false;
        syncStarted = false;
        if (manualSyncTimeoutId) {
          clearTimeout(manualSyncTimeoutId);
          manualSyncTimeoutId = null;
        }
        
        // ✅ 智能重连逻辑 - 🚀 优化：更短的延迟
        if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
          reconnectAttempts++;
          // 🚀 优化：固定 500ms 延迟，不再递增（原来是 1s, 2s, 3s...）
          const delay = 500;
          log(`⏳ 正在重试 (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
          
          updateStatus('waiting', '正在连接');
          
          setTimeout(() => {
            connect();
          }, delay);
        } else {
          // ❌ 重试次数耗尽，显示手动重连按钮
          log('❌ 自动重连失败，请手动点击重连');
          updateStatus('disconnected', '点击重连');
        }
      };
    }

    let currentFileId = null;
    let currentFileIdType = null;
    let currentFileBackedUp = false;

    function handleScreenshot(data) {
      log(`📸 ${data.filename || '截图'}`);
      
      // 🔍 调试：显示接收到的数据
      console.log('🔍 handleScreenshot 接收到的数据:');
      console.log('   filename:', data.filename);
      console.log('   driveFileId:', data.driveFileId || '无');
      console.log('   ossFileId:', data.ossFileId || '无');
      console.log('   gifCacheId:', data.gifCacheId || '无');
      
      currentFileId = data.ossFileId || data.driveFileId || null;
      currentFileIdType = data.ossFileId ? 'oss' : (data.driveFileId ? 'drive' : null);
      // 检查文件是否已备份（Google Drive）或保留（iCloud）
      currentFileBackedUp = data.backedUpLocally || data.keptInIcloud || false;

      try {
      parent.postMessage({
        pluginMessage: {
          type: 'add-screenshot',
          bytes: data.bytes,
          timestamp: data.timestamp,
          filename: data.filename,
          driveFileId: data.driveFileId,
          ossFileId: data.ossFileId,
          gifCacheId: data.gifCacheId  // ✅ 传递 gifCacheId（用于 GIF 导出）
        }
      }, '*');
      
      // 🔍 调试：显示发送给 code.js 的数据
      console.log('🔍 发送给 code.js 的消息:');
      console.log('   driveFileId:', data.driveFileId || '无');
      console.log('   ossFileId:', data.ossFileId || '无');
      console.log('   gifCacheId:', data.gifCacheId || '无');
      } catch (error) {
        log('❌ 处理失败: ' + error.message);
        console.error('发送失败:', error);
        
        // 如果发送到 Figma 失败（例如消息过大），但已经备份到本地
        // 那么我们也应该通知服务器可以删除云端文件，因为本地已经有了
        if (currentFileBackedUp) {
          log('⚠️  发送到 Figma 失败，但文件已备份到本地，确认删除云端文件');
          showToast('Figma 导入失败，已保存到本地', 'warning');
          
          if (ws && ws.readyState === WebSocket.OPEN) {
            if (currentFileId) {
              try {
                const confirmMessage = {
                  type: 'screenshot-received',
                  filename: data.filename || '未命名文件',
                  timestamp: Date.now()
                };
                if (currentFileIdType === 'oss') confirmMessage.ossFileId = currentFileId;
                else if (currentFileIdType === 'drive') confirmMessage.driveFileId = currentFileId;
                ws.send(JSON.stringify(confirmMessage));
                
                // Reset
                currentFileId = null;
                currentFileIdType = null;
                currentFileBackedUp = false;
              } catch (sendError) {
                console.error('❌ 发送确认失败:', sendError);
              }
            }
          }
        }
      }
    }

    // Helper to animate width changes for smooth morphing
    function animateWidthChange(element, updateContentFn) {
        // 🚀 修复：移除所有手动宽度计算，使用内容自适应
        
        // 1. 保存当前的布局状态，确保平滑过渡
        const oldWidth = element.offsetWidth;
        element.style.transition = 'none'; // 临时禁用过渡
        element.style.width = oldWidth + 'px'; // 锁定当前宽度
        
        // 防止文本换行（只在动画期间）
        element.style.whiteSpace = 'nowrap';
        
        // 2. 执行内容更新
        updateContentFn();
        
        // 3. 短暂延迟，确保 DOM 更新完成
        setTimeout(() => {
            // 4. 恢复过渡动画并让内容自动撑开
            element.style.transition = '';
            element.style.width = ''; // 移除固定宽度，让内容自适应
            
            // 5. 延迟清理，确保动画完成
            setTimeout(() => {
                // 清理临时样式，恢复默认状态
                element.style.whiteSpace = '';
                element.style.overflow = 'visible'; // 确保关闭按钮可见
            }, 350);
        }, 50);
    }

    // 生成 status pill 关闭按钮的 HTML
    function getPillCloseButtonHTML() {
      return `
        <span class="pill-close-btn" onclick="event.stopPropagation();">
          <svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
            <path d="M2 2L10 10M10 2L2 10"/>
          </svg>
        </span>
      `;
    }

    // 为 status pill 绑定关闭按钮事件
    function bindPillCloseButton(statusEl, clearStateFn) {
      const closeBtn = statusEl.querySelector('.pill-close-btn');
      if (closeBtn) {
        closeBtn.onclick = function(e) {
          e.stopPropagation();
          clearStateFn();
        };
      }
    }

    function updateStatus(type, text) {
      // 🛡️ 防止初始化未完成时崩溃
      try {
        const statusEl = document.getElementById('status');
        if (!statusEl) return; // 元素不存在时直接返回

        // ✅ 强制检查：如果 WebSocket 断开，清除所有锁定状态并强制显示断开
        if (!ws || ws.readyState !== WebSocket.OPEN) {
        if (type !== 'disconnected' && type !== 'waiting') {
          currentButtonState = null;
          justFinishedExport = false;
          // ✅ 重置新的状态系统
          pendingStates.exported = { count: 0, active: false };
          pendingStates.savedVideo = { count: 0, active: false };
          pendingStates.savedGif = { count: 0, active: false };
        }
        if (type === 'connected') {
        type = 'disconnected';
        if (!text || text === '') {
          text = '连接断开';
        }
      }
      }

      // Wrap the content update in our animation helper
      animateWidthChange(statusEl, () => {
          // Reset Base State
          statusEl.className = 'connection-pill';
          statusEl.style.cursor = 'default';
          statusEl.onclick = null;
          statusEl.style.display = '';
          statusEl.innerHTML = '';

          // 1. Disconnected / Waiting - Always highest priority when not connected
          if (type === 'disconnected' || (type === 'waiting' && (!ws || ws.readyState !== WebSocket.OPEN))) {
            const isDisconnected = type === 'disconnected';
            const displayText = text || (isDisconnected ? '点击重连' : '正在连接');
            
            let pillClass = 'connection-pill interactive';
            if (type === 'waiting') {
                pillClass += ' waiting';
            } else if (displayText === '连接断开') {
                pillClass += ' offline'; // Gray, no glow
            } else {
                pillClass += ' reconnect'; // Red, glow
            }

        // Waiting state: recessed (no bezel/face), other states: button style (with bezel/face)
        if (type === 'waiting') {
        statusEl.innerHTML = `
              <span class="status-dot"></span>
              <span>${displayText}</span>
            `;
        } else {
            statusEl.innerHTML = `
              <div class="bezel"></div>
              <div class="face"></div>
              <span class="status-dot" style="position: relative; z-index: 2;"></span>
              <span style="position: relative; z-index: 2;">${displayText}</span>
        `;
        }
        
            statusEl.className = pillClass;
        statusEl.style.cursor = 'pointer';
        statusEl.style.display = 'flex';
        statusEl.style.alignItems = 'center';
        statusEl.onclick = function() {
          attemptReconnect();
        };
        return;
      }

          // ========================================
          // ✅ 新的状态管理逻辑
          // ========================================
          // 规则：
          // 1. 导出完成时，立即清除所有"已保存"状态，只显示"已导出"
          // 2. 点击"已导出"后，恢复"已连接"
          // 3. 同步完成时，"已保存视频"和"已保存GIF"可同时存在
          // 4. 点击"已保存视频"后，只清除视频状态，继续显示GIF状态（如果有）
          // 5. 点击"已保存GIF"后，只清除GIF状态，继续显示视频状态（如果有）
          // 6. 所有状态都点击完后，恢复"已连接"
          // ========================================

          // 2. 导出完成 - 最高优先级，立即清除所有"已保存"状态
          if (justFinishedExport) {
            // ✅ 关键：导出完成时，清除所有"已保存"状态
            pendingStates.savedVideo.active = false;
            pendingStates.savedVideo.count = 0;
            pendingStates.savedGif.active = false;
            pendingStates.savedGif.count = 0;
            manualDragCount = 0;
            gifBackupCount = 0;
            skippedFilesSet.clear();
            
            // 设置导出状态
            pendingStates.exported.active = true;
            pendingStates.exported.count = exportedGifCount > 0 ? exportedGifCount : 1;
            currentButtonState = 'exported';
            
            const displayCount = pendingStates.exported.count;
            const exportText = `已导出 ${displayCount} 段 GIF`;
            statusEl.innerHTML = `
              <div class="bezel"></div>
              <div class="face"></div>
              <span class="status-dot" style="position: relative; z-index: 2;"></span>
              <span style="position: relative; z-index: 2;">${exportText}</span>
              ${getPillCloseButtonHTML()}
            `;
            statusEl.className = 'connection-pill connected interactive';
            statusEl.style.cursor = 'pointer';
            statusEl.onclick = function() {
              if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'open-folder', targetFolder: 'GIF-导出' }));
              }
              // ✅ 点击后清除导出状态，恢复"已连接"
              pendingStates.exported.active = false;
              pendingStates.exported.count = 0;
              exportedGifCount = 0;
              justFinishedExport = false;
              currentButtonState = null;
              updateStatus('connected', '已连接');
            };
            // 绑定关闭按钮（不打开文件夹，直接清除状态）
            bindPillCloseButton(statusEl, function() {
              pendingStates.exported.active = false;
              pendingStates.exported.count = 0;
              exportedGifCount = 0;
              justFinishedExport = false;
              currentButtonState = null;
              updateStatus('connected', '已连接');
            });
            return;
          }

          // 3. 检查是否有导出状态（已锁定）
          if (pendingStates.exported.active || currentButtonState === 'exported') {
            const displayCount = pendingStates.exported.count > 0 ? pendingStates.exported.count : (exportedGifCount > 0 ? exportedGifCount : 1);
            const exportText = `已导出 ${displayCount} 段 GIF`;
            statusEl.innerHTML = `
              <div class="bezel"></div>
              <div class="face"></div>
              <span class="status-dot" style="position: relative; z-index: 2;"></span>
              <span style="position: relative; z-index: 2;">${exportText}</span>
              ${getPillCloseButtonHTML()}
            `;
            statusEl.className = 'connection-pill connected interactive';
            statusEl.style.cursor = 'pointer';
            statusEl.onclick = function() {
              if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'open-folder', targetFolder: 'GIF-导出' }));
              }
              pendingStates.exported.active = false;
              pendingStates.exported.count = 0;
              exportedGifCount = 0;
              justFinishedExport = false;
              currentButtonState = null;
              updateStatus('connected', '已连接');
            };
            // 绑定关闭按钮
            bindPillCloseButton(statusEl, function() {
              pendingStates.exported.active = false;
              pendingStates.exported.count = 0;
              exportedGifCount = 0;
              justFinishedExport = false;
              currentButtonState = null;
              updateStatus('connected', '已连接');
            });
            return;
          }
          
          // 4. 检查"已保存视频"状态
          // 同步计数到 pendingStates
          if (manualDragCount > 0) {
            pendingStates.savedVideo.active = true;
            pendingStates.savedVideo.count = manualDragCount;
          }
          
          if (pendingStates.savedVideo.active && pendingStates.savedVideo.count > 0) {
            currentButtonState = 'video';
            const warningText = `已保存 ${pendingStates.savedVideo.count} 段视频`;
            statusEl.innerHTML = `
              <div class="bezel"></div>
              <div class="face"></div>
              <span class="status-dot" style="position: relative; z-index: 2;"></span>
              <span style="position: relative; z-index: 2;">${warningText}</span>
              ${getPillCloseButtonHTML()}
            `;
            statusEl.className = 'connection-pill connected interactive';
            statusEl.style.cursor = 'pointer';
            statusEl.onclick = function() {
              if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'open-local-folder', targetFolder: '视频' }));
              }
              // ✅ 只清除视频状态
              pendingStates.savedVideo.active = false;
              pendingStates.savedVideo.count = 0;
              manualDragCount = 0;
              skippedFilesSet.clear();
              
              // ✅ 检查是否还有 GIF 状态，如果有则继续显示
              if (pendingStates.savedGif.active && pendingStates.savedGif.count > 0) {
                currentButtonState = 'gif-backup';
              } else {
                currentButtonState = null;
              }
              justFinishedExport = false;
              updateStatus('connected', '');
            };
            // 绑定关闭按钮（不打开文件夹，直接清除状态）
            bindPillCloseButton(statusEl, function() {
              pendingStates.savedVideo.active = false;
              pendingStates.savedVideo.count = 0;
              manualDragCount = 0;
              skippedFilesSet.clear();
              if (pendingStates.savedGif.active && pendingStates.savedGif.count > 0) {
                currentButtonState = 'gif-backup';
              } else {
                currentButtonState = null;
              }
              justFinishedExport = false;
              updateStatus('connected', '');
            });
            return;
          }
          
          // 5. 检查"已保存GIF"状态
          // 同步计数到 pendingStates
          if (gifBackupCount > 0) {
            pendingStates.savedGif.active = true;
            pendingStates.savedGif.count = gifBackupCount;
          }
          
          if (pendingStates.savedGif.active && pendingStates.savedGif.count > 0) {
            currentButtonState = 'gif-backup';
            const backupText = `已保存 ${pendingStates.savedGif.count} 段 GIF`;
            statusEl.innerHTML = `
              <div class="bezel"></div>
              <div class="face"></div>
              <span class="status-dot" style="position: relative; z-index: 2;"></span>
              <span style="position: relative; z-index: 2;">${backupText}</span>
              ${getPillCloseButtonHTML()}
            `;
            statusEl.className = 'connection-pill connected interactive';
            statusEl.style.cursor = 'pointer';
            statusEl.onclick = function() {
              if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'open-local-folder', targetFolder: 'GIF' }));
              }
              // ✅ 只清除 GIF 状态
              pendingStates.savedGif.active = false;
              pendingStates.savedGif.count = 0;
              gifBackupCount = 0;
              
              // ✅ 检查是否还有视频状态，如果有则继续显示
              if (pendingStates.savedVideo.active && pendingStates.savedVideo.count > 0) {
                currentButtonState = 'video';
              } else {
                currentButtonState = null;
              }
              justFinishedExport = false;
              updateStatus('connected', '');
            };
            // 绑定关闭按钮
            bindPillCloseButton(statusEl, function() {
              pendingStates.savedGif.active = false;
              pendingStates.savedGif.count = 0;
              gifBackupCount = 0;
              if (pendingStates.savedVideo.active && pendingStates.savedVideo.count > 0) {
                currentButtonState = 'video';
              } else {
                currentButtonState = null;
              }
              justFinishedExport = false;
              updateStatus('connected', '');
            });
            return;
          }

          // 6. 兼容旧逻辑：检查 exportedGifCount（如果新状态系统没捕获到）
          if (exportedGifCount > 0) {
            pendingStates.exported.active = true;
            pendingStates.exported.count = exportedGifCount;
            currentButtonState = 'exported';
            const exportText = `已导出 ${exportedGifCount} 段 GIF`;
            statusEl.innerHTML = `
              <div class="bezel"></div>
              <div class="face"></div>
              <span class="status-dot" style="position: relative; z-index: 2;"></span>
              <span style="position: relative; z-index: 2;">${exportText}</span>
              ${getPillCloseButtonHTML()}
            `;
            statusEl.className = 'connection-pill connected interactive';
            statusEl.style.cursor = 'pointer';
            statusEl.onclick = function() {
              if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'open-folder', targetFolder: 'GIF-导出' }));
              }
              // ✅ 使用新的状态管理系统
              pendingStates.exported.active = false;
              pendingStates.exported.count = 0;
              exportedGifCount = 0;
              justFinishedExport = false;
              currentButtonState = null;
              updateStatus('connected', '已连接');
            };
            // 绑定关闭按钮
            bindPillCloseButton(statusEl, function() {
              pendingStates.exported.active = false;
              pendingStates.exported.count = 0;
              exportedGifCount = 0;
              justFinishedExport = false;
              currentButtonState = null;
              updateStatus('connected', '已连接');
            });
            return;
          }

          // 7. Default: Connected (Screen Style)
          // No counts, show connected state
          currentButtonState = null; // Ensure state is unlocked
          statusEl.innerHTML = `
            <span class="status-dot" style="position: relative; z-index: 2;"></span>
            <span style="position: relative; z-index: 2;">已连接</span>
          `;
          statusEl.className = 'connection-pill connected';
      });
      } catch (error) {
        console.error('❌ updateStatus 错误:', error);
      }
    }

    let isRealtimeActive = false;

    function showWorkArea(mode) {
      // 🛡️ 防止初始化未完成时崩溃
      try {
        currentMode = mode;
        document.getElementById('modeSelection').classList.add('hidden');
        document.getElementById('workArea').classList.add('active');
        
        collapseLog();
        
        // Legacy UI update (safeguard if elements exist)
        const activeModeIcon = document.getElementById('activeModeIcon');
        const activeModeTitle = document.getElementById('activeModeTitle');
        if (activeModeIcon) activeModeIcon.style.display = 'none'; // Hide legacy icon
        if (activeModeTitle) activeModeTitle.style.display = 'none'; // Hide legacy title

        if (mode === 'realtime') {
          // Realtime Mode Setup - Start in Idle State
          updateStartScreenUI('idle');
          
          // Update Status
          if (ws && ws.readyState === 1) {
            updateStatus('connected', '已连接');
          } else {
            updateStatus('disconnected', '点击重连');
          }
        } else {
          // Legacy Manual Mode (should not be reached in new flow, but keep for safety)
          if (ws && ws.readyState === 1) {
            updateStatus('connected', '已连接');
          }
        }
      } catch (error) {
        console.error('❌ showWorkArea 错误:', error);
      }
    }

    function updateStartScreenUI(state) {
        // 🛡️ 防止初始化未完成时崩溃
        try {
            const btn = document.getElementById('mainStartBtn');
            const label = document.getElementById('realtimeLabel');
            
            // Legacy support checks
            const oldTitle = document.getElementById('mainStatusTitle');
            const oldSubtitle = document.getElementById('mainStatusSubtitle');
            
            if (!btn) return;
            
            if (state === 'listening') {
                btn.classList.add('active');
                isRealtimeActive = true;
                
                // Label text and color remain unchanged
                
                if (oldTitle) oldTitle.textContent = '正在实时同步';
            } else {
                btn.classList.remove('active');
                isRealtimeActive = false;
                
                // Label text and color remain unchanged
                
                if (oldTitle) {
                    oldTitle.textContent = '点击开启实时同步';
                    oldTitle.style.color = 'var(--text-primary)';
                }
            }
        } catch (error) {
            console.error('❌ updateStartScreenUI 错误:', error);
        }
    }

    function toggleRealtimeSync() {
        // 🛡️ 防止初始化未完成时崩溃
        try {
            if (isRealtimeActive) {
                stopRealtimeSync();
            } else {
                startRealtimeSync();
            }
        } catch (error) {
            console.error('❌ toggleRealtimeSync 错误:', error);
        }
    }

    function startRealtimeSync() {
        // 🛡️ 防止初始化未完成时崩溃
        try {
            if (ws && ws.readyState === 1) {
                ws.send(JSON.stringify({ type: 'start-realtime' }));
                log('⚡ 实时同步已启动');
                updateStartScreenUI('listening');
                updateStatus('connected', '运行中');
            } else {
                showToast('未连接到服务器', 'error');
                updateStatus('disconnected', '点击重连');
            }
        } catch (error) {
            console.error('❌ startRealtimeSync 错误:', error);
            showToast('启动失败，请稍后重试', 'error');
        }
    }


    function showModeSelection() {
      if (currentMode === 'realtime' && ws && ws.readyState === 1) {
        ws.send(JSON.stringify({ type: 'stop-realtime' }));
        log('⏸️  实时同步已停止');
      }

      screenshotCount = 0;
      manualDragCount = 0;
      skippedFilesSet.clear();
      gifBackupCount = 0;
      isManualSyncing = false; // 重置手动同步标志
      document.getElementById('count').textContent = '0';
      
      currentMode = null;
      document.getElementById('workArea').classList.remove('active');
      document.getElementById('modeSelection').classList.remove('hidden');
      updateStatus('connected', '已返回模式选择');
    }

    /* 
    document.getElementById('realtimeBtn').onclick = function () { showWorkArea('realtime'); };
    document.getElementById('manualBtn').onclick = function () { showWorkArea('manual'); };
    */

    document.getElementById('syncBtn').onclick = function () {
      // 第一道防线：使用 JavaScript 标志变量（更快更可靠）
      if (isManualSyncing) {
        console.log('⚠️  同步正在进行中，请勿重复点击（标志阻止）');
        return;
      }
      
      const syncBtn = document.getElementById('syncBtn');
      
      // 第二道防线：检查按钮状态
      if (syncBtn.disabled) {
        console.log('⚠️  同步正在进行中，请勿重复点击（按钮已禁用）');
        return;
      }
      
      // 检查连接状态
      if (!ws || ws.readyState !== 1) {
        log('❌ 未连接');
        updateStatus('disconnected', '点击重连');
        return;
      }
      
      // ✅ 立即设置标志和禁用按钮（双重保护），不等待任何异步操作
      isManualSyncing = true;
      syncBtn.disabled = true;
      syncBtn.textContent = '同步中';
      
      // 设置超时保护：如果 60 秒内没有收到响应，自动恢复按钮
      const syncTimeout = setTimeout(() => {
        if (isManualSyncing || syncBtn.disabled) {
          console.warn('⚠️  同步超时，自动恢复按钮状态');
          isManualSyncing = false;
          syncBtn.disabled = false;
          syncBtn.textContent = '立即同步';
          updateStatus('connected', '同步超时');
        }
      }, 60000);
      
      // 保存超时 ID，以便在收到响应时清除
      syncBtn.dataset.syncTimeout = syncTimeout;
      
      log('🫳🏻 开始同步...');
      updateStatus('connected', '正在同步');
      manualDragCount = 0;
      skippedFilesSet.clear();
      gifBackupCount = 0;
      
      // 立即发送同步请求
      try {
        ws.send(JSON.stringify({ type: 'manual-sync' }));
        console.log('📨 已发送手动同步请求');
      } catch (error) {
        console.error('❌ 发送同步请求失败:', error);
        clearTimeout(syncTimeout);
        isManualSyncing = false; // 重置标志
        syncBtn.disabled = false;
        syncBtn.textContent = '立即同步';
        updateStatus('connected', '请求失败');
      }
    };

    document.getElementById('stopBtn').onclick = function() {
      stopRealtimeSync();
      // 不再显示模式选择，直接停留在当前界面
      log('⏸️  实时同步已停止');
      updateStatus('connected', '已停止'); 
    }

    function stopRealtimeSync() {
      // 🛡️ 防止初始化未完成时崩溃
      try {
        // 无论当前模式是什么，只要 WebSocket 连接存在，就发送停止命令
        // 这样可以确保在关闭插件时，所有正在运行的监听都会被停止
        if (ws && ws.readyState === 1) {
          ws.send(JSON.stringify({ type: 'stop-realtime' }));
          log('⏸️  已停止同步监听');
        }
        
        // Update UI to Idle
        updateStartScreenUI('idle');
        updateStatus('connected', '已连接');
      } catch (error) {
        console.error('❌ stopRealtimeSync 错误:', error);
      }
    }

    document.getElementById('locateFrameBtn').onclick = function () {
      parent.postMessage({ pluginMessage: { type: 'locate-frame' } }, '*');
    };

    document.getElementById('backBtn').onclick = function () { 
      // 不再返回模式选择，而是重新开始实时同步
      if (currentMode === 'realtime') {
      stopRealtimeSync();
        log('⏸️  实时同步已停止');
        updateStatus('connected', '已停止');
      } else {
        // 如果是手动模式，则重新开始实时模式
        showWorkArea('realtime');
      }
    };

    function setQRCodeImages() {
      const qrGoogleScreenshot = document.getElementById('qrGoogleScreenshot');
      const qrGoogleAlbum = document.getElementById('qrGoogleAlbum');
      const qrIcloudScreenshot = document.getElementById('qrIcloudScreenshot');
      const qrIcloudAlbum = document.getElementById('qrIcloudAlbum');
      
      const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const uris = getQRCodeURI(isDark);
      
      if (qrGoogleScreenshot) qrGoogleScreenshot.src = uris.googleScreenshot || uris.google;
      if (qrGoogleAlbum) qrGoogleAlbum.src = uris.googleAlbum || uris.google;
      if (qrIcloudScreenshot) qrIcloudScreenshot.src = uris.icloudScreenshot || uris.icloud;
      if (qrIcloudAlbum) qrIcloudAlbum.src = uris.icloudAlbum || uris.icloud;
    }

    // QR Code Zoom Functions
    function setupQRCodeZoom() {
      const qrImages = [
        { id: 'qrGoogleScreenshot', label: '直接截图' },
        { id: 'qrGoogleAlbum', label: '相册选择' },
        { id: 'qrIcloudScreenshot', label: '直接截图' },
        { id: 'qrIcloudAlbum', label: '相册选择' }
      ];

      qrImages.forEach(({ id, label }) => {
        const img = document.getElementById(id);
        if (img) {
          img.classList.add('qr-clickable');
          img.onclick = () => openQRZoom(img.src, label);
        }
      });

      // Click overlay to close
      const overlay = document.getElementById('qrZoomOverlay');
      if (overlay) {
        overlay.onclick = closeQRZoom;
      }
    }

    function openQRZoom(src, label) {
      const overlay = document.getElementById('qrZoomOverlay');
      const zoomImage = document.getElementById('qrZoomImage');
      const zoomLabel = document.getElementById('qrZoomLabel');

      if (overlay && zoomImage && zoomLabel) {
        zoomImage.src = src;
        zoomLabel.textContent = label;
        overlay.classList.add('show');
      }
    }

    function closeQRZoom() {
      const overlay = document.getElementById('qrZoomOverlay');
      if (overlay) {
        overlay.classList.remove('show');
      }
    }

    function setIdStepImages() {
      const idStep1Image = document.getElementById('idStep1Image');
      const idStep2Image = document.getElementById('idStep2Image');
      const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      
      if (idStep1Image) {
        idStep1Image.src = IMAGE_BASE_URL + (isDark ? 'id-step1-black.png' : 'id-step1-white.png');
      }
      if (idStep2Image) {
        idStep2Image.src = IMAGE_BASE_URL + (isDark ? 'id-step2-black.png' : 'id-step2-white.png');
      }
    }

    function updateIconColors() {
       const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
       // logo.svg is now inline SVG, no need to update src
       // kept for potential future use or other icons
    }

    function handleThemeChange() {
      setQRCodeImages();
      setIdStepImages();
      updateIconColors();
    }
    
    if (document.readyState === 'loading') {
      window.addEventListener('DOMContentLoaded', function() {
        handleThemeChange();
        setupQRCodeZoom();
      });
    } else {
      handleThemeChange();
      setupQRCodeZoom();
    }
    
    const themeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    themeMediaQuery.addEventListener('change', handleThemeChange);

    const viewUseCases = document.getElementById('viewUseCases'); // Legacy, may be null

    function updateQRCodeDisplay() {
      const qrGoogleScreenshotContainer = document.getElementById('qrGoogleScreenshotContainer');
      const qrGoogleAlbumContainer = document.getElementById('qrGoogleAlbumContainer');
      const qrIcloudScreenshotContainer = document.getElementById('qrIcloudScreenshotContainer');
      const qrIcloudAlbumContainer = document.getElementById('qrIcloudAlbumContainer');
      const googleDriveHint = document.getElementById('googleDriveHint');
      const qrCodesContainer = document.getElementById('qrCodesContainer');
      const userIdDisplaySection = document.getElementById('userIdDisplaySection');
      const noModeMessage = document.getElementById('noModeMessage');
      const qrSubtitle = document.getElementById('qrSubtitle');
      const shortcutGuideTitle = document.getElementById('shortcutGuideTitle');
      const userIdTitle = document.getElementById('userIdTitle');
      const userIdSubtitle = document.getElementById('userIdSubtitle');
      
      if (qrGoogleScreenshotContainer) qrGoogleScreenshotContainer.style.display = 'none';
      if (qrGoogleAlbumContainer) qrGoogleAlbumContainer.style.display = 'none';
      if (qrIcloudScreenshotContainer) qrIcloudScreenshotContainer.style.display = 'none';
      if (qrIcloudAlbumContainer) qrIcloudAlbumContainer.style.display = 'none';
      // if (googleDriveHint) googleDriveHint.style.display = 'none';
      if (userIdDisplaySection) userIdDisplaySection.style.display = 'none';
      if (noModeMessage) noModeMessage.style.display = 'none';
      if (qrSubtitle) qrSubtitle.style.display = 'none';
      if (qrCodesContainer) qrCodesContainer.style.display = 'none';
      if (userIdSubtitle) userIdSubtitle.style.display = 'none'; // Always hide original subtitles
      
      if (currentSyncMode === 'drive' && typeof ENABLE_GOOGLE_DRIVE !== 'undefined' && ENABLE_GOOGLE_DRIVE) {
        if (qrCodesContainer) qrCodesContainer.style.display = 'grid';
        if (qrGoogleScreenshotContainer) qrGoogleScreenshotContainer.style.display = 'flex';
        if (qrGoogleAlbumContainer) qrGoogleAlbumContainer.style.display = 'flex';
        
        if (userIdDisplaySection) userIdDisplaySection.style.display = 'block';
        
        // Google Mode Titles
        if (shortcutGuideTitle) shortcutGuideTitle.textContent = '01 扫码获取快捷指令';
        if (userIdTitle) userIdTitle.textContent = '02 将 User ID 填入指令的文本框中';
        
      } else if (currentSyncMode === 'icloud') {
        if (qrCodesContainer) qrCodesContainer.style.display = 'grid';
        if (qrIcloudScreenshotContainer) qrIcloudScreenshotContainer.style.display = 'flex';
        if (qrIcloudAlbumContainer) qrIcloudAlbumContainer.style.display = 'flex';
        
        // iCloud Mode Titles
        if (shortcutGuideTitle) shortcutGuideTitle.textContent = '扫码获取快捷指令';
      } else {
        // No mode selected or unknown mode
        if (noModeMessage) noModeMessage.style.display = 'block';
      }
    }

    // Tab Switching Logic
    const tabDesktop = document.getElementById('tabDesktop');
    const tabMobile = document.getElementById('tabMobile');
    const contentDesktop = document.getElementById('contentDesktop');
    const contentMobile = document.getElementById('contentMobile');

    let currentTab = 'desktop';
    
    function switchTab(tab) {
        if (tab === currentTab) return; // 如果已经是当前tab，不执行切换
        
        const isGoingRight = (currentTab === 'desktop' && tab === 'mobile');
        const oldContent = currentTab === 'desktop' ? contentDesktop : contentMobile;
        const newContent = tab === 'desktop' ? contentDesktop : contentMobile;
        
        // 更新tab按钮状态
        if (tab === 'desktop') {
            tabDesktop.classList.add('active');
            tabMobile.classList.remove('active');
        } else {
            tabDesktop.classList.remove('active');
            tabMobile.classList.add('active');
        }
        
        // 旧内容滑出
        oldContent.classList.add(isGoingRight ? 'slide-out-left' : 'slide-out-right');
        oldContent.classList.remove('active');
        
        // 等待旧内容滑出后，显示新内容
        setTimeout(() => {
            oldContent.style.display = 'none';
            oldContent.classList.remove('slide-out-left', 'slide-out-right');
            
            // 显示新内容
            newContent.style.display = 'block';
            newContent.classList.add(isGoingRight ? 'slide-in-right' : 'slide-in-left');
            
            // 在动画结束后清理动画类
            setTimeout(() => {
                newContent.classList.remove('slide-in-left', 'slide-in-right');
                newContent.classList.add('active');
            }, 300);
        }, 150); // 滑出动画的一半时间，实现交叉淡入淡出
        
        currentTab = tab;
        
        // Trigger QR updates when mobile tab is active
        if (tab === 'mobile') {
      updateQRCodeDisplay();
      if (ws && ws.readyState === 1) {
        if (!currentSyncMode) {
            ws.send(JSON.stringify({ type: 'get-sync-mode' }));
        }
        ws.send(JSON.stringify({ type: 'get-user-id' }));
      }
        }
    }

    if (tabDesktop) tabDesktop.onclick = function() { switchTab('desktop'); };
    if (tabMobile) tabMobile.onclick = function() { switchTab('mobile'); };

    function openSettings(defaultTab = 'desktop') {
      if (isMinimized) toggleMinimize();
      
      // Request info
      if (ws && ws.readyState === 1) {
           ws.send(JSON.stringify({ type: 'get-sync-mode' }));
           ws.send(JSON.stringify({ type: 'get-user-id' }));
           // 请求 GIF 备份设置
           ws.send(JSON.stringify({ type: 'get-gif-backup-setting' }));
           // 请求备份截图设置 (新)
           ws.send(JSON.stringify({ type: 'get-backup-screenshot-setting' }));
           ws.send(JSON.stringify({ type: 'get-keep-gif-in-icloud-setting' }));
      }
      parent.postMessage({ pluginMessage: { type: 'get-plugin-version' } }, '*');
      
      updateSyncModeDisplay();
      loadSizeSettings();
      loadLayoutSettings();
      
      // 初始化tab状态（无动画）
      currentTab = defaultTab;
      if (defaultTab === 'desktop') {
          tabDesktop.classList.add('active');
          tabMobile.classList.remove('active');
          contentDesktop.style.display = 'block';
          contentDesktop.classList.add('active');
          contentMobile.style.display = 'none';
          contentMobile.classList.remove('active');
      } else {
          tabDesktop.classList.remove('active');
          tabMobile.classList.add('active');
          contentDesktop.style.display = 'none';
          contentDesktop.classList.remove('active');
          contentMobile.style.display = 'block';
          contentMobile.classList.add('active');
          updateQRCodeDisplay();
      }
      
      settingsOverlay.classList.add('show');
    }

    if (viewUseCases) {
        viewUseCases.onclick = function() { openSettings('mobile'); };
    }

    // Update QRCode display check to look for mobile tab
    function checkQRCodeVisibility() {
        return settingsOverlay.classList.contains('show') && tabMobile.classList.contains('active');
      }

    const settingsOverlay = document.getElementById('settingsOverlay');
    const openSettingsBtn = document.getElementById('openSettings');
    const settingsClose = document.getElementById('settingsClose');
    const switchToDrive = document.getElementById('switchToDrive');
    const switchToAliyun = document.getElementById('switchToAliyun');
    const switchToIcloud = document.getElementById('switchToIcloud');
    
    if (typeof ENABLE_GOOGLE_DRIVE !== 'undefined' && !ENABLE_GOOGLE_DRIVE) {
      if (switchToDrive) switchToDrive.style.display = 'none';
      // Hide others handled in updateQRCodeDisplay
    }
    
    if (typeof ENABLE_ALIYUN !== 'undefined' && !ENABLE_ALIYUN) {
      if (switchToAliyun) switchToAliyun.style.display = 'none';
    }
    
    const imageWidthInput = document.getElementById('imageWidthInput');
    const imageHeightInput = document.getElementById('imageHeightInput');
    const saveSizeSettingsBtn = document.getElementById('saveSizeSettings');
    const clearSizeSettingsBtn = document.getElementById('clearSizeSettings');
    const frameColumnsInput = document.getElementById('frameColumnsInput');
    const saveLayoutSettingsBtn = document.getElementById('saveLayoutSettings');
    const clearLayoutSettingsBtn = document.getElementById('clearLayoutSettings');
    const backupModeSelect = document.getElementById('backupModeSelect');
    const backupSection = document.getElementById('backupSection');
    const toggleMinimizeBtn = document.getElementById('toggleMinimize');
    
    // 禁用输入框的鼠标滚轮调整数值功能
    [imageWidthInput, imageHeightInput, frameColumnsInput].forEach(input => {
      if (input) {
        input.addEventListener('wheel', function(e) {
          e.preventDefault();
        }, { passive: false });
      }
    });
    const minimizeIcon = document.getElementById('minimizeIcon');
    const appRoot = document.querySelector('.app');
    
    // Save button (consolidated)
    const saveSettingsBtn = document.getElementById('globalSaveBtn');
    
    // Track original values to detect changes
    let originalSettings = {
      imageWidth: '',
      imageHeight: '',
      frameColumns: '',
      backupMode: 'none'
    };
    
    // Track current values
    let currentSettings = {
      imageWidth: '',
      imageHeight: '',
      frameColumns: '',
      backupMode: 'none'
    };
    
    // Check for changes and update save button state
    function checkSettingsChanges() {
      // Compare current inputs with original settings
      const widthChanged = imageWidthInput ? (imageWidthInput.value != originalSettings.imageWidth) : false;
      const heightChanged = imageHeightInput ? (imageHeightInput.value != originalSettings.imageHeight) : false;
      const columnsChanged = frameColumnsInput ? (frameColumnsInput.value != originalSettings.frameColumns) : false;
      const backupChanged = backupModeSelect ? (backupModeSelect.value != originalSettings.backupMode) : false;
      
      const hasChanges = widthChanged || heightChanged || columnsChanged || backupChanged;
      
      if (saveSettingsBtn) {
        if (hasChanges) {
          saveSettingsBtn.disabled = false;
          saveSettingsBtn.classList.remove('disabled');
        } else {
          saveSettingsBtn.disabled = true;
          saveSettingsBtn.classList.add('disabled');
        }
      }
      
      // Update current settings tracking for inputs
      if (imageWidthInput) currentSettings.imageWidth = imageWidthInput.value;
      if (imageHeightInput) currentSettings.imageHeight = imageHeightInput.value;
      if (frameColumnsInput) currentSettings.frameColumns = frameColumnsInput.value;
    }
    
    // Add event listeners to inputs
    if (imageWidthInput) imageWidthInput.addEventListener('input', checkSettingsChanges);
    if (imageHeightInput) imageHeightInput.addEventListener('input', checkSettingsChanges);
    if (frameColumnsInput) frameColumnsInput.addEventListener('input', checkSettingsChanges);
    // 动态调整 select 宽度以适应当前选项文字
    function adjustSelectWidth(selectEl) {
      if (!selectEl) return;
      
      // 创建临时 span 测量文字宽度
      const tempSpan = document.createElement('span');
      tempSpan.style.visibility = 'hidden';
      tempSpan.style.position = 'absolute';
      tempSpan.style.whiteSpace = 'nowrap';
      tempSpan.style.fontSize = getComputedStyle(selectEl).fontSize;
      tempSpan.style.fontFamily = getComputedStyle(selectEl).fontFamily;
      tempSpan.textContent = selectEl.options[selectEl.selectedIndex].text;
      document.body.appendChild(tempSpan);
      
      // 设置宽度：文字宽度 + padding (10px 左 + 28px 右给箭头) + 边框
      const textWidth = tempSpan.offsetWidth;
      selectEl.style.width = (textWidth + 42) + 'px';
      
      document.body.removeChild(tempSpan);
    }

    if (backupModeSelect) {
      backupModeSelect.addEventListener('change', function() {
        checkSettingsChanges();
        adjustSelectWidth(this);
        this.blur(); // Remove focus to restore raised style immediately
      });
      // 初始化时也调整一次宽度
      adjustSelectWidth(backupModeSelect);
    }
    
    function loadSizeSettings() {
      parent.postMessage({ pluginMessage: { type: 'get-size-settings' } }, '*');
    }
    
    // Consolidated save function
    function saveAllSettings() {
      if (!saveSettingsBtn || saveSettingsBtn.disabled) return;
      if (!imageWidthInput || !imageHeightInput || !frameColumnsInput) {
        console.error('Settings inputs not initialized');
        return;
      }
      
      const width = imageWidthInput.value.trim();
      const height = imageHeightInput.value.trim();
      const columns = frameColumnsInput.value.trim();
      const backupMode = backupModeSelect ? backupModeSelect.value : 'none';
      
      if (width && (isNaN(width) || parseInt(width) <= 0)) {
        showToast('宽度必须是大于0的数字', 'error');
        return;
      }
      if (height && (isNaN(height) || parseInt(height) <= 0)) {
        showToast('高度必须是大于0的数字', 'error');
        return;
      }
      if (columns && (isNaN(columns) || parseInt(columns) <= 0)) {
        showToast('布局每行必须是大于0的数字', 'error');
        return;
      }
      
      // 1. Save Size Settings
      parent.postMessage({
        pluginMessage: {
          type: 'update-size-settings',
          width: width ? parseInt(width) : null,
          height: height ? parseInt(height) : null
        }
      }, '*');
      
      // 2. Save Layout Settings
      parent.postMessage({
        pluginMessage: {
          type: 'update-layout-settings',
          columns: columns ? parseInt(columns) : null
        }
      }, '*');
      
      // 3. Save Backup Screenshot Setting
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: 'update-backup-screenshot-setting',
          mode: backupMode
        }));
    }
    
      // Update original settings to match current state (reset change detection)
      originalSettings.imageWidth = width;
      originalSettings.imageHeight = height;
      originalSettings.frameColumns = columns;
      originalSettings.backupMode = backupMode;
      
      checkSettingsChanges();
      
      // Show success toast and close settings
      showToast('设置已保存', 'success');
      setTimeout(() => {
        closeSettings();
      }, 300);
    }
    
    if (saveSettingsBtn) {
      saveSettingsBtn.onclick = saveAllSettings;
    }
    
    function loadLayoutSettings() {
      parent.postMessage({ pluginMessage: { type: 'get-layout-settings' } }, '*');
    }
    
    function loadServerPath() {
      parent.postMessage({ pluginMessage: { type: 'get-server-path' } }, '*');
    }
    
    openSettingsBtn.onclick = function() {
      openSettings('desktop');
    };
    
    const openFolderBtn = document.getElementById('openFolder');
    if (openFolderBtn) {
      openFolderBtn.onclick = function() {
        if (ws && ws.readyState === WebSocket.OPEN) {
          // 打开 ScreenSyncImg 根文件夹（不指定子文件夹）
          ws.send(JSON.stringify({ type: 'open-local-folder' }));
          log('📂 已请求打开文件夹');
        } else {
          log('⚠️ 未连接到服务器');
        }
      };
    }
    
    // 全局变量：跟踪待更新的类型
    let pendingUpdateType = null; // 'plugin' or 'server'
    let pendingUpdateData = {};
    
    // 处理插件更新信息
    function handlePluginUpdateInfo(data) {
      latestPluginVersion = data.latestVersion;
      pluginUpdateUrl = data.updateUrl;
      
      // 如果还没有收到真实的插件版本信息，暂存更新信息，等待版本信息到达后再处理
      if (currentPluginVersion === null) {
        console.log('⏳ 插件版本信息尚未到达，暂存更新信息');
        pendingPluginUpdateInfo = data;
        return;
      }
      
      // 比较版本号
      if (data.hasUpdate && compareVersions(latestPluginVersion, currentPluginVersion) > 0) {
        // 检查是否是用户已经点击"稍后"忽略的版本
        const shouldShow = !dismissedPluginVersion || compareVersions(latestPluginVersion, dismissedPluginVersion) > 0;
        
        if (shouldShow) {
          // 有新版本，且不是用户已忽略的版本，显示顶部通知条
          pendingUpdateType = 'plugin';
          pendingUpdateData = data;
          showUpdateBanner('plugin', currentPluginVersion, latestPluginVersion);
          console.log(`📢 发现新版本: v${currentPluginVersion} → v${latestPluginVersion}`);
        } else {
          console.log(`🔕 用户已忽略版本 v${dismissedPluginVersion}，不再显示`);
        }
      } else {
        console.log(`✅ 已是最新版本: v${currentPluginVersion}`);
      }
    }
    
    // 处理服务器更新信息
    function handleServerUpdateInfo(data) {
      if (data.hasUpdate) {
        // 首先检查是否已经安装了这个版本（从 localStorage）
        if (installedServerVersion && compareVersions(data.latestVersion, installedServerVersion) <= 0) {
          console.log(`✅ 已安装最新版本: v${installedServerVersion}，跳过更新提示`);
          return;
        }
        
        // 检查是否是用户已经点击"稍后"忽略的版本
        const shouldShow = !dismissedServerVersion || compareVersions(data.latestVersion, dismissedServerVersion) > 0;
        
        if (shouldShow) {
          // 如果已经有插件更新待处理，服务器更新优先
            pendingUpdateType = 'server';
          pendingUpdateData = data;
          showUpdateBanner('server', data.currentVersion, data.latestVersion);
          console.log(`📢 发现新版本: v${data.currentVersion} → v${data.latestVersion}`);
        } else {
          console.log(`🔕 用户已忽略版本 v${dismissedServerVersion}，不再显示`);
        }
      }
    }
    
    // 显示顶部更新通知条（统一显示，不区分插件/服务器）
    function showUpdateBanner(componentName, currentVer, latestVer) {
      const banner = document.getElementById('updateBanner');
      const text = document.getElementById('updateBannerText');
      
      if (banner && text) {
        // 统一显示为"发现新版本 v版本号"
        text.textContent = `发现新版本 v${latestVer}`;
        banner.classList.add('show');
        
        // 如果当前未最小化，调整窗口高度以适应 Banner
        if (typeof isMinimized !== 'undefined' && !isMinimized) {
          parent.postMessage({
            pluginMessage: { type: 'resize', width: 360, height: 460 }
          }, '*');
        }
      }
    }
    
    // 隐藏顶部更新通知条
    function hideUpdateBanner() {
      const banner = document.getElementById('updateBanner');
      if (banner) {
        banner.classList.remove('show');
        // 确保样式被重置（配合最小化逻辑）
        banner.style.display = '';
        
        // 如果当前未最小化，恢复窗口高度
        if (typeof isMinimized !== 'undefined' && !isMinimized) {
          parent.postMessage({
            pluginMessage: { type: 'resize', width: 360, height: 400 }
          }, '*');
        }
      }
    }
    
    // 处理插件版本信息
    function handlePluginVersionInfo(data) {
      currentPluginVersion = data.version || '1.0.0';
      console.log('📦 当前插件版本:', currentPluginVersion);
      
      // 如果有暂存的更新信息，现在可以处理了
      if (pendingPluginUpdateInfo) {
        console.log('📦 处理暂存的插件更新信息');
        const tempData = pendingPluginUpdateInfo;
        pendingPluginUpdateInfo = null;
        handlePluginUpdateInfo(tempData);
      }
    }
    
    // 比较版本号（简单版本，支持 x.y.z 格式）
    function compareVersions(v1, v2) {
      const parts1 = v1.split('.').map(Number);
      const parts2 = v2.split('.').map(Number);
      const maxLength = Math.max(parts1.length, parts2.length);
      
      for (let i = 0; i < maxLength; i++) {
        const part1 = parts1[i] || 0;
        const part2 = parts2[i] || 0;
        if (part1 > part2) return 1;
        if (part1 < part2) return -1;
      }
      return 0;
    }
    
    // 处理统一更新进度（插件 + 服务器）
    function handleUpdateProgress(data) {
      const bannerBtn = document.getElementById('updateBannerNow');
      
      if (data.status === 'downloading') {
        // 只更新按钮文字，不显示 toast
        if (bannerBtn) {
          bannerBtn.disabled = true;
          // 保持按钮样式，不添加 transparent 类
          // bannerBtn.classList.add('transparent'); // 已移除
          bannerBtn.textContent = data.progress ? `下载中 ${data.progress}%` : '下载中...';
      }
      } else if (data.status === 'extracting' || data.status === 'checking' || data.status === 'installing') {
        // 合并中间状态为“正在安装”
        if (bannerBtn) {
          // bannerBtn.classList.add('transparent'); // 已移除
          bannerBtn.textContent = '正在安装';
        }
      } else if (data.status === 'completed') {
        const successMsg = data.message || `更新完成！已更新 ${data.updatedCount || 0} 个文件`;
        showToast(successMsg, 'success');
        
        // 更新按钮状态为“更新完成”
        if (bannerBtn) {
          bannerBtn.textContent = '更新完成';
          bannerBtn.classList.add('success');
          
          // 成功状态：绿色描边风格
          bannerBtn.style.background = 'transparent';
          bannerBtn.style.color = '#4CAF50'; 
          bannerBtn.style.borderColor = '#4CAF50';
          bannerBtn.style.opacity = '1';
        }
        
        // 保存当前版本号到 localStorage，防止 banner 再次弹出
        if (data.latestVersion) {
          installedServerVersion = data.latestVersion.replace(/^v/, '');
          try {
            localStorage.setItem('currentServerVersion', installedServerVersion);
            console.log(`💾 已保存当前版本: ${installedServerVersion}`);
          } catch (error) {
            console.log('⚠️ 无法保存到 localStorage:', error.message);
          }
        }
        
        // 隐藏更新通知条 (延迟一点以便用户看到“更新完成”)
        setTimeout(() => {
          hideUpdateBanner();
        }, 1500);
        
        // 更新版本（如果提供）
        if (data.version) {
          currentPluginVersion = data.version.replace(/^v/, '');
          }
        
        // 清除待更新标记和忽略记录
        pendingUpdateType = null;
        pendingUpdateData = {};
        dismissedPluginVersion = null;
        dismissedServerVersion = null;
        
        // 3秒后提示用户重启插件
        setTimeout(() => {
          showToast('更新完成！请关闭并重新打开插件', 'success');
        }, 3000);
        
      } else if (data.status === 'error') {
        showToast(data.message || '更新失败', 'error');
        // 重置按钮状态，但保持 banner 主文字不变
        if (bannerBtn) {
          bannerBtn.disabled = false;
          // bannerBtn.classList.remove('transparent'); // 已移除添加逻辑
          bannerBtn.textContent = '立即更新';
          // 恢复样式
          bannerBtn.classList.remove('success');
          bannerBtn.style.background = '';
          bannerBtn.style.color = '';
          bannerBtn.style.borderColor = '';
          bannerBtn.style.opacity = '';
        }
      }
    }
    
    // 保留旧函数名作为别名（兼容性）
    function handlePluginUpdateProgress(data) {
      handleUpdateProgress(data);
    }
    
    function handleServerUpdateProgress(data) {
      handleUpdateProgress(data);
    }

    // SVG Icons for Toast
    function getToastIcon(type) {
      if (type === 'success') {
        return '<svg viewBox="0 0 24 24" fill="none"><circle cx="12" cy="12" r="10" fill="currentColor"/><path d="M16.5 9.5l-5.5 5.5-3-3" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
      } else if (type === 'error') {
        return '<svg viewBox="0 0 24 24" fill="none"><circle cx="12" cy="12" r="10" fill="currentColor"/><path d="M12 8v5M12 16.5v.5" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
      } else if (type === 'loading') {
        return '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="animation: spin 1s linear infinite;"><circle cx="12" cy="12" r="10" stroke-dasharray="31.416" stroke-dashoffset="7.854" opacity="0.3"></circle><circle cx="12" cy="12" r="10" stroke-dasharray="31.416" stroke-dashoffset="23.562"></circle></svg>';
      }
      return '';
    }
    
    // Add spin animation for loading icon
    const style = document.createElement('style');
    style.textContent = '@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }';
    document.head.appendChild(style);
    
    // ✅ Toast 管理：防止高频弹出和重复显示
    let toastTimer = null; // 当前 toast 的隐藏定时器
    let lastToastMessage = ''; // 上一次显示的 toast 内容
    let lastToastTime = 0; // 上一次显示 toast 的时间
    const TOAST_DEBOUNCE_TIME = 500; // 去重时间窗口（毫秒）
    
    function showToast(message, type = 'info') {
      // 🛡️ 防止初始化未完成时崩溃
      try {
        // 最小化状态下不显示 toast
        if (isMinimized) return;
        
        const toast = document.getElementById('toast');
        if (!toast) return;
      
      const iconEl = toast.querySelector('.toast-icon');
      const messageEl = toast.querySelector('.toast-message');
      
      if (!iconEl || !messageEl) return;
      
      // Remove emoji and trailing ellipsis from message
      let cleanMessage = message
        .replace(/✅|❌|⏳|⚠️|📸|📍/g, '')
        .replace(/\.\.\./g, '')
        .trim();
      
      // ✅ 去重：如果在短时间内显示相同内容的 toast，则忽略
      const now = Date.now();
      if (cleanMessage === lastToastMessage && (now - lastToastTime) < TOAST_DEBOUNCE_TIME) {
        console.log('🔇 Toast 去重：跳过重复消息', cleanMessage);
        return;
      }
      
      // ✅ 清除旧的定时器，避免冲突
      if (toastTimer) {
        clearTimeout(toastTimer);
        toastTimer = null;
      }
      
      // 更新记录
      lastToastMessage = cleanMessage;
      lastToastTime = now;
      
      // ✅ 如果当前有显示的 toast，先立即隐藏
      if (toast.classList.contains('show')) {
        toast.classList.remove('show');
        // 等待淡出动画完成后再显示新的
        setTimeout(() => {
          displayToast(toast, iconEl, messageEl, cleanMessage, type);
        }, 300);
      } else {
        displayToast(toast, iconEl, messageEl, cleanMessage, type);
      }
      } catch (error) {
        console.error('❌ showToast 错误:', error);
      }
    }
    
    // ✅ 实际显示 toast 的函数（内部使用）
    function displayToast(toast, iconEl, messageEl, cleanMessage, type) {
      // Set icon
      if (type === 'success' || type === 'error' || type === 'loading') {
        iconEl.innerHTML = getToastIcon(type);
        iconEl.style.display = 'flex';
      } else {
        iconEl.innerHTML = '';
        iconEl.style.display = 'none';
      }
      
      // Set message
      messageEl.textContent = cleanMessage;
      messageEl.innerHTML = cleanMessage; // Allow HTML content
      
      // Set toast class
      toast.className = 'toast';
      if (type === 'success') {
        toast.classList.add('success');
      } else if (type === 'error') {
        toast.classList.add('error');
      } else if (type === 'loading') {
        toast.classList.add('loading');
      }
      
      // Show toast
      setTimeout(() => {
        toast.classList.add('show');
      }, 10);
      
      // Hide toast after 2 seconds
      toastTimer = setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
          iconEl.innerHTML = '';
          messageEl.textContent = '';
          toastTimer = null;
        }, 300);
      }, 2000);
    }

    function showToastWithAction(message, actionText, actionCallback) {
      // 最小化状态下不显示 toast
      if (isMinimized) return;
      
      const toast = document.getElementById('toast');
      if (!toast) return;
      
      const iconEl = toast.querySelector('.toast-icon');
      const messageEl = toast.querySelector('.toast-message');
      
      if (!iconEl || !messageEl) return;
      
      // Validate parameters
      if (!message || !actionText) {
        console.error('showToastWithAction: message or actionText is missing');
        return;
      }
      
      // ✅ 清除旧的定时器，避免冲突
      if (toastTimer) {
        clearTimeout(toastTimer);
        toastTimer = null;
      }
      
      // ✅ 如果当前有显示的 toast，先立即隐藏
      if (toast.classList.contains('show')) {
        toast.classList.remove('show');
        setTimeout(() => {
          displayToastWithAction(toast, iconEl, messageEl, message, actionText, actionCallback);
        }, 300);
      } else {
        displayToastWithAction(toast, iconEl, messageEl, message, actionText, actionCallback);
      }
    }
    
    // ✅ 实际显示带操作的 toast 的函数（内部使用）
    function displayToastWithAction(toast, iconEl, messageEl, message, actionText, actionCallback) {
      // Set success icon
      iconEl.innerHTML = getToastIcon('success');
      iconEl.style.display = 'flex';
      
      // Create message with action link
      messageEl.innerHTML = `${message} <span class="toast-action">${actionText}</span>`;
      
      // Add click handler to action link
      const actionLink = messageEl.querySelector('.toast-action');
      if (actionLink && actionCallback) {
        actionLink.onclick = (e) => {
          e.stopPropagation();
          actionCallback();
        };
      }
      
      // Set toast class
      toast.className = 'toast success';
      
      // Show toast
      setTimeout(() => {
        toast.classList.add('show');
      }, 10);
      
      // Hide toast after 3 seconds (longer for action)
      toastTimer = setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
          iconEl.innerHTML = '';
          messageEl.innerHTML = '';
          toastTimer = null;
        }, 300);
      }, 3000);
    }

    function closeSettings() {
      // Reset all inputs and toggles to original saved values
      // This discards any unsaved changes
      if (imageWidthInput) imageWidthInput.value = originalSettings.imageWidth || '';
      if (imageHeightInput) imageHeightInput.value = originalSettings.imageHeight || '';
      if (frameColumnsInput) frameColumnsInput.value = originalSettings.frameColumns || '';
      
      // Reset Backup Mode Select
      if (backupModeSelect) {
        backupModeSelect.value = originalSettings.backupMode || 'none';
        if (typeof adjustSelectWidth === 'function') {
          adjustSelectWidth(backupModeSelect);
        }
      }
      
      const gifBackupToggle = document.getElementById('gifBackupToggle');
      if (gifBackupToggle) gifBackupToggle.checked = originalSettings.backupGif || false;
      
      const keepGifInIcloudToggle = document.getElementById('keepGifInIcloudToggle');
      if (keepGifInIcloudToggle) keepGifInIcloudToggle.checked = originalSettings.keepGifInIcloud || false;
      
      // Reset change detection
      checkSettingsChanges();
      
      settingsOverlay.classList.remove('show');
    }

    function updateSyncModeDisplay() {
      const driveBtn = document.getElementById('switchToDrive');
      const aliyunBtn = document.getElementById('switchToAliyun');
      const icloudBtn = document.getElementById('switchToIcloud');
      
      if (driveBtn) driveBtn.style.display = (typeof ENABLE_GOOGLE_DRIVE !== 'undefined' && ENABLE_GOOGLE_DRIVE) ? 'flex' : 'none';
      
      const showGoogleDrive = (currentSyncMode === 'drive' && typeof ENABLE_GOOGLE_DRIVE !== 'undefined' && ENABLE_GOOGLE_DRIVE);
      const qrGoogleScreenshotContainer = document.getElementById('qrGoogleScreenshotContainer');
      const qrGoogleAlbumContainer = document.getElementById('qrGoogleAlbumContainer');
      const googleDriveHint = document.getElementById('googleDriveHint');

      if (qrGoogleScreenshotContainer) qrGoogleScreenshotContainer.style.display = showGoogleDrive ? 'flex' : 'none';
      if (qrGoogleAlbumContainer) qrGoogleAlbumContainer.style.display = showGoogleDrive ? 'flex' : 'none';
      // if (googleDriveHint) googleDriveHint.style.display = showGoogleDrive ? 'block' : 'none';
      
      if (aliyunBtn) aliyunBtn.style.display = (typeof ENABLE_ALIYUN !== 'undefined' && ENABLE_ALIYUN) ? 'flex' : 'none';
      
      // Use box-shadow for selected state instead of border color for better visibility on cards
      if (driveBtn) {
          driveBtn.style.borderColor = (currentSyncMode === 'drive') ? 'var(--accent)' : 'var(--border)';
          driveBtn.style.background = (currentSyncMode === 'drive') ? 'var(--bg-card-hover)' : 'var(--bg-card)';
          if (currentSyncMode === 'drive') driveBtn.classList.add('selected');
          else driveBtn.classList.remove('selected');
      }
      if (aliyunBtn) {
          aliyunBtn.style.borderColor = (currentSyncMode === 'aliyun' || currentSyncMode === 'oss') ? 'var(--accent)' : 'var(--border)';
          aliyunBtn.style.background = (currentSyncMode === 'aliyun' || currentSyncMode === 'oss') ? 'var(--bg-card-hover)' : 'var(--bg-card)';
          if (currentSyncMode === 'aliyun' || currentSyncMode === 'oss') aliyunBtn.classList.add('selected');
          else aliyunBtn.classList.remove('selected');
      }
      if (icloudBtn) {
          icloudBtn.style.borderColor = (currentSyncMode === 'icloud') ? 'var(--accent)' : 'var(--border)';
          icloudBtn.style.background = (currentSyncMode === 'icloud') ? 'var(--bg-card-hover)' : 'var(--bg-card)';
          if (currentSyncMode === 'icloud') icloudBtn.classList.add('selected');
          else icloudBtn.classList.remove('selected');
      }
    }

    settingsClose.onclick = closeSettings;
    settingsOverlay.addEventListener('click', function (e) {
      if (e.target === settingsOverlay) closeSettings();
    });
    document.addEventListener('keydown', function (e) {
      if (e.key === 'Escape' && settingsOverlay.classList.contains('show')) {
        closeSettings();
      }
    });

    if (switchToDrive) {
      switchToDrive.onclick = function () {
        if (!ENABLE_GOOGLE_DRIVE) return;
        if (currentSyncMode === 'drive') return;
        
        showToast('正在切换', 'loading');
        if (ws && ws.readyState === 1) {
          ws.send(JSON.stringify({ type: 'switch-sync-mode', mode: 'drive' }));
        }
      };
    }

    if (switchToAliyun) {
      switchToAliyun.onclick = function () {
        if (typeof ENABLE_ALIYUN !== 'undefined' && !ENABLE_ALIYUN) return;
        if (currentSyncMode === 'aliyun') return;

        showToast('正在切换', 'loading');
        if (ws && ws.readyState === 1) {
          ws.send(JSON.stringify({ type: 'switch-sync-mode', mode: 'aliyun' }));
        }
      };
    }

    switchToIcloud.onclick = function () {
      if (currentSyncMode === 'icloud') return;
      showToast('正在切换', 'loading');
      if (ws && ws.readyState === 1) {
        ws.send(JSON.stringify({ type: 'switch-sync-mode', mode: 'icloud' }));
      }
    };

    function toggleMinimize() {
      isMinimized = !isMinimized;
      const currentIcon = document.getElementById('minimizeIcon');
      const updateBanner = document.getElementById('updateBanner');
      
      if (!currentIcon) return;
      
      if (isMinimized) {
        appRoot.classList.add('minimized');
        closeSettings(); // Use closeSettings to discard unsaved changes
        
        // 最小化时隐藏更新横幅
        // 检查 classList.contains('show') 因为这是主要的显示状态
        if (updateBanner && (updateBanner.classList.contains('show') || updateBanner.style.display === 'flex' || updateBanner.style.display === 'block')) {
          updateBanner.dataset.wasVisible = 'true';
          updateBanner.style.display = 'none';
        }
        
        // 最小化时隐藏所有 toast 提示
        const toast = document.getElementById('toast');
        if (toast) {
          toast.classList.remove('show');
          // 清除 toast 定时器
          if (toastTimer) {
            clearTimeout(toastTimer);
            toastTimer = null;
          }
          // 清空内容
          const iconEl = toast.querySelector('.toast-icon');
          const messageEl = toast.querySelector('.toast-message');
          if (iconEl) iconEl.innerHTML = '';
          if (messageEl) messageEl.innerHTML = '';
        }
        
        // Toggle icon path to Maximize (No slash)
        toggleMinimizeBtn.setAttribute('title', '恢复');
        toggleMinimizeBtn.classList.add('no-tooltip'); // 禁用最大化按钮的 tooltip
        currentIcon.innerHTML = '<polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline>';
        
        parent.postMessage({
          pluginMessage: { type: 'resize', width: 130, height: 44 }
        }, '*');
      } else {
        appRoot.classList.remove('minimized');
        
        let isBannerVisible = false;
        // 恢复时显示更新横幅
        if (updateBanner && updateBanner.dataset.wasVisible === 'true') {
          updateBanner.style.display = ''; // 清除内联样式，让 CSS .show 生效
          delete updateBanner.dataset.wasVisible;
          isBannerVisible = true;
        } else if (updateBanner && updateBanner.classList.contains('show')) {
          // 如果没有 wasVisible 标记但有 .show 类（可能是逻辑边缘情况），也认为是显示的
          isBannerVisible = true;
        }
        
        // Toggle icon path to Minimize
        toggleMinimizeBtn.setAttribute('title', '最小化');
        toggleMinimizeBtn.classList.remove('no-tooltip'); // 恢复最小化按钮的 tooltip
        currentIcon.innerHTML = '<polyline points="4 14 10 14 10 20"></polyline><polyline points="20 10 14 10 14 4"></polyline>';
        
        // 根据是否有 Banner 调整窗口高度
        const height = isBannerVisible ? 460 : 400;
        parent.postMessage({
          pluginMessage: { type: 'resize', width: 360, height: height }
        }, '*');
      }
    }

    toggleMinimizeBtn.onclick = toggleMinimize;
    
    // 更新通知条按钮事件
    const updateBannerCloseBtn = document.getElementById('updateBannerClose');
    const updateBannerNowBtn = document.getElementById('updateBannerNow');
    
    if (updateBannerCloseBtn) {
      updateBannerCloseBtn.onclick = function() {
        // 记录用户忽略的版本，避免重复提示同一版本
        if (pendingUpdateType === 'plugin' && latestPluginVersion) {
          dismissedPluginVersion = latestPluginVersion;
          console.log(`🔕 用户关闭了插件更新提示 v${latestPluginVersion}`);
        } else if (pendingUpdateType === 'server' && pendingUpdateData.latestVersion) {
          dismissedServerVersion = pendingUpdateData.latestVersion;
          console.log(`🔕 用户关闭了服务器更新提示 v${pendingUpdateData.latestVersion}`);
        }
        
        hideUpdateBanner();
      };
    }
    
    if (updateBannerNowBtn) {
      updateBannerNowBtn.onclick = function() {
        // 禁用按钮防止重复点击
        updateBannerNowBtn.disabled = true;
        updateBannerNowBtn.textContent = '更新中...';
        
        console.log('🔄 开始全量更新...');
        
        // 发送更新请求到服务器
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: 'update-full'
          }));
          console.log('   📤 已发送更新请求到服务器');
        } else {
          // WebSocket 未连接，显示错误
          console.error('❌ WebSocket 未连接，无法更新');
          showToast('服务器未连接，无法更新', 'error');
          updateBannerNowBtn.disabled = false;
          updateBannerNowBtn.textContent = '立即更新';
        }
      };
    }

    // ========================================
    // Upload GIF Modal Logic
    // ========================================
    let pendingUnsyncedGifs = []; // 待上传的 GIF 列表
    let selectedFiles = {}; // 用户选择的文件 { layerId: File }
    let uploadedGifs = new Set(); // 已上传成功的 layerId
    
    function showUploadGifModal(unsyncedGifs) {
      console.log('🔔 showUploadGifModal 被调用！');
      console.log('   未同步的 GIF/视频数量:', unsyncedGifs ? unsyncedGifs.length : 'undefined');
      
      pendingUnsyncedGifs = unsyncedGifs;
      selectedFiles = {};
      uploadedGifs = new Set();
      
      const overlay = document.getElementById('uploadGifOverlay');
      const subtitleContainer = document.getElementById('unsynced-gifs-subtitle');
      const multiFileInput = document.getElementById('multi-file-input');
      const dropzone = document.getElementById('upload-dropzone');
      const dropzoneText = document.getElementById('dropzone-text');
      
      // 填充副标题：通用提示
      subtitleContainer.innerHTML = `请手动选择 Frame 中包含的本地录屏文件`;
      
      // 重置拖拽区域状态
      resetDropzoneStyle();
      
      // 点击拖拽区域 -> 打开文件选择器
      dropzone.onclick = () => {
        multiFileInput.click();
      };
      
      // 拖拽进入
      dropzone.ondragenter = (e) => {
        e.preventDefault();
        e.stopPropagation();
        dropzone.style.border = '2px dashed var(--primary)';
        dropzone.style.background = 'var(--primary-bg)';
        dropzone.style.boxShadow = 'var(--pill-recessed-shadow)';
      };
      
      // 拖拽悬停
      dropzone.ondragover = (e) => {
        e.preventDefault();
        e.stopPropagation();
        // 保持悬停状态样式
        dropzone.style.border = '2px dashed var(--primary)';
        dropzone.style.background = 'var(--primary-bg)';
      };
      
      // 拖拽离开
      dropzone.ondragleave = (e) => {
        e.preventDefault();
        e.stopPropagation();
        resetDropzoneStyle();
      };
      
      // 拖拽放下
      dropzone.ondrop = async (e) => {
        e.preventDefault();
        e.stopPropagation();
        resetDropzoneStyle();
        
        const files = Array.from(e.dataTransfer.files).filter(file => {
          const ext = file.name.toLowerCase().split('.').pop();
          return ['gif', 'mov', 'mp4'].includes(ext);
        });
        
        if (files.length === 0) {
          showToast('请拖入 .gif .mov .mp4 格式的文件', 'warning');
          return;
        }
        
        console.log(`📁 用户拖入了 ${files.length} 个文件，开始匹配并上传...`);
        await matchAndUploadFiles(files, unsyncedGifs);
      };
      
      // 重置拖拽区域样式（和 status pill 保持一致）
      function resetDropzoneStyle() {
        dropzone.style.border = 'none';
        dropzone.style.background = 'var(--pill-recessed-bg)';
        dropzone.style.boxShadow = 'var(--pill-recessed-shadow)';
      }
      
      // 选择文件后立即开始上传
      multiFileInput.onchange = async (e) => {
        const files = Array.from(e.target.files);
        if (files.length === 0) return;
        
        console.log(`📁 用户选择了 ${files.length} 个文件，开始匹配并上传...`);
        
        // 自动匹配并立即上传
        await matchAndUploadFiles(files, unsyncedGifs);
      };
      
      // 绑定关闭按钮
      const closeBtn = document.getElementById('uploadGifClose');
      if (closeBtn) {
        closeBtn.onclick = () => {
          overlay.classList.remove('show');
          overlay.classList.add('hidden');
          setTimeout(() => {
            overlay.style.display = 'none';
          }, 250);
          pendingUnsyncedGifs = [];
          selectedFiles = {};
          uploadedGifs = new Set();
        };
      }
      
      // 显示模态框
      overlay.style.display = 'flex';
      overlay.classList.add('show');
      overlay.classList.remove('hidden');
      console.log('   ✅ 模态框已显示');
    }
    
    // 匹配并自动上传文件
    async function matchAndUploadFiles(files, unsyncedGifs) {
      const progressContainer = document.getElementById('upload-progress-container');
      const progressText = document.getElementById('upload-progress-text');
      const progressBar = document.getElementById('upload-progress-bar');
      const dropzone = document.getElementById('upload-dropzone');
      
      // 显示进度，隐藏拖拽区域
      if (dropzone) dropzone.style.display = 'none';
      if (progressContainer) progressContainer.style.display = 'block';
      
      // 立即设置初始进度，避免显示空的进度条
      if (progressBar) {
        progressBar.style.width = '0%';
        // 强制重绘后再设置初始进度
        progressBar.offsetHeight;
        progressBar.style.width = '5%';
      }
      if (progressText) progressText.textContent = '上传中...';
      
      try {
        // 匹配文件到图层
        console.log('🔍 开始匹配文件...');
        selectedFiles = {};
        
        unsyncedGifs.forEach(gif => {
          const layerName = gif.layerName;
          const originalFilename = gif.filename || gif.layerName; // 使用原始文件名或图层名
          
          const matchedFile = files.find(file => {
            const fileName = file.name.replace(/\.(gif|mov|mp4)$/i, '');
            
            // 清理图层名和原始文件名（去掉扩展名）
            const layerNameClean = layerName.replace(/\.(gif|mov|mp4)$/i, '').replace(/\s+/g, '-').toLowerCase();
            const originalFilenameClean = originalFilename.replace(/\.(gif|mov|mp4)$/i, '').replace(/\s+/g, '-').toLowerCase();
            const fileNameClean = fileName.replace(/\s+/g, '-').toLowerCase();
            
            // 1. 精确匹配（原始文件名或图层名）
            if (fileNameClean === originalFilenameClean || fileNameClean === layerNameClean) return true;
            
            // 2. 包含匹配
            if (fileNameClean.includes(originalFilenameClean) || originalFilenameClean.includes(fileNameClean)) return true;
            if (fileNameClean.includes(layerNameClean) || layerNameClean.includes(fileNameClean)) return true;
            
            // 3. 宽松匹配（去除所有特殊字符）
            const originalSimple = originalFilenameClean.replace(/[^a-z0-9]/g, '');
            const layerSimple = layerNameClean.replace(/[^a-z0-9]/g, '');
            const fileSimple = fileNameClean.replace(/[^a-z0-9]/g, '');
            
            if (originalSimple && fileSimple && originalSimple.length > 2 && 
                (originalSimple === fileSimple || fileSimple.includes(originalSimple) || originalSimple.includes(fileSimple))) {
              return true;
            }
            
            if (layerSimple && fileSimple && layerSimple.length > 2 && 
                (layerSimple === fileSimple || fileSimple.includes(layerSimple) || layerSimple.includes(fileSimple))) {
              return true;
            }
            
            return false;
          });
          
          if (matchedFile) {
            selectedFiles[gif.layerId] = matchedFile;
            console.log(`   ✅ 匹配: ${originalFilename} (图层: ${layerName}) <- ${matchedFile.name}`);
          } else {
            console.log(`   ❌ 未匹配: ${originalFilename} (图层: ${layerName})`);
          }
        });
        
        const matchedGifs = unsyncedGifs.filter(gif => selectedFiles[gif.layerId]);
        const totalToUpload = matchedGifs.length;
        
        if (totalToUpload === 0) {
          showToast('未能匹配任何文件，请检查文件名是否包含在图层名中', 'warning');
          // 恢复拖拽区域
          if (dropzone) dropzone.style.display = 'flex';
          if (progressContainer) progressContainer.style.display = 'none';
          return;
        }
        
        console.log(`🚀 开始上传 ${totalToUpload} 个文件...`);
        
        // 匹配完成，更新进度
        if (progressBar) progressBar.style.width = '15%';
        
        // 开始上传
        for (let i = 0; i < totalToUpload; i++) {
          const gif = matchedGifs[i];
          const file = selectedFiles[gif.layerId];
          
          // 更新进度条（从20%开始，到90%，留出空间给最后的100%动画）
          const percent = (20 + ((i + 1) / totalToUpload) * 70).toFixed(0);
          if (progressBar) progressBar.style.width = `${percent}%`;
          
          // 读取文件内容为 Base64
          const base64Data = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result.split(',')[1]);
            reader.onerror = reject;
            reader.readAsDataURL(file);
          });
          
          // 发送上传请求
          const uploadResult = await uploadGifToCloud(file.name, base64Data, gif.layerId);
          
          if (uploadResult.success) {
            uploadedGifs.add(gif.layerId);
            
            parent.postMessage({
              pluginMessage: {
                type: 'associate-uploaded-gif',
                layerId: gif.layerId,
                driveFileId: uploadResult.driveFileId,
                ossFileId: uploadResult.ossFileId,
                // ✅ 必须使用服务器返回的文件名 (originalFilename)，而不是 file.name (本地文件名)
                originalFilename: uploadResult.originalFilename || file.name,
                imageHash: uploadResult.imageHash,
                // ✅ 新增: 传递生成的 gifCacheId
                gifCacheId: uploadResult.gifCacheId
              }
            }, '*');
            
            console.log(`   ✅ 已上传: ${file.name}`);
          } else {
            throw new Error(`上传失败: ${uploadResult.error}`);
          }
        }
        
        // 确保进度条显示 100%
        if (progressBar) progressBar.style.width = '100%';
        if (progressText) progressText.textContent = '上传完成';
        
        // 等待进度条动画完成，让用户看到100%的效果
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // 检查上传文件大小，如果较大给出优化提示
        const totalUploadSize = matchedGifs.reduce((sum, gif) => {
          return sum + (selectedFiles[gif.layerId] ? selectedFiles[gif.layerId].size : 0);
        }, 0);
        const totalUploadSizeMB = (totalUploadSize / 1024 / 1024).toFixed(1);
        
        if (totalUploadSize > 10 * 1024 * 1024) {
          // 大于 10MB，显示优化提示
          console.log(`💡 上传了 ${totalUploadSizeMB}MB 的文件`);
          console.log(`💡 提示：下次可以将录屏文件直接放入 ScreenSyncImg 文件夹，无需手动上传，导出会更快！`);
        }
        
        showToast('文件上传成功，继续导出', 'success');
        
        console.log('   ⏰ 准备关闭弹窗并重试...');
        
        setTimeout(() => {
          try {
            console.log('   🔒 关闭弹窗...');
            const overlay = document.getElementById('uploadGifOverlay');
            if (overlay) {
              overlay.classList.remove('show');
              overlay.classList.add('hidden');
              setTimeout(() => {
                overlay.style.display = 'none';
              }, 300);
            }
            
            console.log('   🔄 发送 export-annotated-gif...');
            parent.postMessage({
              pluginMessage: { type: 'export-annotated-gif' }
            }, '*');
          } catch (e) {
            console.error('   ❌ 关闭弹窗逻辑出错:', e);
            // 强制尝试关闭
            const overlay = document.getElementById('uploadGifOverlay');
            if (overlay) overlay.style.display = 'none';
            
            // 即使出错也要尝试触发导出
            parent.postMessage({
              pluginMessage: { type: 'export-annotated-gif' }
            }, '*');
          }
        }, 1000);
        
      } catch (error) {
        console.error('❌ 上传失败:', error);
        showToast('上传失败: ' + error.message, 'error');
        
        // 恢复拖拽区域
        if (dropzone) dropzone.style.display = 'flex';
        if (progressContainer) progressContainer.style.display = 'none';
      }
    }
    
    // 上传 GIF 到云端的辅助函数
    function uploadGifToCloud(filename, base64Data, layerId, progressCallback) {
      return new Promise((resolve, reject) => {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          reject(new Error('WebSocket 未连接'));
          return;
        }
        
        const messageId = `upload-${layerId}-${Date.now()}`;
        
        console.log(`   🚀 开始上传: ${filename}`);
        
        // 监听上传结果
        const uploadListener = function(event) {
          const data = JSON.parse(event.data);
          if (data.type === 'upload-gif-result' && data.messageId === messageId) {
            ws.removeEventListener('message', uploadListener);
            if (data.success) {
              console.log(`   ✅ 上传成功: ${filename}`);
              resolve({
                success: true,
                driveFileId: data.driveFileId,
                ossFileId: data.ossFileId,
                imageHash: data.imageHash,
                gifCacheId: data.gifCacheId, // ✅ 新增
                originalFilename: data.originalFilename // ✅ 新增
              });
            } else {
              reject(new Error(data.error || '上传失败'));
            }
          }
        };
        
        ws.addEventListener('message', uploadListener);
        
        // 通知正在发送
        if (progressCallback) progressCallback('sending');
        
        const uploadStartTime = Date.now();
        
        // 发送上传请求（使用 Base64 编码，速度快很多）
        console.log(`   📡 正在通过 WebSocket 传输数据 (Base64)...`);
        ws.send(JSON.stringify({
          type: 'upload-local-gif',
          messageId: messageId,
          filename: filename,
          base64: base64Data,
          layerId: layerId
        }));
        
        // 发送完成后通知服务器处理中
        const sendDuration = Date.now() - uploadStartTime;
        console.log(`   ✅ 数据传输完成 (${(sendDuration / 1000).toFixed(1)}秒)，等待服务器处理...`);
        if (progressCallback) progressCallback('processing');
        
        // 120 秒超时（给大文件更多时间）
        setTimeout(() => {
          ws.removeEventListener('message', uploadListener);
          reject(new Error('上传超时（120秒）'));
        }, 120000);
      });
    }
    window.onmessage = function (event) {
      // 🛡️ 安全处理消息，防止错误导致插件崩溃
      try {
        var msg = event.data && event.data.pluginMessage;
        if (!msg) return;

        if (msg.type === 'plugin-closing') {
          stopRealtimeSync();
        } else if (msg.type === 'request-skipped-file-cache' || msg.type === 'request-skipped-file-cache-for-node') {
        // ✅ code.js 请求获取跳过文件的缓存信息（用于自动关联手动拖入的Video/GIF）
        const isForNode = msg.type === 'request-skipped-file-cache-for-node';
        console.log(`📤 UI 收到缓存请求${isForNode ? '(自动关联)' : ''}，文件名:`, msg.filename);
        
        if (!msg.filename) {
          console.warn('⚠️  文件名为空，无法查找缓存');
          return;
        }
        
        // 直接匹配
        let cacheData = skippedFileCache.get(msg.filename);
        
        // 如果直接匹配失败，尝试模糊匹配（去除扩展名，忽略大小写和空格）
        if (!cacheData) {
          // ✅ 增强：先去除 Figma 可能添加的数字后缀 (如 "Name 1", "Name 2")
          // 例如: "Video 1.mov" -> "Video", "Video 1" -> "Video"
          let nameClean = msg.filename.replace(/\.[^/.]+$/, ''); // 去后缀
          nameClean = nameClean.replace(/\s\d+$/, ''); // 去尾部数字
          
          const normalize = (str) => str.toLowerCase().replace(/\.[^/.]+$/, '').replace(/\s+/g, '');
          const targetName = normalize(nameClean);
          
          for (const [key, value] of skippedFileCache.entries()) {
            const cacheName = normalize(key);
            // 1. 完全匹配（去后缀去空格）
            if (cacheName === targetName) {
              cacheData = value;
              console.log(`   ✨ 模糊匹配成功(Level 1): ${key} -> ${msg.filename}`);
              break;
            }
            // 2. 包含匹配（如果节点名包含文件名，或者文件名包含节点名）
            // 例如：节点名 "IMG_1234 (1)"，文件名 "IMG_1234"
            if (targetName.includes(cacheName) || cacheName.includes(targetName)) {
               // 只有当长度差异不大时才认为是匹配（防止误判）
               if (Math.abs(targetName.length - cacheName.length) < 5) {
                 cacheData = value;
                 console.log(`   ✨ 模糊匹配成功(Level 2): ${key} -> ${msg.filename}`);
                 break;
               }
            }
          }
        }
        
        if (cacheData) {
          console.log('   ✅ 找到缓存数据:', cacheData);
          const response = {
            type: 'skipped-file-cache-response',
            filename: msg.filename,
            cacheData: cacheData
          };
          
          // 如果是自动关联请求，需要传递nodeId
          if (isForNode && msg.nodeId) {
            response.nodeId = msg.nodeId;
            console.log('   🔗 包含nodeId，将自动关联到节点:', msg.nodeId);
          }
          
          parent.postMessage({
            pluginMessage: response
          }, '*');
        } else {
          console.log('   ⚠️  未找到缓存数据');
          
          // ✅ 关键优化：如果 UI 缓存没找到，且是自动关联请求，尝试向 Server 请求检查
          // 这能解决用户重启插件后拖入文件，自动关联失效的问题
          if (isForNode && msg.nodeId && ws && ws.readyState === WebSocket.OPEN) {
             console.log('   🔄 尝试向 Server 请求缓存检查 (Server-Side Fallback)...');
             ws.send(JSON.stringify({
                type: 'check-cache-existence',
                files: [{
                   filename: msg.filename,
                   layerId: msg.nodeId
                }]
             }));
          }
        }
      } else if (msg.type === 'export-batch-start') {
        // Start export flow
        totalExports = msg.total || 0;
        completedExports = 0;
        isExporting = true;
        isCancellingExport = false; // ✅ 重置取消标志

        console.log('🎬 开始批量导出，总数:', totalExports);
        console.log('🔍 检查元素状态:', {
            exportGifBtn: !!exportGifBtn,
            progressRing: !!progressRing,
            progressCircle: !!progressCircle
        });
        
        // Add exporting class to button
        if (exportGifBtn) {
          exportGifBtn.classList.add("exporting");
          exportGifBtn.classList.remove("success");
          // 修改 tooltip 为停止导出
          exportGifBtn.setAttribute('data-tooltip', '停止导出 GIF');
          console.log('✅ 已添加 exporting class');
        } else {
          console.warn('⚠️ exportGifBtn 未找到');
        }
        
        if (totalExports > 0) {
          console.log('🚀 启动 smooth progress...');
          startSmoothProgress(); // Start smooth progress animation
        } else {
          console.warn('⚠️ totalExports 为 0 或 undefined');
        }
        
        // Reset button state
        const exportBtn = document.getElementById('exportGifBtn');
        if (exportBtn) {
            exportBtn.classList.remove('success');
        }
      } else if (msg.type === 'export-gif-error') {
        showToast(msg.error, 'error');
        // Reset button state
        stopSmoothProgress();
        const exportBtn = document.getElementById('exportGifBtn');
        if (exportBtn) {
            exportBtn.classList.remove('success');
            const ring = exportBtn.querySelector('.progress-ring');
            if (ring) ring.style.opacity = 0;
        }
        isExporting = false;
      } else if (msg.type === 'export-gif-cancelled') {
        // ✅ 处理 code.js 发来的取消确认消息
        // cancelExport() 已经显示了 toast 和重置了状态，这里只需确保 isExporting 被重置
        console.log('🛑 收到 code.js 取消确认');
        stopSmoothProgress();
        const exportBtn = document.getElementById('exportGifBtn');
        if (exportBtn) {
            exportBtn.classList.remove('exporting');
            exportBtn.classList.remove('success');
            exportBtn.setAttribute('data-tooltip', '导出 GIF');
            const ring = exportBtn.querySelector('.progress-ring');
            if (ring) ring.style.opacity = 0;
        }
        isExporting = false;
      } else if (msg.type === 'request-upload-gifs') {
        // 请求用户上传未同步的 GIF
        console.log('🔔 检测到未同步的 GIF:', msg.unsyncedGifs);
        showUploadGifModal(msg.unsyncedGifs);
      } else if (msg.type === 'associate-gif-success') {
        console.log('✅ GIF 数据关联成功:', msg.layerId);
        // 这个消息会由 showUploadGifModal 处理
      } else if (msg.type === 'associate-gif-error') {
        console.error('❌ GIF 数据关联失败:', msg.layerId, msg.error);
        showToast('GIF 数据关联失败: ' + msg.error, 'error');
      } else if (msg.type === 'trigger-export-from-code') {
        // code.js 请求重新触发导出（清除数据后）
        console.log('🔄 收到 code.js 的重新导出请求，触发导出流程...');
        parent.postMessage({
          pluginMessage: { 
            type: 'export-annotated-gif',
            skipServerCheck: msg.skipServerCheck || false
          }
        }, '*');
      } else if (msg.type === 'check-server-cache-for-unsynced') {
        // ✅ 转发检查请求给 Server
        if (ws && ws.readyState === WebSocket.OPEN) {
          console.log('📤 发送缓存检查请求到 Server');
          pendingExportCacheCheck = true; // ✅ 标记这是导出流程的缓存检查
          ws.send(JSON.stringify({
            type: 'check-cache-existence',
            files: msg.unsyncedGifs.map(g => ({
              filename: g.filename,
              layerId: g.layerId
            }))
          }));
        } else {
          console.warn('⚠️ WebSocket 未连接，无法检查缓存，直接请求上传');
          // 回退到请求上传
          parent.postMessage({
            pluginMessage: { 
              type: 'request-upload-gifs',
              unsyncedGifs: msg.unsyncedGifs
            }
          }, '*');
        }
      } else if (msg.type === 'compose-annotated-gif') {
        // Forward message to server
        console.log('📨 UI 收到 compose-annotated-gif 消息');
        // 深度检查 gifInfos
        if (msg.gifInfos && msg.gifInfos.length > 0) {
           console.log('   🔍 UI 检查第一个 GIF 的 imageFillInfo:', JSON.stringify(msg.gifInfos[0].imageFillInfo));
        }
        console.log('   Frame名称:', msg.frameName);
        console.log('   GIF数量:', msg.gifInfos ? msg.gifInfos.length : 0);
        if (msg.gifInfos) {
          msg.gifInfos.forEach((gif, idx) => {
            console.log(`      ${idx + 1}. ${gif.filename} @ (${gif.bounds.x}, ${gif.bounds.y})`);
          });
        }
        console.log('   批次:', `${msg.batchIndex + 1}/${msg.batchTotal}`);
        // 🔍 检查 bottomLayerBytes
        console.log('   🔍 bottomLayerBytes 是否存在:', !!msg.bottomLayerBytes);
        if (msg.bottomLayerBytes) {
          console.log('   🔍 bottomLayerBytes 长度:', msg.bottomLayerBytes.length);
        } else {
          console.log('   ⚠️  bottomLayerBytes 为空或不存在！');
        }
        
        // 🔍 检查 middleLayerBytes
        console.log('   🔍 middleLayerBytes 是否存在:', !!msg.middleLayerBytes);
        if (msg.middleLayerBytes) {
          console.log('   🔍 middleLayerBytes 长度:', msg.middleLayerBytes.length);
        } else {
          console.log('   ⚠️  middleLayerBytes 为空或不存在！');
        }
        
        console.log('   WebSocket状态:', ws ? ws.readyState : 'ws is null');
        
        if (ws && ws.readyState === WebSocket.OPEN) {
          console.log('   ✅ WebSocket已连接，发送消息到服务器');
          ws.send(JSON.stringify(msg));
          console.log('   ✅ 消息已发送');
        } else {
          console.error('   ❌ WebSocket未连接，无法发送消息');
          showToast('未连接到服务器', 'error');
          // Reset button state
          const exportBtn = document.getElementById('exportGifBtn');
          if (exportBtn) {
              exportBtn.classList.remove('success');
              const ring = exportBtn.querySelector('.progress-ring');
              if (ring) ring.style.opacity = 0;
          }
          isExporting = false;
          stopSmoothProgress();
        }
      } else if (msg.type === 'frame-created') {
        log('✅ 画板已创建');
      } else if (msg.type === 'frame-located') {
        if (msg.success) log('📍 ' + msg.message);
        else log('❌ ' + msg.message);
      } else if (msg.type === 'screenshot-added') {
        if (msg.success) {
          screenshotCount++;
          document.getElementById('count').textContent = screenshotCount;
          
          if (ws && ws.readyState === WebSocket.OPEN) {
            // 优先使用 plugin 返回的 ID
            const driveFileId = msg.driveFileId || (currentFileIdType === 'drive' ? currentFileId : null);
            const ossFileId = msg.ossFileId || (currentFileIdType === 'oss' ? currentFileId : null);
            
            if (driveFileId || ossFileId) {
              try {
                const confirmMessage = {
                  type: 'screenshot-received',
                  filename: msg.filename || '未命名文件',
                  timestamp: Date.now()
                };
                if (ossFileId) confirmMessage.ossFileId = ossFileId;
                if (driveFileId) confirmMessage.driveFileId = driveFileId;
                
                ws.send(JSON.stringify(confirmMessage));
                
                if (!msg.driveFileId && !msg.ossFileId) {
                currentFileId = null;
                currentFileIdType = null;
                }
              } catch (error) {
                console.error('❌ 发送确认失败:', error);
              }
            }
          }
        } else {
          log('❌ 添加失败: ' + (msg.error || '未知错误'));
          
          // 如果添加失败，但已经备份到本地，也发送确认以删除云端文件
          if (currentFileBackedUp) {
            log('⚠️  导入 Figma 失败，但文件已备份到本地，确认删除云端文件');
            showToast('Figma 导入失败，已保存到本地', 'warning');
            
            if (ws && ws.readyState === WebSocket.OPEN) {
              // 优先使用 plugin 返回的 ID
              const driveFileId = msg.driveFileId || (currentFileIdType === 'drive' ? currentFileId : null);
              const ossFileId = msg.ossFileId || (currentFileIdType === 'oss' ? currentFileId : null);
              
              if (driveFileId || ossFileId) {
                try {
                  const confirmMessage = {
                    type: 'screenshot-received',
                    filename: msg.filename || '未命名文件',
                    timestamp: Date.now()
                  };
                  if (ossFileId) confirmMessage.ossFileId = ossFileId;
                  if (driveFileId) confirmMessage.driveFileId = driveFileId;
                  
                  ws.send(JSON.stringify(confirmMessage));
                  
                  // Reset
                  if (!msg.driveFileId && !msg.ossFileId) {
                  currentFileId = null;
                  currentFileIdType = null;
                  }
                  currentFileBackedUp = false;
                } catch (error) {
                  console.error('❌ 发送确认失败:', error);
                }
              }
            }
          }
        }
      } else if (msg.type === 'file-needs-manual-drag') {
        manualDragCount++;
        // Don't reset state - let currentButtonState handle locking
        const reasonText = msg.reason === 'undefined-error' ? '导入失败' : '未知原因';
        log(`⚠️  ${msg.filename} 需手动导入`);
        
        if (ws && ws.readyState === WebSocket.OPEN) {
          try {
            const failMessage = {
              type: 'screenshot-failed',
              filename: msg.filename,
              error: msg.error || 'undefined错误',
               keepFile: true
            };
            
            const driveFileId = msg.driveFileId || (currentFileIdType === 'drive' ? currentFileId : null);
            const ossFileId = msg.ossFileId || (currentFileIdType === 'oss' ? currentFileId : null);
            
            if (ossFileId) failMessage.ossFileId = ossFileId;
            if (driveFileId) failMessage.driveFileId = driveFileId;
            
            ws.send(JSON.stringify(failMessage));
            
            if (!msg.driveFileId && !msg.ossFileId) {
            currentFileId = null;
            currentFileIdType = null;
            }
          } catch (error) {
            console.error('发送失败消息失败:', error);
          }
        }
        updateStatus('connected', '');
      } else if (msg.type === 'size-settings-loaded') {
        if (msg.width) imageWidthInput.value = msg.width;
        if (msg.height) imageHeightInput.value = msg.height;
      } else if (msg.type === 'size-settings-updated') {
        // Toast now handled by unified saveAllSettings function
        // No individual toast needed to avoid duplicates
      } else if (msg.type === 'layout-settings-loaded') {
        if (msg.columns) frameColumnsInput.value = msg.columns;
      } else if (msg.type === 'layout-settings-updated') {
        // Toast now handled by unified saveAllSettings function
        // No individual toast needed to avoid duplicates
      } else if (msg.type === 'server-path-loaded') {
        if (msg.path) {
          serverInstallPath = msg.path;
          const pathEl = document.getElementById('server-path-placeholder');
          if (pathEl) {
            pathEl.textContent = serverInstallPath;
            pathEl.style.color = 'inherit';
            console.log('✅ 已加载保存的服务器路径:', serverInstallPath);
          }
        }
      } else if (msg.type === 'plugin-version-info') {
        // 获取插件版本信息
        handlePluginVersionInfo(msg);
      }
      } catch (error) {
        // 🛡️ 捕获所有错误，防止插件崩溃
        console.error('❌ window.onmessage 处理错误:', error);
      }
    };

    const logContainer = document.getElementById('logContainer');
    const logHeader = document.getElementById('logHeader');
    const logToggleText = document.getElementById('logToggleText');

    function collapseLog() {
      logContainer.classList.add('collapsed');
      logToggleText.textContent = '展开';
    }

    function expandLog() {
      logContainer.classList.remove('collapsed');
      logToggleText.textContent = '收起';
    }

    logHeader.addEventListener('click', function () {
      const isCollapsed = logContainer.classList.contains('collapsed');
      if (isCollapsed) expandLog();
      else collapseLog();
    });

    // ✅ 初始状态：显示"正在连接"，确保服务器未启动时界面正常加载
    updateStatus('waiting', '正在连接');

    // 使用 setTimeout 确保 connect() 异步执行，不阻塞界面渲染
    setTimeout(() => {
    connect();
    }, 0);
    
    loadServerPath(); // 加载保存的服务器路径
    // 请求当前插件版本
    parent.postMessage({ pluginMessage: { type: 'get-plugin-version' } }, '*');

    // // 临时显示 Update Banner 用于调整样式（开发调试用）
    // setTimeout(() => {
    //   const banner = document.getElementById('updateBanner');
    //   const text = document.getElementById('updateBannerText');
    //   if (banner && text) {
    //     text.textContent = '发现新版本 v1.0.2';
    //     banner.classList.add('show');
    //     console.log('🎨 临时显示 Update Banner 用于样式调整');
    //   }
    // }, 500);

    window.addEventListener('beforeunload', function () {
      stopRealtimeSync();
    });
    
    
    // Copy User ID Logic
    const copyUserIdBtn = document.getElementById('copyUserIdBtn');
    if (copyUserIdBtn) {
      copyUserIdBtn.onclick = function() {
        const userIdEl = document.getElementById('displayUserId');
        if (!userIdEl) return;
        
        const userId = userIdEl.textContent.trim();
        if (!userId || userId === '正在获取...') {
          showToast('User ID 尚未获取', 'error');
          return;
        }
        
        const textArea = document.createElement("textarea");
        textArea.value = userId;
        document.body.appendChild(textArea);
        textArea.select();
        try {
          document.execCommand('copy');
          showToast('User ID 已复制', 'success');
        } catch (err) {
          showToast('复制失败', 'error');
        }
        document.body.removeChild(textArea);
      };
    }
      // ==========================================
    // Export GIF Logic
    // ==========================================
    
    let totalExports = 0;
    let completedExports = 0;
    let isExporting = false;
    let isCancellingExport = false; // 标记是否正在取消导出（用于忽略取消后的错误消息）
    let pendingExportCacheCheck = false; // 标记是否有待处理的导出流程缓存检查
    let successTimer = null;
    let circumference = 0;
    let progressCircle = null;
    
    // Manual Sync Progress
    let totalManualSyncFiles = 0;
    let completedManualSyncFiles = 0;
    let isManualSyncing = false;
    let syncStarted = false; // ✅ 标记同步是否已经开始（收到了第一个响应）
    let manualSyncTimeoutId = null; // ✅ 保存超时 ID，以便清除
    
    // ✅ 导出超时检测
    let exportTimeoutId = null; // 导出超时计时器
    let lastProgressUpdate = 0; // 上次进度更新时间
    const EXPORT_STALL_TIMEOUT = 600000; // 10分钟无进度更新视为卡住
    let circumferenceManual = 0;
    let progressCircleManual = null;
    let progressRingManual = null;
    let progressRing = null;
    let exportGifBtn = null;
    let smoothProgressInterval = null;
    let currentSmoothProgress = 0;
    
    // 跟踪窗口焦点状态（用于判断是否显示 toast）
    let windowHasFocus = !document.hidden;
    
    // 监听窗口焦点和可见性变化
    window.addEventListener('focus', () => {
      windowHasFocus = true;
      console.log('🔍 窗口获得焦点');
    });
    
    window.addEventListener('blur', () => {
      windowHasFocus = false;
      console.log('🔍 窗口失去焦点');
    });
    
    document.addEventListener('visibilitychange', () => {
      windowHasFocus = !document.hidden;
      console.log('🔍 窗口可见性变化:', document.hidden ? '隐藏' : '可见');
    });

    // Initialize after DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
        // Check for Update Banner and adjust height immediately
        const updateBanner = document.getElementById('updateBanner');
        if (updateBanner && (updateBanner.classList.contains('show') || updateBanner.style.display === 'block' || updateBanner.style.display === 'flex')) {
            console.log('📏 Initial Resize: Banner visible, setting height to 460');
            parent.postMessage({
                pluginMessage: { type: 'resize', width: 360, height: 460 }
            }, '*');
        } else {
            // Ensure standard height
            console.log('📏 Initial Resize: Standard height 400');
            parent.postMessage({
                pluginMessage: { type: 'resize', width: 360, height: 400 }
            }, '*');
        }

        // 开发者模式：显示模式切换区域
        if (DEVELOPER_MODE) {
          const modeSwitchSection = document.getElementById('modeSwitchSection');
          if (modeSwitchSection) {
            modeSwitchSection.style.display = '';
            console.log('🔧 开发者模式已启用，模式切换区域已显示');
          }
        }
        
        exportGifBtn = document.getElementById("exportGifBtn");
        progressRing = exportGifBtn ? exportGifBtn.querySelector(".progress-ring") : null;
        progressCircle = exportGifBtn ? exportGifBtn.querySelector(".progress-ring__circle") : null;
        
        // Initialize Export GIF Progress Ring
        if (progressCircle) {
            const radius = progressCircle.r.baseVal.value;
            circumference = radius * 2 * Math.PI;
            console.log('🔵 Export GIF Progress Ring 初始化:', {
                radius,
                circumference,
                element: progressCircle
            });
            progressCircle.style.strokeDasharray = `${circumference} ${circumference}`;
            progressCircle.style.strokeDashoffset = circumference;
        } else {
            console.warn('⚠️ Export GIF Progress Circle 元素未找到');
        }
        
        // Initialize Manual Sync Progress Ring
        let manualSyncBtn = document.getElementById("manualSyncBtn");
        progressRingManual = manualSyncBtn ? manualSyncBtn.querySelector(".progress-ring-manual") : null;
        progressCircleManual = manualSyncBtn ? manualSyncBtn.querySelector(".progress-ring-manual .progress-ring__circle") : null;
        
        if (progressCircleManual) {
            const radius = progressCircleManual.r.baseVal.value;
            circumferenceManual = radius * 2 * Math.PI;
            console.log('🔵 Manual Sync Progress Ring 初始化:', {
                radius,
                circumference: circumferenceManual,
                element: progressCircleManual
            });
            progressCircleManual.style.strokeDasharray = `${circumferenceManual} ${circumferenceManual}`;
            progressCircleManual.style.strokeDashoffset = circumferenceManual;
        } else {
            console.warn('⚠️ Manual Sync Progress Circle 元素未找到');
        }

        // 手动同步按钮逻辑绑定
        if (manualSyncBtn) {
            manualSyncBtn.onclick = function() {
                // Check if already syncing
                if (isManualSyncing) {
                    console.log('⚠️ 同步正在进行中，请勿重复点击');
                    showToast('同步进行中...', 'loading');
                    return;
                }
                
                // Check connection
                if (!ws || ws.readyState !== WebSocket.OPEN) {
                    log('❌ 未连接');
                    updateStatus('disconnected', '点击重连');
                    return;
                }
                
                console.log('🔘 手动同步按钮点击');
                
                // ✅ 立即开始视觉反馈（无需等待）
                isManualSyncing = true;
                manualDragCount = 0;
                skippedFilesSet.clear();
                gifBackupCount = 0;
                
                // ✅ 显示旋转的进度条（无限循环动画）
                if (progressRingManual) {
                    const circle = progressCircleManual;
                    // 设置为无限旋转动画
                    circle.style.strokeDasharray = `${circumferenceManual * 0.25} ${circumferenceManual}`;
                    circle.style.strokeDashoffset = '0';
                    progressRingManual.style.opacity = 1;
                    progressRingManual.style.animation = 'rotate 1s linear infinite';
                }
                
                // ✅ Add syncing visual state
                manualSyncBtn.classList.add('exporting');
                manualSyncBtn.setAttribute('data-tooltip', '同步中...');
                
                // ✅ 重置同步开始标记
                syncStarted = false;
                
                log('🫳🏻 开始手动同步...');
                updateStatus('connected', '正在同步');
                
                // ✅ 清除之前的超时（如果有）
                if (manualSyncTimeoutId) {
                    clearTimeout(manualSyncTimeoutId);
                    manualSyncTimeoutId = null;
                }
                
                // ✅ 超时保护 (30秒内完全没反应才算超时)
                manualSyncTimeoutId = setTimeout(() => {
                    // 只有当同步尚未开始时才判断为超时
                    if (isManualSyncing && !syncStarted) {
                        console.warn('⚠️ 手动同步超时 (30s内无响应)');
                        isManualSyncing = false;
                        manualSyncBtn.classList.remove('exporting');
                        manualSyncBtn.setAttribute('data-tooltip', '手动同步');
                        if (progressRingManual) {
                            progressRingManual.style.opacity = 0;
                            progressRingManual.style.animation = '';
                        }
                        updateStatus('connected', '同步超时');
                        showToast('同步请求超时，请检查连接', 'error');
                        manualSyncTimeoutId = null;
                    } else if (isManualSyncing && syncStarted) {
                        // 已经开始同步但还没完成，不算超时，清除超时 ID
                        console.log('✅ 同步已开始，取消超时检查');
                        manualSyncTimeoutId = null;
                    }
                }, 30000);
                
                // ✅ 直接发送同步请求（立即响应）
                try {
                    console.log('📨 发送 manual-sync 消息...');
                    ws.send(JSON.stringify({ type: 'manual-sync' }));
                    console.log('📨 已发送手动同步请求');
                } catch (error) {
                    console.error('❌ 发送同步请求失败:', error);
                    isManualSyncing = false;
                    manualSyncBtn.classList.remove('exporting');
                    manualSyncBtn.setAttribute('data-tooltip', '手动同步');
                    if (progressRingManual) {
                        progressRingManual.style.opacity = 0;
                        progressRingManual.style.animation = '';
                    }
                    updateStatus('connected', '发送失败');
                    showToast('发送请求失败', 'error');
                }
            };
        }

        if (exportGifBtn) {
            exportGifBtn.onclick = () => {
                if (isExporting) {
                    // Cancel Export
                    console.log('🛑 用户取消导出');
                    cancelExport();
                } else {
                    // Start Export
                    parent.postMessage({ pluginMessage: { type: "export-annotated-gif" } }, "*");
                }
            };
        }
        
        // 主界面开始按钮
        const mainStartBtn = document.getElementById('mainStartBtn');
        if (mainStartBtn) {
            mainStartBtn.onclick = function() {
                // 防抖保护：防止用户狂点
                if (mainStartBtn.classList.contains('processing')) return;
                
                // 标记处理中
                mainStartBtn.classList.add('processing');
                setTimeout(() => mainStartBtn.classList.remove('processing'), 500); // 0.5s 防抖
                
                toggleRealtimeSync();
            };
        }
        
        // 自动进入实时模式
        setTimeout(() => {
            if (ws && ws.readyState === 1) {
                console.log('🚀 自动进入实时模式界面');
                showWorkArea('realtime');
            } else {
                console.log('⏳ 等待连接后自动进入实时模式界面');
            }
        }, 500);
    });

    function setExportProgress(percent) {
        // Re-check elements if null (just in case)
        if (!progressCircle || !progressRing) {
             exportGifBtn = document.getElementById("exportGifBtn");
             progressRing = exportGifBtn ? exportGifBtn.querySelector(".progress-ring") : null;
             progressCircle = exportGifBtn ? exportGifBtn.querySelector(".progress-ring__circle") : null;
             if (progressCircle && circumference === 0) {
                 const radius = progressCircle.r.baseVal.value;
                 circumference = radius * 2 * Math.PI;
                 progressCircle.style.strokeDasharray = `${circumference} ${circumference}`;
                 console.log('🔵 Progress Ring 重新初始化:', { radius, circumference });
             }
        }
        
        if (!progressCircle || !progressRing) {
            console.warn('⚠️ setExportProgress: 元素未找到', { progressCircle, progressRing });
            return;
        }
        
        const offset = circumference - (percent / 100) * circumference;
        progressCircle.style.strokeDashoffset = offset;
        progressRing.style.opacity = 1;
        
        console.log('📊 导出GIF进度更新:', {
            percent: percent.toFixed(1) + '%',
            circumference: circumference.toFixed(2),
            offset: offset.toFixed(2),
            ringOpacity: progressRing.style.opacity,
            hasExportingClass: exportGifBtn?.classList.contains('exporting')
        });
    }
    
    function setManualSyncProgress(percent) {
        // Re-check elements if null (just in case)
        if (!progressCircleManual || !progressRingManual) {
             const manualSyncBtn = document.getElementById("manualSyncBtn");
             progressRingManual = manualSyncBtn ? manualSyncBtn.querySelector(".progress-ring-manual") : null;
             progressCircleManual = manualSyncBtn ? manualSyncBtn.querySelector(".progress-ring-manual .progress-ring__circle") : null;
             if (progressCircleManual && circumferenceManual === 0) {
                 const radius = progressCircleManual.r.baseVal.value;
                 circumferenceManual = radius * 2 * Math.PI;
                 progressCircleManual.style.strokeDasharray = `${circumferenceManual} ${circumferenceManual}`;
                 console.log('🔵 Manual Sync Progress Ring 重新初始化:', { radius, circumference: circumferenceManual });
             }
        }
        
        if (!progressCircleManual || !progressRingManual) {
            console.warn('⚠️ setManualSyncProgress: 元素未找到', { progressCircleManual, progressRingManual });
            return;
        }
        
        const offset = circumferenceManual - (percent / 100) * circumferenceManual;
        progressCircleManual.style.strokeDashoffset = offset;
        progressRingManual.style.opacity = 1;
        
        console.log('📊 手动同步进度更新:', {
            percent: percent.toFixed(1) + '%',
            circumference: circumferenceManual.toFixed(2),
            offset: offset.toFixed(2),
            ringOpacity: progressRingManual.style.opacity
        });
    }

    // 更新真实进度
    function updateRealProgress(percent, message) {
        // ✅ 收到进度更新，重置卡住检测计时器
        resetExportStallDetection();
        
        // 如果有消息，可以更新状态文本（如果有状态显示区域的话）
        if (message) {
            console.log(`📊 进度 ${percent}%: ${message}`);
            // 可选：更新按钮文字显示当前状态
            if (exportGifBtn && !exportGifBtn.classList.contains('success')) {
               const btnText = exportGifBtn.querySelector('span');
               if (btnText) btnText.textContent = `导出中 ${percent}%`;
            }
        }

        // 基于当前批次进度的计算
        // 假设每个 GIF 的处理进度是独立的，这里我们主要关注当前的 percent
        // 但为了防止进度条倒退（当处理下一个 GIF 时），我们需要综合考虑
        
        // 简单策略：直接使用服务器返回的百分比作为当前目标
        // 但为了平滑，我们不直接 set，而是更新 target，让 smooth interval 去追赶
        
        // 实际上，服务器现在的进度是针对单个请求的。
        // 如果是批量导出，我们需要结合 completedExports 和 totalExports 来计算总进度
        // 总进度 = (已完成数量 * 100 + 当前正在处理的百分比) / 总数量
        
        let batchProgress = percent;
        if (totalExports > 1) {
            batchProgress = ((completedExports * 100) + percent) / totalExports;
        }
        
        // 确保进度不倒退
        if (batchProgress > currentSmoothProgress) {
             currentSmoothProgress = batchProgress;
             setExportProgress(currentSmoothProgress);
        }
    }

    // Smooth progress simulation for better UX
    // 现在主要作为"心跳"动画，防止用户以为卡死
    function startSmoothProgress() {
        console.log('🎯 startSmoothProgress 被调用');
        
        if (smoothProgressInterval) clearInterval(smoothProgressInterval);
        
        // 初始进度
        currentSmoothProgress = 2;
        lastProgressUpdate = Date.now(); // 记录开始时间
        console.log('📈 调用 setExportProgress(2)...');
        setExportProgress(currentSmoothProgress);
        
        if (exportGifBtn) {
           const btnText = exportGifBtn.querySelector('span');
           if (btnText) btnText.textContent = '准备中...';
        }
        
        // ✅ 启动导出超时检测
        startExportStallDetection();
        
        smoothProgressInterval = setInterval(() => {
            // 仅仅做极缓慢的增加，作为"我还在运行"的信号
            // 如果真实进度来了，currentSmoothProgress 会被 updateRealProgress 大幅更新
            
            // 如果卡在某个进度太久，最多自动爬升 5%
            // 比如当前是 30%，最多自动爬到 35%，然后等待服务器消息
            
            // 这里我们只做非常微小的蠕动，每 100ms 增加 0.05%
            // 这样 1秒增加 0.5%，1分钟增加 30%
            // 并在 95% 处封顶
            
            if (currentSmoothProgress < 95) {
                currentSmoothProgress += 0.05;
                setExportProgress(currentSmoothProgress);
            }
            
        }, 100); 
    }
    
    // ✅ 导出卡住检测
    function startExportStallDetection() {
        // 清除之前的超时（如果有）
        if (exportTimeoutId) {
            clearTimeout(exportTimeoutId);
            exportTimeoutId = null;
        }
        
        // 设置新的超时检测
        exportTimeoutId = setTimeout(() => {
            // 检查是否还在导出中
            if (isExporting) {
                console.warn('⚠️  检测到导出超时（进度停滞超过 10 分钟）');
                
                // ✅ 设置取消标志，忽略后续的错误消息
                isCancellingExport = true;
                
                // ✅ 发送取消消息给 code.js
                parent.postMessage({ pluginMessage: { type: "cancel-gif-export" } }, "*");
                
                // ✅ 发送取消消息给 server
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: "cancel-gif-export" }));
                    console.log('   📤 已发送超时取消请求到服务器');
                }
                
                // 停止导出并提示用户
                stopSmoothProgress();
                clearExportStallDetection();
                
                isExporting = false;
                totalExports = 0;
                completedExports = 0;
                currentSmoothProgress = 0;
                
                // 重置 UI
                if (exportGifBtn) {
                    exportGifBtn.classList.remove("exporting");
                    exportGifBtn.classList.remove("success");
                    exportGifBtn.setAttribute('data-tooltip', '导出 GIF');
                }
                if (progressRing) progressRing.style.opacity = 0;
                
                // 提示用户
                showToast('导出超时，已自动终止', 'error');
                log('❌ 导出超时：GIF 尺寸过大或处理时间过长，建议减小画面尺寸或缩短视频时长');
                updateStatus('connected', '');
            }
        }, EXPORT_STALL_TIMEOUT);
    }
    
    // ✅ 清除导出卡住检测
    function clearExportStallDetection() {
        if (exportTimeoutId) {
            clearTimeout(exportTimeoutId);
            exportTimeoutId = null;
        }
    }
    
    // ✅ 重置导出卡住检测（收到进度更新时调用）
    function resetExportStallDetection() {
        lastProgressUpdate = Date.now();
        if (isExporting) {
            startExportStallDetection();
        }
    }

    function stopSmoothProgress() {
        if (smoothProgressInterval) {
            clearInterval(smoothProgressInterval);
            smoothProgressInterval = null;
        }
    }

    function createSplashParticles(rect) {
        const particleCount = 12;
        const colors = ["#34C759", "#32D74B", "#248A3D"]; // Shades of green
        
        for (let i = 0; i < particleCount; i++) {
            const particle = document.createElement("div");
            particle.classList.add("splash-particle");
            document.body.appendChild(particle);
            
            // Random position around center
            const angle = (i / particleCount) * 360 + (Math.random() * 30 - 15);
            const distance = 20 + Math.random() * 15;
            
            // Start at button center
            const startX = rect.left + rect.width / 2;
            const startY = rect.top + rect.height / 2;
            
            particle.style.left = `${startX}px`;
            particle.style.top = `${startY}px`;
            particle.style.background = colors[Math.floor(Math.random() * colors.length)];
            
            // Calculate destination
            const rad = angle * Math.PI / 180;
            const tx = Math.cos(rad) * distance;
            const ty = Math.sin(rad) * distance;
            
            particle.style.setProperty("--tx", `${tx}px`);
            particle.style.setProperty("--ty", `${ty}px`);
            
            particle.style.animation = `splash-anim 0.6s cubic-bezier(0.165, 0.84, 0.44, 1) forwards`;
            
            // Cleanup
            setTimeout(() => {
                if (particle.parentNode) document.body.removeChild(particle);
            }, 600);
        }
    }

    function cancelExport() {
        console.log('🛑 用户点击取消导出');
        
        // ✅ 设置取消标志，忽略后续的错误消息
        isCancellingExport = true;

        // 发送取消消息给后端
        parent.postMessage({ pluginMessage: { type: "cancel-gif-export" } }, "*");
        
        // 立即停止平滑进度动画
        stopSmoothProgress();
        clearExportStallDetection(); // ✅ 清除超时检测
        
        // 完全重置所有状态
        isExporting = false;
        totalExports = 0;
        completedExports = 0;
        currentSmoothProgress = 0;
        
        // 重置 UI 到初始状态
        if (exportGifBtn) {
            exportGifBtn.classList.remove("exporting");
            exportGifBtn.classList.remove("success");
            // 恢复原始 tooltip
            exportGifBtn.setAttribute('data-tooltip', '导出 GIF');
        }
        
        // 立即隐藏进度环
        setExportProgress(0);
        
        showToast("GIF 导出已停止", 'info');

        if (progressRing) {
            progressRing.style.transition = 'none';
            progressRing.style.opacity = '0';
            // 短暂延迟后恢复过渡效果，用于下次导出
            setTimeout(() => {
                if (progressRing) progressRing.style.transition = 'opacity 0.3s ease';
            }, 50);
        }
        
        // 重置进度到 0
        if (progressCircle) {
            progressCircle.style.transition = 'none';
            progressCircle.style.strokeDashoffset = circumference;
            setTimeout(() => {
                if (progressCircle) progressCircle.style.transition = 'stroke-dashoffset 0.2s linear';
            }, 50);
        }
        
        // 通知服务器取消所有进行中的处理
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: "cancel-gif-export" }));
            console.log('   📤 已发送取消请求到服务器');
        }
        
        console.log('   ✅ 所有状态已重置，可以重新开始导出');
    }

    function handleExportSuccess() {
        completedExports++;

        console.log(`✅ 导出成功 ${completedExports}/${totalExports}`);

        // On final completion, stop smooth progress and update status pill
        if (completedExports >= totalExports && totalExports > 0) {
            console.log('🎉 所有导出完成！');

            stopSmoothProgress();
            clearExportStallDetection(); // ✅ 清除超时检测
            setExportProgress(100);
            
            setTimeout(() => {
                isExporting = false;
                
                // Remove exporting class
                if (exportGifBtn) {
                    exportGifBtn.classList.remove("exporting");
                    // 恢复原始 tooltip
                    exportGifBtn.setAttribute('data-tooltip', '导出 GIF');
                }
                
                // Trigger icon completion glow animation (blink twice)
                const gifIcon = exportGifBtn.querySelector('.icon-gif-text');
                if (gifIcon) {
                    gifIcon.classList.add('icon-completion-glow');
                    setTimeout(() => {
                        gifIcon.classList.remove('icon-completion-glow');
                    }, 1400); // Match animation duration
                }
                
                // Directly fade out the progress ring at 100% (no backward animation)
                if (progressRing) {
                    progressRing.style.opacity = 0;
                }
                
                // Reset stroke offset AFTER fade out completes (invisible to user)
                setTimeout(() => {
                    if (progressCircle) progressCircle.style.strokeDashoffset = circumference;
                }, 400); // Match fade-out duration
                
                // No toast - success feedback is through status pill only
                console.log('✅ 导出完成，通过 status pill 显示反馈');
            }, 300);
        }
    }

    function handleExportError() {
        completedExports++;

        // On final completion (even with errors), stop smooth progress
        if (totalExports > 0 && completedExports >= totalExports) {
            stopSmoothProgress();
            clearExportStallDetection(); // ✅ 清除超时检测
            setExportProgress(100);
            
            setTimeout(() => {
                isExporting = false;
                
                // Remove exporting class
                if (exportGifBtn) {
                    exportGifBtn.classList.remove("exporting");
                    // 恢复原始 tooltip
                    exportGifBtn.setAttribute('data-tooltip', '导出 GIF');
                }
                
                // Directly fade out the progress ring at 100% (no backward animation)
                if (progressRing) {
                    progressRing.style.opacity = 0;
                }
                
                // Reset stroke offset AFTER fade out completes (invisible to user)
                setTimeout(() => {
                    if (progressCircle) progressCircle.style.strokeDashoffset = circumference;
                }, 300);
                
                // Error toast is already shown by individual error handlers
            }, 300);
        }
    }
  </script>
</html>
