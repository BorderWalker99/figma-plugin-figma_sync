<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ScreenSync</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Staatliches&family=Archivo+Black&display=swap" rel="stylesheet">
  <style>
    /*========================
      Design System: Lab / Apple Hybrid
    ========================*/
    :root {
      /* Colors */
      --bg-app: #F5F5F7;
      --bg-card: #FFFFFF;
      --bg-card-hover: #FDFDFD;
      
      /* Logo Colors */
      --logo-color-primary: #007AFF;
      --logo-color-secondary: #FFFFFF;

      --text-primary: #1D1D1F;
      --text-secondary: #86868B;
      --text-tertiary: #AEAEB2;
      
      /* Accent Blue: #0066FF (Contrast Ratio 4.67:1 with White, passes WCAG AA) */
      --accent: #0066FF;
      --accent-gradient: linear-gradient(135deg, #0066FF, #0052CC);
      --accent-soft: rgba(0, 102, 255, 0.1);
      
      --success: #34C759;
      --success-bg: rgba(52, 199, 89, 0.1);
      
      --warning: #FF9500;
      --warning-bg: rgba(255, 149, 0, 0.1);
      
      --danger: #FF3B30;
      --danger-bg: rgba(255, 59, 48, 0.1);
      
      --divider: rgba(0, 0, 0, 0.05);
      --border: rgba(0, 0, 0, 0.08);
      
      /* Shadows */
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.04);
      --shadow-md: 0 8px 24px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 15px 48px rgba(0, 0, 0, 0.1);
      --shadow-inner: inset 0 1px 1px rgba(255,255,255,0.5);
      
      /* Radius */
      --radius-s: 8px;
      --radius-m: 16px;
      --radius-l: 24px;
      
      /* Animation */
      --ease-spring: cubic-bezier(0.25, 0.8, 0.25, 1);
      --ease-out: cubic-bezier(0.33, 1, 0.68, 1);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg-app: #121212;
        --bg-card: #1C1C1E;
        --bg-card-hover: #2C2C2E;
        
        /* Logo Colors Dark Mode */
        --logo-color-primary: #0051D5;
        --logo-color-secondary: #1C1C1E;

        --text-primary: #F5F5F7;
        --text-secondary: #8E8E93;
        --text-tertiary: #48484A;
        
        --accent: #007AFF;
        --accent-soft: rgba(0, 122, 255, 0.1);

        --divider: rgba(255, 255, 255, 0.08);
        --border: rgba(255, 255, 255, 0.12);
        
        --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
        --shadow-md: 0 8px 24px rgba(0, 0, 0, 0.4);
      }
    }

    /* CSS Refactoring: Settings Content */
    .settings-section {
        margin-bottom: 20px;
        padding: 0;
    }

    /* Add extra space for the first section to avoid clipping hover effects */
    .tab-content > .settings-section:first-child {
        padding-top: 4px;
    }

    .settings-section:last-child {
        margin-bottom: 0;
    }

    .settings-section h3 {
        font-size: 13px;
        margin: 0 0 12px 0;
        /* font-weight: 600; */ 
    }

    * {
      box-sizing: border-box;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: "SF Pro Text", "SF Pro Icons", "Helvetica Neue", Helvetica, Arial, sans-serif;
      background: var(--bg-app);
      color: var(--text-primary);
      font-size: 13px;
      line-height: 1.4;
      overflow: hidden; /* Fixed height app */
      user-select: none;
    }

    /* Layout */
    .app {
      display: flex;
      flex-direction: column;
      height: 100vh;
      padding: 16px;
      gap: 8px;
      transition: all 0.4s var(--ease-spring);
    }

    .app.minimized {
      padding: 0;
      background: transparent;
    }
    
    .app.minimized .main-content,
    .app.minimized .status-bar {
      display: none;
    }

    /* Header */
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 4px;
      flex-shrink: 0;
      height: 32px; /* Fixed header height */
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .logo-box {
      /* width: 28px;
      height: 28px; */
      /* border-radius: var(--radius-s); */
      /* background: var(--bg-card);
      border: 1px solid var(--border); */
      display: flex;
      align-items: center;
      justify-content: center;
      /* box-shadow: var(--shadow-sm); */
    }
    
    .logo-box img {
        display: block;
        width: 18px;
        height: 18px;
    }

    .app-title {
      font-family: 'Archivo Black', sans-serif;
      font-weight: 400;
      font-size: 15px;
      letter-spacing: -0.01em;
      margin-top: 2px;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .connection-pill {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 100px;
      background: rgba(0, 0, 0, 0.08);
      color: var(--text-secondary);
      font-weight: 500;
      transition: all 0.3s ease;
      height: 24px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .connection-pill::before {
      content: '';
        display: block;
      width: 6px;
      height: 6px;
      border-radius: 50%;
        background-color: currentColor;
      opacity: 0.5;
    }

    .connection-pill:empty {
        display: none;
    }

    .connection-pill.connected {
        background: rgba(52, 199, 89, 0.15);
      color: var(--success);
    }
    
    .connection-pill.connected::before {
      opacity: 1;
        box-shadow: 0 0 6px rgba(52, 199, 89, 0.5);
    }
    
    .connection-pill.waiting {
        background: rgba(0, 122, 255, 0.15);
        color: var(--accent);
    }
    
    .connection-pill.waiting::before {
        opacity: 1;
        box-shadow: 0 0 6px rgba(0, 122, 255, 0.5);
    }
    
    .connection-pill.reconnect {
        background: rgba(255, 59, 48, 0.15);
        color: var(--danger);
        cursor: pointer;
        transition: all 0.2s ease;
        gap: 4px;
    }
    
    .connection-pill.reconnect::before {
        display: none; /* 不显示圆点，使用自定义 SVG 图标 */
    }
    
    .connection-pill.reconnect svg {
        animation: pulse 2s ease-in-out infinite;
    }
    
    .connection-pill.reconnect:hover {
        background: rgba(255, 59, 48, 0.25);
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(255, 59, 48, 0.2);
    }
    
    .connection-pill.reconnect:hover svg {
        animation: spin 1s linear infinite;
    }
    
    .connection-pill.reconnect:active {
        transform: translateY(0);
    }
    
    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
    }
    
    @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
    
    /* 减少右箭头和文字之间的间距 */

    @media (prefers-color-scheme: dark) {
        .connection-pill {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
        }
        .connection-pill.connected {
            background: rgba(52, 199, 89, 0.2);
        }
        .connection-pill.waiting {
            background: rgba(10, 132, 255, 0.2);
        }
        .connection-pill.reconnect {
            background: rgba(255, 59, 48, 0.2);
        }
        .connection-pill.reconnect:hover {
            background: rgba(255, 59, 48, 0.3);
        }
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .icon-btn {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      border: none;
      background: transparent;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      opacity: 0.6;
      position: relative; /* 为 tooltip 定位 */
    }

    .icon-btn:hover {
      background: rgba(0,0,0,0.05);
      opacity: 1;
    }
    
    @media (prefers-color-scheme: dark) {
        .icon-btn:hover {
            background: rgba(255,255,255,0.1);
        }
    }
    
    /* Tooltip 样式 */
    .icon-btn[data-tooltip]:not(.no-tooltip)::after {
      content: attr(data-tooltip);
      position: absolute;
      top: calc(100% + 7px);
      left: 50%;
      transform: translateX(-50%) scale(0.9);
      background: var(--bg-card);
      color: var(--text-primary);
      padding: 5px 10px;
      border-radius: 6px;
      font-size: 12px;
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease 0s, transform 0.2s ease 0s;
      z-index: 1000;
      font-weight: 400;
      letter-spacing: 0.01em;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12), 0 1px 3px rgba(0, 0, 0, 0.08);
    }
    
    /* Tooltip 小尖角 */
    .icon-btn[data-tooltip]:not(.no-tooltip)::before {
      content: '';
      position: absolute;
      top: calc(100% + 3px);
      left: 50%;
      transform: translateX(-50%) scale(0.9);
      width: 0;
      height: 0;
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
      border-bottom: 4px solid var(--bg-card);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease 0s, transform 0.2s ease 0s;
      z-index: 1001;
      filter: drop-shadow(0 -1px 1px rgba(0, 0, 0, 0.06));
    }
    
    .icon-btn[data-tooltip]:not(.no-tooltip):hover::after,
    .icon-btn[data-tooltip]:not(.no-tooltip):hover::before {
      opacity: 1;
      transform: translateX(-50%) scale(1);
      transition-delay: 0.5s;
    }

    /* Update Banner */
    .update-banner {
      display: none;
      /* Light Mode: 10% Opacity */
      background: color-mix(in srgb, var(--accent), transparent 90%);
      color: var(--text-primary);
      padding: 8px 8px 8px 12px;
      font-size: 11px;
      line-height: 1.4;
      border-radius: var(--radius-s);
      animation: slideDown 0.3s ease;
      flex-shrink: 0;
      margin: 8px 0;
      /* border: 1px solid color-mix(in srgb, var(--accent), transparent 80%); */
    }

    @media (prefers-color-scheme: dark) {
      .update-banner {
        /* Dark Mode: 30% Opacity */
        background: color-mix(in srgb, var(--accent), transparent 70%);
      }
    }

    .update-banner.show {
      display: block;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .update-banner-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .update-banner-info {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .update-banner-icon {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
      color: var(--accent);
    }

    .update-banner-text {
      flex: 1;
      font-weight: 500;
      font-size: 13px;
    }

    .update-banner-actions {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-shrink: 0;
    }

    .update-banner-btn {
      padding: 4px 6px;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 600;
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
    }

    .update-banner-btn.primary {
      background: var(--accent);
      color: white;
    }

    .update-banner-btn.primary:hover {
      filter: brightness(1.1);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .update-banner-btn.secondary {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .update-banner-btn.secondary:hover {
      background: var(--bg-active);
    }

    .update-banner-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .update-banner-close {
      width: 20px;
      height: 20px;
      padding: 0;
      background: transparent;
      border: none;
      border-radius: 4px;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }

    .update-banner-close svg {
      width: 14px;
      height: 14px;
    }

    .update-banner-close:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .update-banner-close:active {
      transform: scale(0.95);
    }

    /* Main Content Area */
    .main-content {
      flex: 1;
      position: relative;
      overflow: hidden;
    }

    /* Mode Selection View */
    .mode-selection {
      display: flex;
      flex-direction: column;
      gap: 12px;
      height: 100%;
      animation: zoomIn 0.4s var(--ease-out);
      text-align: center;
    }

    .section-title {
      font-size: 15px;
      font-weight: 700;
      margin: 0 0 4px 0;
      letter-spacing: -0.02em;
    }

    .section-desc {
      color: var(--text-secondary);
        font-size: 12px;
        margin-bottom: 8px;
    }

    .card-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .feature-card {
      background: var(--bg-card);
      border: 1px solid transparent;
      border-radius: var(--radius-m);
      padding: 15px;
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: space-between;
      text-align: left;
      gap: 0;
      cursor: pointer;
      transition: all 0.3s var(--ease-spring);
      box-shadow: var(--shadow-sm);
      position: relative;
      overflow: hidden;
    }

    .feature-card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .card-icon {
      width: 40px;
      height: 40px;
      border-radius: 50%; /* Circular icons */
      /* background: var(--bg-app); */
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      transition: all 0.3s ease;
      margin-bottom: 0;
      margin-right: 12px;
    }
    
    .card-icon img {
        width: 24px;
        height: 24px;
    }

    .card-content {
      flex: 1;
      width: 100%;
    }

    .card-title {
      font-weight: 600;
      font-size: 14px;
      margin-bottom: 2px;
      color: var(--text-primary);
    }

    .card-desc {
      font-size: 12px;
      color: var(--text-secondary);
      line-height: 1.4;
    }

    /* Upload mode cards - centered titles */
    .feature-card.mode-card {
      align-items: center;
    }
    
    .feature-card.mode-card .card-icon {
      margin-right: 0;
      margin-bottom: 4px;
    }
    
    .feature-card.mode-card .card-content {
      text-align: center;
    }
    
    .feature-card.mode-card .card-title {
      text-align: center;
    }
    
    .feature-card.mode-card .card-desc {
      text-align: center;
    }

    /* Selected Checkmark */
    .checkmark {
      position: absolute;
      top: 0;
      right: 0;
      background: var(--accent);
      width: 24px;
      height: 24px;
      border-bottom-left-radius: calc(var(--radius-m) - 1px);
      border-top-right-radius: calc(var(--radius-m) - 1px); /* Match card radius */
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    .checkmark svg {
      width: 14px;
      height: 14px;
      color: white;
    }

    .feature-card.selected .checkmark {
      display: flex;
    }
    
    .chevron {
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-tertiary);
      margin-left: 8px;
    }
    
    .chevron svg {
        width: 20px; 
        height: 20px;
    }

    /* Work Area View */
    .work-area {
      display: none;
      flex-direction: column;
      height: 100%;
      animation: zoomIn 0.4s var(--ease-spring);
    }
    
    .work-area.active {
      display: flex;
    }

    /* Compact Status Hero - Optimized Layout */
    .status-hero {
      background: var(--bg-card);
      border-radius: var(--radius-m);
      padding: 16px 16px 20px 16px;
      /* border: 1px solid var(--border); */
      box-shadow: var(--shadow-sm);
      position: relative;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .hero-header {
      display: flex;
      align-items: center;
        justify-content: space-between;
        width: 100%;
    }
    
    .hero-mode-info {
      display: flex;
      align-items: center;
        gap: 8px;
    }
    
    /* New compact mode icon */
    .hero-icon-sm {
        width: 22px;
        height: 22px;
        border-radius: 50%;
      display: flex;
      align-items: center;
        justify-content: center;
        flex-shrink: 0;
    }
    
    .hero-icon-sm svg {
        width: 12px;
        height: 12px;
    }

    .hero-mode-title {
        font-size: 15px;
        font-weight: 600;
        color: var(--text-primary);
    }

    /* Main metric layout */
    .hero-main-metric {
      display: flex;
        align-items: baseline;
        justify-content: center;
        gap: 8px;
        padding: 8px 0;
    }

    .count-display {
      font-size: 48px;
      font-weight: 700;
      letter-spacing: -0.02em;
      color: var(--text-primary);
      line-height: 1;
      font-variant-numeric: tabular-nums;
    }

    .metric-label {
        font-size: 13px;
        color: var(--text-secondary);
        font-weight: 500;
    }

    /* Action buttons container */
    .action-buttons {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: auto; /* Push to bottom */
    }

    .btn {
      width: 100%;
      padding: 12px;
      border-radius: var(--radius-s);
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      border: 1px solid transparent;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: all 0.2s var(--ease-spring);
    }

    .btn:active {
      transform: scale(0.98);
    }

    .btn-primary {
      background: var(--accent);
      color: #FFFFFF;
    }

    .btn-primary:hover {
      filter: brightness(1.1);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .btn-secondary {
      background: transparent;
      border-color: var(--border);
      color: var(--text-primary);
    }

    .btn-secondary:hover {
      background: rgba(0, 0, 0, 0.05);
      border-color: var(--border);
    }
    
    @media (prefers-color-scheme: dark) {
        .btn-secondary {
            border-color: rgba(255, 255, 255, 0.15);
        }
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.15);
        }
    }

    .btn-danger {
        background: var(--danger);
        color: #FFFFFF;
    }
    
    .btn-danger:hover {
        filter: brightness(1.1);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    
    @media (prefers-color-scheme: dark) {
        .btn-danger {
            background: #CC2E26;
            color: #FFFFFF;
        }
        .btn-danger:hover {
            background: #B3261E;
        }
    }

    /* Log Area */
    .log-wrapper {
        flex: 1;
        min-height: 0;
        /* border: 1px solid var(--border); */
        border-radius: var(--radius-s);
        background: var(--bg-card);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        margin-bottom: 12px;
    }
    
    .log-header {
        padding: 6px 12px;
        background: rgba(0,0,0,0.02);
        /* border-bottom: 1px solid var(--border); */
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        height: 28px;
    }
    
    .log-title {
        font-size: 12px;
        font-weight: 600;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    .log-content {
        flex: 1;
        padding: 8px 12px;
        overflow-y: auto;
        font-family: "SF Mono", Menlo, monospace;
        font-size: 12px;
        line-height: 1.6;
        color: var(--text-secondary);
        white-space: pre-wrap;
        transition: all 0.3s ease;
    }
    
    .log-wrapper.collapsed .log-content {
        display: none;
    }
    .log-wrapper.collapsed {
        flex: 0 0 auto;
    }

    /* Info Box */
    .info-box {
      background: var(--accent-soft);
      /* border: 1px solid rgba(0, 122, 255, 0.1); */
      color: var(--accent);
      padding: 12px;
      border-radius: var(--radius-s);
      font-size: 12px;
      margin-bottom: 8px;
      display: none;
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0);
      backdrop-filter: blur(0px);
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
      
      /* Hidden state properties */
      opacity: 0;
      visibility: hidden; /* Use visibility instead of display:none */
      pointer-events: none;
      
      /* Transitions including visibility delay */
      transition: opacity 0.25s cubic-bezier(0.33, 1, 0.68, 1),
                  background 0.25s cubic-bezier(0.33, 1, 0.68, 1),
                  backdrop-filter 0.25s cubic-bezier(0.33, 1, 0.68, 1),
                  visibility 0s linear 0.25s; /* Delay hiding visibility */
    }

    /* Modal Overlay - Show State */
    .modal-overlay.show {
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(8px);
      transition-delay: 0s; /* No delay when showing */
    }

    .modal {
      width: 90%;
      max-width: 360px;
      background: var(--bg-card);
      border-radius: var(--radius-l);
      box-shadow: var(--shadow-lg);
      padding: 20px;
      transform: scale(0.92) translateY(20px);
      opacity: 0;
      transition: transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1),
                  opacity 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
      /* border: 1px solid var(--border); */
      max-height: 85vh;
      overflow-y: auto;
    }

    .modal-overlay:not(.hidden) .modal {
      transform: scale(1) translateY(0);
      opacity: 1;
    }


    .modal {
      width: 90%;
      max-width: 360px;
      background: var(--bg-card);
      border-radius: var(--radius-l);
      box-shadow: var(--shadow-lg);
      /* padding: 20px; Remove global padding to allow header to be full width */
      padding: 0; /* Reset padding */
      transform: scale(0.92) translateY(20px);
      opacity: 0;
      transition: transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1),
                  opacity 0.35s cubic-bezier(0.34, 1.56, 0.64, 1),
                  max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      max-height: 85vh;
      display: flex;
      flex-direction: column;
      overflow: hidden; /* Important for border-radius */
    }

    .modal-overlay:not(.hidden) .modal {
      transform: scale(1) translateY(0);
      opacity: 1;
    }

    .modal-content {
        padding: 24px; /* Increased padding to prevent clipping of hover effects */
        overflow-y: auto; /* Scroll content only */
        flex: 1;
        opacity: 0;
        transform: translateY(10px);
        transition: opacity 0.4s cubic-bezier(0.33, 1, 0.68, 1) 0.1s,
                    transform 0.4s cubic-bezier(0.33, 1, 0.68, 1) 0.1s,
                    max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                    min-height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .modal-overlay:not(.hidden) .modal-content {
        opacity: 1;
        transform: translateY(0);
    }

    .modal-header {
      /* position: sticky; Remove sticky, flex layout handles it */
      /* top: 0; */
      display: flex;
      justify-content: space-between;
      align-items: center;
      /* margin: 0 0 15px 0; */
      padding: 14px 20px 8px 20px; 
      border-bottom: 1px solid var(--divider);
      background: var(--bg-card);
      z-index: 10;
      flex-shrink: 0; /* Prevent header from shrinking */
      opacity: 0;
      transform: translateY(-10px);
      transition: opacity 0.3s cubic-bezier(0.33, 1, 0.68, 1) 0.05s,
                  transform 0.3s cubic-bezier(0.33, 1, 0.68, 1) 0.05s;
    }

    .modal-overlay:not(.hidden) .modal-header {
        opacity: 1;
        transform: translateY(0);
    }

    .modal-title {
      font-size: 15px;
      font-weight: 700;
    }
    
    /* Modal Tabs */
    .modal-tabs {
        display: flex;
        gap: 20px;
        align-items: center;
    }

    .tab-btn {
        background: transparent;
        border: none;
        padding:  0;
        font-size: 14px;
        font-weight: 600;
        color: var(--text-tertiary);
        cursor: pointer;
        position: relative;
        transition: color 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .tab-btn::after {
        content: '';
        position: absolute;
        bottom: -9px; /* Adjust based on header padding */
        left: 50%;
        right: 50%;
        height: 2px;
        background: var(--text-primary);
        border-radius: 2px;
        opacity: 0;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .tab-btn:hover {
        color: var(--text-secondary);
    }

    .tab-btn.active {
        color: var(--text-primary);
    }
    
    .tab-btn.active::after {
        left: 0;
        right: 0;
        opacity: 1;
    }
    
    /* Tab Content Animation */
    .tab-content {
        opacity: 0;
        transform: translateX(-20px);
        transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1), 
                    transform 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                    height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        display: none;
        overflow: hidden; /* Smooth height transition */
    }
    
    .tab-content.active {
        opacity: 1;
        transform: translateX(0);
    }
    
    .tab-content.slide-out-left {
        opacity: 0;
        transform: translateX(-20px);
    }
    
    .tab-content.slide-out-right {
        opacity: 0;
        transform: translateX(20px);
    }
    
    .tab-content.slide-in-left {
        animation: slideInLeft 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }
    
    .tab-content.slide-in-right {
        animation: slideInRight 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }
    
    @keyframes slideInLeft {
        from {
            opacity: 0;
            transform: translateX(-20px);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }
    
    @keyframes slideInRight {
        from {
            opacity: 0;
            transform: translateX(20px);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }

    /* Modal buttons - smaller height */
    .modal .btn {
      padding: 8px 12px;
    }
    
    .close-btn {
        width: 24px;
        height: 24px;
      border-radius: 50%;
        background: rgba(0,0,0,0.05);
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--text-secondary);
      transition: all 0.2s cubic-bezier(0.33, 1, 0.68, 1);
      transform: scale(1);
    }
    
    .close-btn:hover {
        background: var(--divider);
        color: var(--text-primary);
        transform: scale(1.1);
    }
    
    .close-btn:active {
        transform: scale(0.95);
    }
    
    @media (prefers-color-scheme: dark) {
        .close-btn {
            background: rgba(255,255,255,0.1);
        }
    }
    
    /* Hide number input spinners */
    input[type=number]::-webkit-inner-spin-button, 
    input[type=number]::-webkit-outer-spin-button { 
        -webkit-appearance: none; 
        margin: 0; 
    }

    /* Input Styles - Inside Label Variant */
    .input-wrapper {
      display: flex;
      align-items: center;
        background: var(--bg-app);
        border-radius: var(--radius-s);
        padding: 0 12px;
        height: 32px;
        border: 1px solid transparent; /* Transparent border for alignment */
        transition: all 0.2s ease;
    }
    
    .input-wrapper:hover {
        background: rgba(0, 0, 0, 0.02);
    }
    
    @media (prefers-color-scheme: dark) {
        .input-wrapper:hover {
            background: rgba(255, 255, 255, 0.05);
        }
    }
    
    .input-wrapper:focus-within {
        background: var(--bg-app);
        border-color: var(--accent);
        box-shadow: 0 0 0 3px var(--accent-soft);
    }

    .input-prefix {
        color: var(--text-secondary);
        font-size: 13px;
        margin-right: 8px;
        font-weight: 500;
        white-space: nowrap;
    }

    /* Reset default input styles for use inside wrapper */
    .input-wrapper input {
        border: none;
        background: transparent;
        padding: 0;
        margin: 0;
        width: 100%;
        height: 100%;
        outline: none;
        box-shadow: none;
      color: var(--text-primary);
        font-size: 13px;
    }
    
    /* Placeholder color */
    .input-wrapper input::placeholder {
        color: var(--text-tertiary);
    }

    /* Toast */
    .toast {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%) translateY(-100px);
      background: var(--bg-card);
      /* border: 1px solid var(--border); */
      border-radius: var(--radius-m);
      padding: 8px 12px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12), 0 0 1px rgba(0, 0, 0, 0.1);
      font-size: 13px;
      font-weight: 500;
      color: #1D1D1F;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: all 0.5s var(--ease-spring);
      white-space: nowrap;
      width: fit-content;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    @media (prefers-color-scheme: dark) {
        .toast {
            color: #F5F5F7;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4), 0 0 1px rgba(255, 255, 255, 0.1);
        }
    }
    
    .toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
      pointer-events: auto;
    }
    
    .toast-icon {
      width: 14px;
      height: 14px;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .toast-icon svg {
      width: 100%;
      height: 100%;
    }
    
    .toast.success .toast-icon {
      color: var(--success);
    }
    
    .toast.error .toast-icon {
      color: var(--danger);
    }
    
    .toast.loading .toast-icon {
      color: var(--text-secondary);
    }
    
    .toast.loading .toast-icon svg {
      stroke: currentColor;
    }
    
    .toast-action {
      cursor: pointer;
      text-decoration: underline;
      text-underline-offset: 2px;
      margin-left: 6px;
      transition: opacity 0.2s ease;
    }
    
    .toast-action:hover {
      opacity: 0.8;
    }

    /* Utilities */
    .hidden { display: none !important; }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    @keyframes zoomIn {
      from { opacity: 0; transform: scale(0.92); }
      to { opacity: 1; transform: scale(1); }
    }
    
    /* Minimized State Styles */
    .minimized-toolbar {
        display: none;
        background: transparent;
        border: none;
        padding: 4px 4px 4px 12px;
        align-items: center;
        justify-content: space-between;
        box-shadow: none;
        height: 100%;
        animation: zoomIn 0.3s var(--ease-spring);
    }
    
    .app.minimized .minimized-toolbar {
        display: flex;
    }

    .minimized-brand {
        font-family: 'Archivo Black', sans-serif;
        font-weight: 400;
        font-size: 15px;
      display: flex;
        align-items: center;
        gap: 6px;
        color: var(--text-primary);
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
    }
    
    .minimized-brand img {
        width: 18px;
        height: 18px;
        display: block;
    }
    
    .minimized-btn {
        width: 28px; 
        height: 28px;
      border-radius: 50%;
        border: none;
        background: transparent;
      display: flex;
      align-items: center;
      justify-content: center;
        cursor: pointer;
        color: var(--text-secondary);
        opacity: 0.7; /* Match .icon-btn opacity */
        transition: all 0.2s ease;
    }
    
    .minimized-btn:hover {
        background: rgba(0,0,0,0.05);
        opacity: 1;
        color: var(--text-primary);
    }
    
    @media (prefers-color-scheme: dark) {
        .minimized-btn:hover {
            background: rgba(255,255,255,0.1);
        }
    }
    
    .app.minimized .header {
        display: none;
    }
    
    /* Theme Specific Images */
    img.no-invert {
        filter: none !important;
      }

    /* SVG Icons */
    .svg-icon {
        width: 16px;
        height: 16px;
        stroke-width: 2;
        stroke: currentColor;
        fill: none;
        stroke-linecap: round;
        stroke-linejoin: round;
    }
    
    .svg-icon-sm {
        width: 15px;
        height: 15px;
    }

    /* Apple Switch */
    .switch {
      position: relative;
      display: inline-block;
      width: 42px;
      height: 26px;
      flex-shrink: 0;
    }

    .switch input { 
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #E9E9EA;
      transition: .3s cubic-bezier(0.25, 0.8, 0.25, 1);
      border-radius: 34px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 22px;
      width: 22px;
      left: 2px;
      bottom: 2px;
      background-color: white;
      transition: .3s cubic-bezier(0.25, 0.8, 0.25, 1);
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0,0,0,0.15);
    }

    input:checked + .slider {
      background-color: var(--accent);
    }

    input:checked + .slider:before {
      transform: translateX(16px);
    }

    @media (prefers-color-scheme: dark) {
      .slider {
        background-color: #39393D;
      }
    }

    /* Export GIF Button & Animations */
    /* Export GIF Button & Animations */
    #exportGifBtn {
        position: relative;
        overflow: visible; 
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.4s cubic-bezier(0.33, 1, 0.68, 1); /* Apple easeOut */
        color: var(--text-primary); /* Match other .icon-btn */
        padding: 0; /* Remove padding to center content exactly */
    }
    
    #exportGifBtn:hover {
        background: rgba(0,0,0,0.05);
    }
    
    /* 导出中的悬停状态 - 显示停止按钮 */
    #exportGifBtn.exporting:hover {
        background: rgba(239, 68, 68, 0.15); /* 浅红色背景 */
        color: #ef4444; /* 红色 */
    }
    
    @media (prefers-color-scheme: dark) {
        #exportGifBtn:hover {
            background: rgba(255,255,255,0.1);
        }
        
        #exportGifBtn.exporting:hover {
            background: rgba(239, 68, 68, 0.2); /* 深色模式下稍深一点 */
            color: #f87171; /* 稍浅的红色 */
        }
    }

    /* Progress Ring */
    .progress-ring {
        position: absolute;
        /* Center 34px ring on 30px button */
        /* (34 - 30) / 2 = 2px offset */
        top: -2px;
        left: -2px;
        width: 34px;
        height: 34px;
        pointer-events: none;
        transform: rotate(-90deg);
        opacity: 0;
        transition: opacity 0.3s;
    }
    
    /* 确保非导出状态下进度环完全隐藏 */
    #exportGifBtn:not(.exporting) .progress-ring {
        opacity: 0 !important;
    }
    
    .progress-ring__circle {
        fill: transparent;
        stroke: var(--success);
        stroke-width: 3; /* Slightly thicker for better visibility */
        stroke-linecap: round;
        stroke-dasharray: 100 100;
        stroke-dashoffset: 100;
        transition: stroke-dashoffset 0.2s linear, stroke 0.3s ease; /* Linear for progress, smooth for color */
    }
    
    /* 悬停时进度条变红色 */
    #exportGifBtn.exporting:hover .progress-ring__circle {
        stroke: #ef4444; /* 红色，与按钮悬停颜色一致 */
    }

    /* Success State */
    #exportGifBtn.success {
        background-color: var(--success) !important;
        color: white !important;
        transform: scale(1.05); /* Subtle pulse */
        opacity: 1 !important; /* Force opacity to 100% in success state */
    }
    
    #exportGifBtn.success:hover {
        opacity: 1 !important; /* Maintain 100% opacity on hover in success state */
    }
    
    #exportGifBtn.success .progress-ring {
        opacity: 0;
    }

    /* Icon Morphing */
    .icon-wrapper {
        position: relative;
        width: 16px;
        height: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .icon-gif, .icon-stop, .icon-folder {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1); /* Bouncy spring */
        pointer-events: none;
        transform-origin: center center;
    }

    .icon-stop {
        opacity: 0;
        transform: scale(0.55) rotate(45deg);
        stroke-width: 2.5 !important; /* 更明显的加粗效果 */
    }
    
    /* 导出中且悬停时显示停止图标 */
    #exportGifBtn.exporting:hover .icon-gif {
        opacity: 0;
        transform: scale(0.6) rotate(-45deg);
    }
    
    #exportGifBtn.exporting:hover .icon-stop {
        opacity: 1;
        transform: scale(0.91) rotate(0deg);
    }

    .icon-folder {
        opacity: 0;
        transform: scale(0.4) rotate(45deg);
    }
    
    #exportGifBtn.success .icon-gif {
        opacity: 0;
        transform: scale(0.4) rotate(-45deg);
    }
    
    #exportGifBtn.success .icon-folder {
        opacity: 1;
        transform: scale(1) rotate(0deg);
    }

    /* Splash Effect */
    .splash-particle {
        position: absolute;
        width: 3px; /* Smaller particles */
        height: 3px;
        background: var(--success);
        border-radius: 50%;
        pointer-events: none;
        opacity: 0;
        z-index: 100;
    }
    
    @keyframes splash-anim {
        0% { transform: translate(0, 0) scale(1); opacity: 0.8; }
        50% { opacity: 1; }
        100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
    }
  </style>
  <script>
    // GitHub 图片资源基础 URL
    const IMAGE_BASE_URL = 'https://raw.githubusercontent.com/BorderWalker99/figma-plugin-figma_sync/refs/heads/main/images/';
    
    // 根据主题获取二维码（使用 GitHub URL）
    function getQRCodeURI(isDark) {
      return {
        google: IMAGE_BASE_URL + (isDark ? 'qr-google-white.png' : 'qr-google-black.png'),
        googleScreenshot: IMAGE_BASE_URL + (isDark ? 'qr-google-white.png' : 'qr-google-black.png'),
        googleAlbum: IMAGE_BASE_URL + (isDark ? 'qr-google-album-white.png' : 'qr-google-album-black.png'),
        icloud: IMAGE_BASE_URL + (isDark ? 'qr-icloud-white.png' : 'qr-icloud-black.png'),
        icloudScreenshot: IMAGE_BASE_URL + (isDark ? 'qr-icloud-white.png' : 'qr-icloud-black.png'),
        icloudAlbum: IMAGE_BASE_URL + (isDark ? 'qr-icloud-album-white.png' : 'qr-icloud-album-black.png')
      };
    }
  </script>
</head>

<body>
  <div class="app">
    <!-- Header -->
    <div class="header">
      <div class="brand">
        <div class="logo-box">
          <img src="https://raw.githubusercontent.com/BorderWalker99/figma-plugin-figma_sync/refs/heads/main/images/logo.svg" width="18" height="18" />
      </div>
        <div>
          <div class="app-title">SYNC</div>
        </div>
      </div>
      <div class="header-actions">
        <button id="viewUseCases" class="icon-btn" title="手机端配置" style="display: none;">
           <svg class="svg-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
             <rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect>
             <line x1="12" y1="18" x2="12.01" y2="18"></line>
           </svg>
        </button>
        <button id="exportGifBtn" class="icon-btn" data-tooltip="导出 GIF">
           <svg class="progress-ring" viewBox="0 0 34 34">
             <circle class="progress-ring__circle" r="15" cx="17" cy="17"/>
           </svg>
           <div class="icon-wrapper">
               <!-- GIF Icon (Film Strip) -->
               <svg class="icon-gif svg-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                   <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                   <line x1="7.5" y1="3" x2="7.5" y2="21"></line>
                   <line x1="16.5" y1="3" x2="16.5" y2="21"></line>
                   <line x1="3" y1="12" x2="21" y2="12"></line>
                   <line x1="3" y1="7.5" x2="7.5" y2="7.5"></line>
                   <line x1="3" y1="16.5" x2="7.5" y2="16.5"></line>
                   <line x1="16.5" y1="16.5" x2="21" y2="16.5"></line>
                   <line x1="16.5" y1="7.5" x2="21" y2="7.5"></line>
               </svg>
               <!-- Stop Icon (Cancel) -->
               <svg class="icon-stop svg-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                   <rect x="4.75" y="4.75" width="14.5" height="14.5" rx="2" ry="2"></rect>
               </svg>
               <!-- Folder Icon (Hidden by default) -->
               <svg class="icon-folder svg-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                   <path d="M21 18a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 3 18V6a1.5 1.5 0 0 1 1.5-1.5h4.5l1.5 2.25h9A1.5 1.5 0 0 1 21 8.25z"></path>
               </svg>
           </div>
        </button>
        <button id="openSettings" class="icon-btn" data-tooltip="插件与手机端设置">
           <svg class="svg-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
             <circle cx="12" cy="12" r="3"></circle>
             <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
           </svg>
        </button>
        <button id="toggleMinimize" class="icon-btn" data-tooltip="最小化窗口">
            <!-- Icon will be updated by JS, but default is minimize -->
            <svg id="minimizeIcon" class="svg-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="4 14 10 14 10 20"></polyline>
              <polyline points="20 10 14 10 14 4"></polyline>
            </svg>
        </button>
      </div>
    </div>
    
    <!-- Update Banner -->
    <div class="update-banner" id="updateBanner">
      <div class="update-banner-content">
        <div class="update-banner-info">
          <svg class="update-banner-icon" viewBox="0 0 24 24" fill="currentColor">
            <path d="M19 9l1.25-2.75L23 5l-2.75-1.25L19 1l-1.25 2.75L15 5l2.75 1.25L19 9zm-7.5.5L9 4 6.5 9.5 1 12l5.5 2.5L9 20l2.5-5.5L17 12l-5.5-2.5z"/>
          </svg>
          <div class="update-banner-text" id="updateBannerText">发现新版本 v1.0.2</div>
        </div>
        <div class="update-banner-actions">
          <button class="update-banner-btn primary" id="updateBannerNow">立即更新</button>
          <button class="update-banner-close" id="updateBannerClose">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
        </div>
      </div>
    </div>
    
    <!-- Minimized Toolbar (Visible only when minimized) -->
    <div class="minimized-toolbar">
        <div class="minimized-brand">
          <img src="https://raw.githubusercontent.com/BorderWalker99/figma-plugin-figma_sync/refs/heads/main/images/logo.svg" width="18" height="18" />
             <span style="margin-top: 2px;">SYNC</span>
          </div>
         <button class="minimized-btn" onclick="toggleMinimize()">
           <svg class="svg-icon" style="width: 15px; height: 15px;" viewBox="0 0 24 24"><polyline points="13 5 19 5 19 11"></polyline><polyline points="11 19 5 19 5 13"></polyline></svg>
        </button>
    </div>

    <!-- Main Content -->
    <div class="main-content">

    <!-- Mode Selection -->
    <div class="mode-selection" id="modeSelection">
        <div>
          <h2 class="section-title">选择同步模式</h2>
          <!-- <div class="section-desc">同步后将自动清理源文件以释放空间</div> -->
      </div>
        
        <div class="card-grid">
          <div class="feature-card" id="realtimeBtn">
            <div class="card-icon" style="color: #FFCC00; background: rgba(255, 204, 0, 0.15);">
              <!-- Realtime: Lightning/Sync (Filled + Rounded) -->
              <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linejoin="round">
              <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"></path>
            </svg>
          </div>
            <div class="card-content">
              <div class="card-title">实时模式</div>
              <div class="card-desc">手机截图 实时导入</div>
            </div>
            <div class="chevron">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>
            </div>
        </div>

          <div class="feature-card" id="manualBtn">
            <div class="card-icon" style="color: var(--accent); background: var(--accent-soft);">
               <!-- Manual: Download (Arrow + Bar) - Adjusted for visual weight -->
               <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="0">
                 <path d="M19 9h-4V3H9v6H5l7 8 7-8zM5 19v3h14v-3H5z"></path>
            </svg>
          </div>
            <div class="card-content">
              <div class="card-title">手动模式</div>
              <div class="card-desc">云端截图 批量导入</div>
            </div>
            <div class="chevron">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>
            </div>
        </div>
      </div>
    </div>

    <!-- Work Area -->
      <div class="work-area" id="workArea">
        
        <!-- Compact Status Hero -->
        <div class="status-hero">
            <div class="hero-header">
                <div class="hero-mode-info">
                    <div class="hero-icon-sm" id="activeModeIcon">
                        <!-- Dynamic SVG -->
                    </div>
                    <span class="hero-mode-title" id="activeModeTitle">模式名称</span>
                </div>
                <div id="status" class="connection-pill">等待中</div>
        </div>

            <div class="hero-main-metric">
                <div class="count-display" id="count">0</div>
                <div class="metric-label">张</div>
          </div>
            
            <div id="modeSubtitle" style="display:none;"></div>
        </div>

        <div class="info-box" id="infoBox"></div>
        
        <!-- Log Area (Hidden) -->
        <div class="log-wrapper" id="logContainer" style="display: none;">
          <div class="log-header" id="logHeader">
                <span class="log-title">系统日志</span>
                <span id="logToggleText" style="font-size:12px; color:var(--text-tertiary);">收起</span>
          </div>
          <div class="log-content" id="log"></div>
        </div>

        <div class="action-buttons">
            <button class="btn btn-primary" id="syncBtn" style="display:none;">
                立即同步
            </button>
            <button class="btn btn-danger" id="stopBtn" style="display:none;">停止同步</button>
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                <button class="btn btn-secondary" id="locateFrameBtn" style="display:none;">定位画板</button>
                <button class="btn btn-secondary" id="backBtn" style="grid-column: span 2;">返回</button>
            </div>
        </div>
      </div>
    </div>
  </div>


  <!-- Settings Modal -->
  <div id="settingsOverlay" class="modal-overlay">
    <div class="modal">
      <div class="modal-header">
        <div class="modal-tabs">
            <button class="tab-btn active" id="tabDesktop">插件端</button>
            <button class="tab-btn" id="tabMobile">手机端</button>
        </div>
        <button id="settingsClose" class="close-btn">✕</button>
      </div>
      <div class="modal-content" id="settingsContent">
        
        <!-- Tab Content: Desktop -->
        <div id="contentDesktop" class="tab-content active">
        <!-- Cloud Provider Selection -->
        <div class="settings-section">
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px;">
                <div class="feature-card mode-card" id="switchToDrive" style="padding: 12px; flex-direction: column; height: 100%;">
                    <div class="checkmark">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 7 9 18 4 13"></polyline></svg>
                </div>
                    <div class="card-icon" style="width:32px; height:32px;">
                        <img class="no-invert" src="https://raw.githubusercontent.com/BorderWalker99/figma-plugin-figma_sync/refs/heads/main/images/google.svg" width="20" height="20">
              </div>
                    <div class="card-content" style="width:100%">
                        <div class="card-title" style="margin-bottom:2px;">Google Cloud</div>
                        <div class="card-desc">无需 iCloud</div>
            </div>
                </div>
                 <div class="feature-card mode-card" id="switchToAliyun" style="display:none; padding: 12px; flex-direction: column; height: 100%;">
                     <div class="checkmark">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>
              </div>
                     <div class="card-icon" style="width:32px; height:32px;">
                        <img class="no-invert" src="https://raw.githubusercontent.com/BorderWalker99/figma-plugin-figma_sync/refs/heads/main/images/aliyun.svg" width="20" height="20">
            </div>
                    <div class="card-content" style="width:100%">
                        <div class="card-title" style="margin-bottom:2px;">阿里云 OSS</div>
                        <div class="card-desc">对象存储</div>
                </div>
              </div>
                 <div class="feature-card mode-card" id="switchToIcloud" style="padding: 12px; flex-direction: column; height: 100%;">
                     <div class="checkmark">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>
            </div>
                     <div class="card-icon" style="width:32px; height:32px;">
                        <img class="no-invert" src="https://raw.githubusercontent.com/BorderWalker99/figma-plugin-figma_sync/refs/heads/main/images/icloud.svg" width="20" height="20">
          </div>
                    <div class="card-content" style="width:100%">
                        <div class="card-title" style="margin-bottom:2px;">iCloud</div>
                        <div class="card-desc">iCloud 需有空间</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Size Settings -->
        <div class="settings-section">
            <h3>截图尺寸</h3>
             <div style="display: flex; gap: 8px;">
                <div class="input-wrapper" style="flex: 1;">
                  <span class="input-prefix">宽</span>
                  <input type="number" id="imageWidthInput" placeholder="自适应">
            </div>
                <div class="input-wrapper" style="flex: 1;">
                  <span class="input-prefix">高</span>
                  <input type="number" id="imageHeightInput" placeholder="自适应">
            </div>
          </div>
        </div>

        <!-- Layout Settings -->
        <div class="settings-section">
            <h3>画板布局</h3>
            <div>
                <div class="input-wrapper">
                    <span class="input-prefix">每行</span>
                    <input type="number" id="frameColumnsInput" placeholder="一直横排">
          </div>
          </div>
        </div>

                <!-- GIF Backup Setting (Google Drive Only) -->
                <div id="gifBackupSection" class="settings-section" style="display:none;">
                  <div style="display: flex; justify-content: space-between; align-items: center;">
                      <div>
                          <div style="font-size:13px; font-weight: 600;">GIF 保存到本地</div>
                      </div>
                      <label class="switch">
                          <input type="checkbox" id="gifBackupToggle">
                          <span class="slider"></span>
                      </label>
                  </div>
              </div>

                <!-- Keep GIF in iCloud Setting (iCloud Only) -->
                <div id="keepGifInIcloudSection" class="settings-section" style="display:none;">
                  <div style="display: flex; justify-content: space-between; align-items: center;">
                      <div>
                          <div style="font-size:13px; font-weight: 600;">GIF 保留在文件夹</div>
                      </div>
                      <label class="switch">
                          <input type="checkbox" id="keepGifInIcloudToggle">
                          <span class="slider"></span>
                      </label>
                  </div>
              </div>

                <!-- Global Save Button -->
                <div style="margin-top: 20px; margin-bottom: 10px;">
                    <button id="globalSaveBtn" class="btn btn-primary" style="width: 100%;" disabled>保存设置</button>
                </div>
        </div>

        <!-- Tab Content: Mobile -->
        <div id="contentMobile" class="tab-content" style="display:none;">
             <div style="display: flex; flex-direction: column; gap: 16px;">
              <div id="shortcutGuideSection"  style="display: flex; flex-direction: column; gap: 8px;">
                 <div id="shortcutGuideTitle" style="font-weight: 600; margin-bottom: 8px; font-size: 13px;">01 配置快捷指令</div>
                 <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;" id="qrCodesContainer">
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 6px;" id="qrGoogleScreenshotContainer">
                      <img id="qrGoogleScreenshot" style="width: 80px; height: 80px;">
                      <div style="font-size: 12px; color: var(--text-secondary); text-align: center;">直接截图</div>
                </div>
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 6px;" id="qrGoogleAlbumContainer">
                      <img id="qrGoogleAlbum" style="width: 80px; height: 80px;">
                      <div style="font-size: 12px; color: var(--text-secondary); text-align: center;">相册选择</div>
                  </div>
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 6px;" id="qrIcloudScreenshotContainer">
                      <img id="qrIcloudScreenshot" style="width: 80px; height: 80px;">
                      <div style="font-size: 12px; color: var(--text-secondary); text-align: center;">直接截图</div>
                  </div>
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 6px;" id="qrIcloudAlbumContainer">
                      <img id="qrIcloudAlbum" style="width: 80px; height: 80px;">
                      <div style="font-size: 12px; color: var(--text-secondary); text-align: center;">相册选择</div>
                  </div>
                  </div>
                 <div id="noModeMessage" style="font-size: 12px; color: var(--text-secondary); line-height: 1.6; display: none;">
                    请在"电脑端"中选择储存方式
              </div>
            </div>

                        <!-- User ID Display -->
                        <div id="userIdDisplaySection">
                          <div id="userIdTitle" style="font-weight: 600; margin-bottom: 8px; font-size: 13px;">02 您的 User ID</div>
                          <div id="userIdSubtitle" style="font-size: 12px; color: var(--text-secondary); margin-top: 6px;">
                            请在快捷指令的文本框中填入此 ID:
              </div>
                          <div style="background: var(--bg-app); padding: 8px 12px 8px 12px; border-radius: var(--radius-s); margin: 6px 0; display: flex; align-items: center; justify-content: space-between;">
                            <div style="font-family: 'SF Mono', monospace; font-size: 12px; overflow-x: auto; white-space: nowrap; margin-right: 8px; -webkit-overflow-scrolling: touch; scrollbar-width: none; color: var(--text-secondary); user-select: text;">
                              <span id="displayUserId">正在获取...</span>
                </div>
                            <button id="copyUserIdBtn" class="icon-btn" style="width: 24px; height: 24px; flex-shrink: 0;" title="复制 User ID">
                              <svg class="svg-icon" style="width: 14px; height: 14px;" viewBox="0 0 24 24"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                            </button>
                  </div>
                </div>
                  </div>
        </div>

      </div>
    </div>
  </div>

  <!-- Toast -->
  <div id="toast" class="toast">
    <div class="toast-icon"></div>
    <span class="toast-message"></span>
  </div>

  <!-- Logic Script (Preserved) -->
  <script>
    // ========================================
    // Google Drive 模式开关（默认启用）
    // ========================================
    const ENABLE_GOOGLE_DRIVE = true;
    const ENABLE_ALIYUN = false;
    
    const SERVER_URL = 'ws://localhost:8888';
    const connectionId = 'sync-session-1';
    
    let ws = null;
    let screenshotCount = 0;
    let manualDragCount = 0;
    let skippedFilesSet = new Set(); // 用于去重
    let heartbeatTimer = null;
    let updateCheckTimer = null; // 定期检查更新的定时器
    let isManualSyncing = false; // 防止手动同步重复点击的标志
    let currentMode = null;
    let currentSyncMode = null;
    let serverInstallPath = null;
    let isMinimized = false;
    let gifBackupCount = 0;
    let currentPluginVersion = null; // 当前插件版本（初始为 null，等待 code.js 返回真实版本）
    let latestPluginVersion = null; // 最新版本
    let pluginUpdateUrl = null; // 更新下载地址
    let dismissedPluginVersion = null; // 用户点击"稍后"后记录的版本
    let dismissedServerVersion = null; // 用户点击"稍后"后记录的服务器版本
    let pendingPluginUpdateInfo = null; // 暂存的插件更新信息（等待版本信息到达后处理）
    
    // 配置：定期检查更新的间隔（毫秒）
    const UPDATE_CHECK_INTERVAL = 60 * 60 * 1000; // 1小时检查一次
    
    // 日志配置：设为 false 可减少 Figma 控制台日志（降低 Datadog 警告）
    const ENABLE_CONSOLE_LOG = false; // 生产环境建议设为 false

    // ========== 日志函数 ==========
    function log(msg) {
      // 只在开发模式下输出到控制台，减少 Datadog 数据量
      if (ENABLE_CONSOLE_LOG) {
        console.log(msg);
      }
      const logEl = document.getElementById('log');
      const time = new Date().toLocaleTimeString();
      logEl.innerHTML = `[${time}] ${msg}\n` + logEl.innerHTML;

      const lines = logEl.innerText.split('\n');
      if (lines.length > 200) {
        logEl.innerText = lines.slice(0, 200).join('\n');
      }
    }

    // ========== WebSocket连接 ==========
    // 重新连接功能（包含自动修复）
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 3;
    
    function attemptReconnect() {
      reconnectAttempts++;
      log(`🔄 尝试重新连接 (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
      updateStatus('waiting', '正在连接');
      
      // 🔧 关键修复：清理心跳定时器，防止干扰
      if (heartbeatTimer) {
        clearInterval(heartbeatTimer);
        heartbeatTimer = null;
        log('   已清理心跳定时器');
      }
      
      // 🔧 关键修复：增加等待时间，确保旧连接完全释放（从 500ms 增加到 1500ms）
      setTimeout(() => {
        connect();
        
        // 检查连接是否成功（增加检查时间从 2s 到 3s）
        setTimeout(() => {
          if (!ws || ws.readyState !== WebSocket.OPEN) {
            // 连接失败，尝试修复服务
            if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
              log('⚠️ 连接失败，尝试修复服务...');
              repairServerConnection();
            } else {
              log('❌ 多次重连失败');
              updateStatus('disconnected', '连接失败');
              showToast('连接失败，请检查服务器状态', 'error');
              reconnectAttempts = 0; // 重置计数
            }
          } else {
            // 连接成功，重置计数
            reconnectAttempts = 0;
            log('✅ 重新连接成功');
            showToast('已重新连接', 'success');
          }
        }, 3000);
      }, 1500);
    }
    
    // 修复服务器连接（后端自动修复）
    function repairServerConnection() {
      log('🔧 正在尝试修复服务器...');
      
      // 使用 iframe 触发后端修复脚本（通过 Figma plugin API）
      parent.postMessage({
        pluginMessage: {
          type: 'repair-server',
          installPath: serverInstallPath
        }
      }, '*');
      
      // 等待5秒后再次尝试连接
      setTimeout(() => {
        log('🔄 修复完成，重新尝试连接...');
        connect();
        
        setTimeout(() => {
          if (!ws || ws.readyState !== WebSocket.OPEN) {
            if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
              attemptReconnect();
            } else {
              log('❌ 修复失败，请手动检查');
              updateStatus('disconnected', '修复失败');
              showToast('自动修复失败，请查看文档', 'error');
              reconnectAttempts = 0;
            }
          } else {
            reconnectAttempts = 0;
            log('✅ 修复成功，服务已连接');
            showToast('服务已修复并重新连接', 'success');
          }
        }, 2000);
      }, 5000);
    }

    function connect() {
      // 不要在连接开始时立即更新status，避免重连时频繁切换
      // 只有在真正连接成功后才更新status
      
      // 🔧 关键修复：在创建新连接之前，彻底关闭旧连接
      if (ws) {
        try {
          log('🧹 清理旧连接...');
          // 移除所有事件监听器，防止触发 onclose 导致自动重连
          ws.onopen = null;
          ws.onmessage = null;
          ws.onerror = null;
          ws.onclose = null;
          
          // 如果连接还未完全关闭，强制关闭
          if (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) {
            ws.close();
            log('   已关闭旧 WebSocket 连接');
          }
          
          ws = null;
        } catch (error) {
          log('   ⚠️ 关闭旧连接时出错: ' + error.message);
          ws = null;
        }
      }

      ws = new WebSocket(SERVER_URL + '?id=' + connectionId + '&type=figma');

      ws.onopen = function () {
        log('✅ 已连接');
        // 所有模式统一显示"已连接"
        updateStatus('connected', '已连接');

        if (ws.readyState === 1) {
          // 注册插件实例（用于单实例限制）
          ws.send(JSON.stringify({ 
            type: 'register-instance',
            connectionId: connectionId,
            timestamp: Date.now()
          }));
          
          ws.send(JSON.stringify({ type: 'get-sync-mode' }));
          ws.send(JSON.stringify({ type: 'get-server-info' }));
          // 自动检测更新（不需要打开设置）
          ws.send(JSON.stringify({ type: 'check-update' }));
        }
        
        if (heartbeatTimer) clearInterval(heartbeatTimer);
        heartbeatTimer = setInterval(function () {
          if (ws.readyState === 1) {
            ws.send(JSON.stringify({ type: 'ping' }));
          }
        }, 5000);
        
        // 启动定期检查更新（每小时检查一次）
        if (updateCheckTimer) clearInterval(updateCheckTimer);
        updateCheckTimer = setInterval(function () {
          if (ws.readyState === 1) {
            console.log('🔄 定期检查更新...');
            ws.send(JSON.stringify({ type: 'check-update' }));
          }
        }, UPDATE_CHECK_INTERVAL);
        
        console.log(`⏰ 已启动定期更新检查，间隔: ${UPDATE_CHECK_INTERVAL / 1000 / 60} 分钟`);
      };

      ws.onmessage = function (event) {
        var data = JSON.parse(event.data);
        if (data.type === 'pong') { return; }

        // 处理强制关闭（单实例限制）
        if (data.type === 'force-close') {
          log('⚠️  检测到您在其他文件中打开了插件，当前插件将自动关闭');
          // 延迟 2 秒关闭，让用户看到提示
          setTimeout(() => {
            parent.postMessage({
              pluginMessage: { type: 'close-plugin' }
            }, '*');
          }, 2000);
          return;
        }

        if (data.type === 'server-info') {
          if (data.path) {
            serverInstallPath = data.path;
            
            // 保存路径到本地存储
            parent.postMessage({
              pluginMessage: {
                type: 'save-server-path',
                path: data.path
              }
            }, '*');

            const pathEl = document.getElementById('server-path-placeholder');
            if (pathEl) {
              pathEl.textContent = serverInstallPath;
              // 移除占位符的特殊样式，使用普通文本样式
              pathEl.style.color = 'inherit';
            }
          }
        } else if (data.type === 'screenshot') {
          if (data.backedUpLocally || data.keptInIcloud) {
             gifBackupCount++;
             updateStatus('connected', '');
          }
          handleScreenshot(data);
        } else if (data.type === 'file-skipped') {
          // 确定原因文本
          let reasonText = '未知原因';
          if (data.reason === 'mp4' || data.reason === 'video') {
            const ext = (data.filename || '').toLowerCase();
            if (ext.endsWith('.mov')) {
              reasonText = 'MOV视频';
            } else {
              reasonText = 'MP4视频';
            }
          } else if (data.reason === 'gif-too-large') {
            reasonText = 'GIF过大';
          }

          // 去重检查：如果文件名已存在，则不增加计数，也不显示重复的日志
          if (!skippedFilesSet.has(data.filename)) {
            skippedFilesSet.add(data.filename);
            manualDragCount++;
            log(`⚠️  ${data.filename} 需手动导入（${reasonText}）`);
          }
          
          // 即使重复，也尝试发送确认消息以确保后台状态同步（可选，但为了保险起见）
          if (ws && ws.readyState === WebSocket.OPEN) {
            try {
              ws.send(JSON.stringify({
                type: 'screenshot-failed',
                filename: data.filename,
                error: reasonText,
                keepFile: true
              }));
            } catch (error) {
              console.error('发送失败消息失败:', error);
            }
          }
          updateStatus('connected', '');
        } else if (data.type === 'manual-sync-complete') {
          // 恢复同步按钮状态
          const syncBtn = document.getElementById('syncBtn');
          if (syncBtn) {
            // 清除超时定时器
            if (syncBtn.dataset.syncTimeout) {
              clearTimeout(parseInt(syncBtn.dataset.syncTimeout));
              delete syncBtn.dataset.syncTimeout;
            }
            
            // 重置标志和按钮状态
            isManualSyncing = false;
            syncBtn.disabled = false;
            syncBtn.textContent = '立即同步';
          }
          
          // 检查连接状态，只有在连接时才更新status
          if (!ws || ws.readyState !== 1) {
            updateStatus('disconnected', '连接断开');
            return;
          }
          
          // 检查是否有真正的错误消息（如用户文件夹未初始化、网络错误等）
          // 注意：如果 total === 0 且没有 message，说明是文件夹为空，这是正常情况，不是错误
          if (data.message && data.total === 0 && data.count === 0) {
            log(`❌ ${data.message}`);
            // 根据不同的错误消息给出友好提示
            if (data.message.includes('未初始化') || data.message.includes('未连接')) {
              alert(`同步失败：${data.message}\n\n💡 建议：\n1. 确保服务器正在运行\n2. 先在手机端上传至少一个文件\n3. 等待几秒后重试\n4. 如仍无法解决，请重启服务器`);
            } else {
              alert(`同步失败：${data.message}`);
            }
            updateStatus('connected', '同步失败');
            return;
          }
          
          if (manualDragCount > 0) {
            log(`⚠️  有 ${manualDragCount} 个文件需手动导入`);
            updateStatus('connected', '');
             return;
          }
          
          // 优化后的逻辑：支持显示部分失败和具体错误详情
          if (data.total === 0) {
            // 没有文件，但不是错误（message 为空）
            log('✅ 同步完成：0 张截图（文件夹为空）');
            updateStatus('connected', '同步完成');
          } else if (data.count === data.total) {
            // 全部成功
            log(`✅ 同步完成：全部 ${data.count} 张截图`);
            if (gifBackupCount > 0) {
              updateStatus('connected', '');
            } else {
              updateStatus('connected', '同步完成');
            }
          } else {
            // 部分或全部失败
            const failed = data.total - data.count;
            if (data.count > 0) {
               log(`⚠️  同步完成，但有 ${failed} 张失败 (成功 ${data.count}/${data.total})`);
            } else {
               log(`⚠️  同步失败，${data.total} 张全部处理失败`);
            }
            
            // 显示详细错误信息
            if (data.errors && data.errors.length > 0) {
              log(`🔍 错误详情:`);
              data.errors.slice(0, 5).forEach(err => {
                log(`   ❌ ${err.filename}: ${err.error}`);
              });
              if (data.errors.length > 5) {
                log(`   ... 以及其他 ${data.errors.length - 5} 个错误`);
              }
              
              // 延迟弹窗显示第一个错误，帮助调试
              setTimeout(() => {
                const firstErr = data.errors[0];
                alert(`❌ 截图处理失败\n\n文件名: ${firstErr.filename}\n错误信息: ${firstErr.error}\n\n请将此错误信息截图发给开发者。`);
              }, 200);
            } else {
              log(`   ❌ 未知错误 (无详细信息)`);
            }
            updateStatus('connected', '同步完成');
          }
        } else if (data.type === 'sync-mode-changed') {
          currentSyncMode = data.mode;
          updateSyncModeDisplay();
          if (checkQRCodeVisibility()) {
          updateQRCodeDisplay();
          }
          log('✅ 储存方式已切换');
        } else if (data.type === 'gif-compose-progress') {
          // 处理服务器推送的真实进度
          if (data.progress) {
             updateRealProgress(data.progress, data.message);
          }
        } else if (data.type === 'gif-compose-success') {
          // Update Progress
          console.log('✅ 收到服务器成功响应');
          console.log('   输出路径:', data.outputPath);
          console.log('   完成数量:', completedExports + 1, '/', totalExports);
          handleExportSuccess();
        } else if (data.type === 'gif-compose-error') {
          // Update Progress (count as done but failed)
          console.error('❌ 收到服务器错误响应');
          console.error('   错误消息:', data.message || data.error || '未知错误');
          console.error('   完整错误详情:', data.details || '无');
          handleExportError();
          // 只在 toast 显示简短错误提示，详细信息在 console
          showToast('导出失败，请查看控制台了解详情', 'error');
        } else if (data.type === 'gif-compose-cancelled') {
          // 处理取消确认消息
          console.log('🛑 收到服务器取消确认');
          // UI 已经在 cancelGifExport 中处理了重置，这里不需要额外操作
        } else if (data.type === 'sync-mode-info') {
          currentSyncMode = data.mode;
          updateSyncModeDisplay();
          // 如果设置界面是打开的，确保立即更新显示
          if (settingsOverlay && settingsOverlay.classList.contains('show')) {
            // updateSyncModeDisplay() 已经在上面的调用中更新了，这里不需要再次调用
            // 但可以确保显示是最新的
          }
          if (checkQRCodeVisibility()) {
            updateQRCodeDisplay();
          }
        } else if (data.type === 'switch-sync-mode-result') {
          if (data.success) {
            // 简化消息：从"储存方式已切换为 XXX"改为"已切换为 XXX方式"
            let modeName = '未知模式';
            if (data.mode === 'drive' || data.mode === 'google') {
              modeName = 'Google Drive';
            } else if (data.mode === 'aliyun' || data.mode === 'oss') {
              modeName = '阿里云';
            } else if (data.mode === 'icloud') {
              modeName = 'iCloud';
            }
            showToast('切换至 ' + modeName + ' 模式', 'success');
            currentSyncMode = data.mode;
            updateSyncModeDisplay();
            if (useCaseOverlay && useCaseOverlay.classList.contains('show')) {
              updateQRCodeDisplay();
            }
            
            stopRealtimeSync();
            showModeSelection();
            
            setTimeout(() => {
              closeSettings();
            }, 2000);
          } else {
            // 如果是空间不足错误，显示特定的错误消息
            if (data.isSpaceError) {
              showToast('iCloud 无空间', 'error');
            } else {
              showToast(data.message || '切换失败', 'error');
            }
          }
        } else if (data.type === 'user-id-info') {
            const el = document.getElementById('displayUserId');
            if (el) el.textContent = data.userId || '未知';
        } else if (data.type === 'gif-backup-setting-info' || data.type === 'gif-backup-setting-updated') {
          if (gifBackupToggle) {
            gifBackupToggle.checked = !!data.enabled;
            // 同时更新 originalSettings 以保持状态一致
            originalSettings.backupGif = !!data.enabled;
          }
        } else if (data.type === 'keep-gif-in-icloud-setting-info' || data.type === 'keep-gif-in-icloud-setting-updated') {
          if (keepGifInIcloudToggle) {
            keepGifInIcloudToggle.checked = !!data.enabled;
            // 同时更新 originalSettings 以保持状态一致
            originalSettings.keepGifInIcloud = !!data.enabled;
          }
        } else if (data.type === 'plugin-update-info') {
          // 处理插件更新信息
          handlePluginUpdateInfo(data);
        } else if (data.type === 'server-update-info') {
          // 处理服务器更新信息
          handleServerUpdateInfo(data);
        } else if (data.type === 'plugin-version-info') {
          // 处理插件版本信息
          handlePluginVersionInfo(data);
        } else if (data.type === 'plugin-update-progress') {
          // 处理插件更新进度（已废弃，兼容旧版）
          handleUpdateProgress(data);
        } else if (data.type === 'server-update-progress') {
          // 处理服务器更新进度（已废弃，兼容旧版）
          handleUpdateProgress(data);
        } else if (data.type === 'update-progress') {
          // 处理统一更新进度
          handleUpdateProgress(data);
        }
      };

      ws.onerror = function () {
        log('❌ 连接失败');
        // 只有在当前显示连接状态时才更新为断开
        const statusEl = document.getElementById('status');
        if (statusEl && (statusEl.classList.contains('connected') || statusEl.textContent.includes('已连接') || statusEl.textContent.includes('运行中'))) {
        updateStatus('disconnected', '连接失败');
        }
        // 重置同步标志，防止按钮永久禁用
        isManualSyncing = false;
      };

      ws.onclose = function () {
        log('⚠️ 连接断开，正在重连');
        // 使用 'waiting' 状态显示"正在连接"，给用户自动连接的反馈
        updateStatus('waiting', '正在连接');
        
        if (heartbeatTimer) clearInterval(heartbeatTimer);
        if (updateCheckTimer) clearInterval(updateCheckTimer); // 清除更新检查定时器
        // 重置同步标志，防止按钮永久禁用
        isManualSyncing = false;
        setTimeout(connect, 2000); // 缩短重连间隔到 2 秒，体验更流畅
      };
    }

    let currentFileId = null;
    let currentFileIdType = null;
    let currentFileBackedUp = false;

    function handleScreenshot(data) {
      log(`📸 ${data.filename || '截图'}`);
      currentFileId = data.ossFileId || data.driveFileId || null;
      currentFileIdType = data.ossFileId ? 'oss' : (data.driveFileId ? 'drive' : null);
      // 检查文件是否已备份（Google Drive）或保留（iCloud）
      currentFileBackedUp = data.backedUpLocally || data.keptInIcloud || false;

      try {
      parent.postMessage({
        pluginMessage: {
          type: 'add-screenshot',
          bytes: data.bytes,
          timestamp: data.timestamp,
          filename: data.filename,
          driveFileId: data.driveFileId,
          ossFileId: data.ossFileId
        }
      }, '*');
      } catch (error) {
        log('❌ 处理失败: ' + error.message);
        console.error('发送失败:', error);
        
        // 如果发送到 Figma 失败（例如消息过大），但已经备份到本地
        // 那么我们也应该通知服务器可以删除云端文件，因为本地已经有了
        if (currentFileBackedUp) {
          log('⚠️  发送到 Figma 失败，但文件已备份到本地，确认删除云端文件');
          showToast('Figma 导入失败，已保存到本地', 'warning');
          
          if (ws && ws.readyState === WebSocket.OPEN) {
            if (currentFileId) {
              try {
                const confirmMessage = {
                  type: 'screenshot-received',
                  filename: data.filename || '未命名文件',
                  timestamp: Date.now()
                };
                if (currentFileIdType === 'oss') confirmMessage.ossFileId = currentFileId;
                else if (currentFileIdType === 'drive') confirmMessage.driveFileId = currentFileId;
                ws.send(JSON.stringify(confirmMessage));
                
                // Reset
                currentFileId = null;
                currentFileIdType = null;
                currentFileBackedUp = false;
              } catch (sendError) {
                console.error('❌ 发送确认失败:', sendError);
              }
            }
          }
        }
      }
    }

    function updateStatus(type, text) {
      const statusEl = document.getElementById('status');

      // 如果尝试设置为 connected 状态，但实际连接已断开，则改为 disconnected
      if (type === 'connected' && (!ws || ws.readyState !== WebSocket.OPEN)) {
        type = 'disconnected';
        if (!text || text === '') {
          text = '连接断开';
        }
      }

      statusEl.className = 'connection-pill'; // Reset to base class
      statusEl.style.cursor = 'default';
      statusEl.onclick = null;
      statusEl.style.display = ''; // Reset display style (flex/block etc handled by class usually, but disconnected sets explicit flex)
      
      // 1. Highest Priority: Disconnected
      // 特殊处理：disconnected 状态显示为可点击的"重新连接"按钮
      if (type === 'disconnected') {
        // 纯线条重试图标，双箭头循环风格（更平衡居中），无背景，视觉更轻盈
        statusEl.innerHTML = `
          <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0;">
            <path d="M23 4v6h-6"></path>
            <path d="M1 20v-6h6"></path>
            <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
          </svg>
          <span>点击重连</span>
        `;
        statusEl.className = 'connection-pill reconnect';
        statusEl.style.cursor = 'pointer';
        statusEl.style.display = 'flex';
        statusEl.style.alignItems = 'center';
        statusEl.onclick = function() {
          attemptReconnect();
        };
        return;
      }

      // 2. Priority 1: Manual Import (Blocking)
      // 只要 manualDragCount > 0，就强制显示此状态，直到用户点击
      if (manualDragCount > 0) {
        const warningText = `需手动导入 ${manualDragCount} 段视频`;
        statusEl.innerHTML = `${warningText} <svg width="7" height="14" viewBox="7 0 14 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="opacity: 0.8;"><polyline points="9 18 15 12 9 6"></polyline></svg>`;
        // 使用蓝色 connected 样式，而不是黄色的 waiting
        statusEl.className = 'connection-pill connected';
        statusEl.style.cursor = 'pointer';
        statusEl.onclick = function() {
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'open-local-folder' }));
          }
          // 点击后清除计数，解除阻塞，允许后续状态显示
          manualDragCount = 0;
          // 立即刷新状态为正常连接
          updateStatus('connected', '已连接');
        };
        return; // 阻止后续状态更新
      }

      // 3. Priority 2: Saved GIFs (Blocking)
      // 只要 gifBackupCount > 0，就强制显示此状态，直到用户点击
      if (gifBackupCount > 0) {
        // 根据当前模式显示不同的文案
        const actionText = (currentSyncMode === 'icloud') ? '已保留' : '已保存';
        const backupText = `${actionText} ${gifBackupCount} 段 GIF`;
        statusEl.innerHTML = `${backupText} <svg width="7" height="14" viewBox="7 0 14 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="opacity: 0.8;"><polyline points="9 18 15 12 9 6"></polyline></svg>`;
        statusEl.className = 'connection-pill connected';
        statusEl.style.cursor = 'pointer';
        statusEl.onclick = function() {
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'open-local-folder' }));
          }
          // 点击后清除计数，解除阻塞
          gifBackupCount = 0;
          // 立即刷新状态
          updateStatus('connected', '已连接');
        };
        return; // 阻止后续状态更新
      }

      // 4. Priority 3: Normal Status Updates
      if (text && text !== '') {
        statusEl.textContent = text;
        if(type === 'connected') statusEl.classList.add('connected');
        else if(type === 'waiting') statusEl.classList.add('waiting');
      } else {
        statusEl.textContent = '已连接'; // 默认文案
        statusEl.classList.add('connected');
      }
    }

    function showWorkArea(mode) {
      currentMode = mode;
      document.getElementById('modeSelection').classList.add('hidden');
      document.getElementById('workArea').classList.add('active');
      
      collapseLog();
      
      const activeModeIcon = document.getElementById('activeModeIcon');
      const activeModeTitle = document.getElementById('activeModeTitle');

      if (mode === 'realtime') {
        // Realtime Mode Setup
        activeModeIcon.style.color = '#FFCC00';
        activeModeIcon.style.background = 'rgba(255, 204, 0, 0.15)';
        activeModeIcon.innerHTML = `<svg width: 12px; height: 12px; viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linejoin="round"><path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"></path></svg>`;
        activeModeTitle.textContent = '实时模式';
        document.getElementById('modeSubtitle').textContent = '监听中...';

        document.getElementById('syncBtn').style.display = 'none';
        document.getElementById('stopBtn').style.display = 'flex';
        document.getElementById('infoBox').style.display = 'none';

        if (ws && ws.readyState === 1) {
          ws.send(JSON.stringify({ type: 'start-realtime' }));
          log('⚡ 实时同步已启动');
          updateStatus('connected', '已连接');
        } else {
          // 如果未连接，显示连接断开状态
          updateStatus('disconnected', '连接断开');
        }
      } else {
        // Manual Mode Setup
        activeModeIcon.style.color = 'var(--accent)';
        activeModeIcon.style.background = 'var(--accent-soft)';
        activeModeIcon.innerHTML = `<svg style="width: 14px; height: 14px;" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="0"><path d="M19 9h-4V3H9v6H5l7 8 7-8zM5 19v3h14v-3H5z"></path></svg>`;
        activeModeTitle.textContent = '手动模式';
        document.getElementById('modeSubtitle').textContent = '准备同步';

        document.getElementById('syncBtn').style.display = 'flex';
        document.getElementById('stopBtn').style.display = 'none';
        document.getElementById('infoBox').style.display = 'none';
        
        // 只有在连接成功时才显示"已连接"
        if (ws && ws.readyState === 1) {
        updateStatus('connected', '已连接');
        } else {
          updateStatus('disconnected', '连接断开');
        }
      }
    }

    function showModeSelection() {
      if (currentMode === 'realtime' && ws && ws.readyState === 1) {
        ws.send(JSON.stringify({ type: 'stop-realtime' }));
        log('⏸️  实时同步已停止');
      }

      screenshotCount = 0;
      manualDragCount = 0;
      skippedFilesSet.clear();
      gifBackupCount = 0;
      isManualSyncing = false; // 重置手动同步标志
      document.getElementById('count').textContent = '0';
      
      currentMode = null;
      document.getElementById('workArea').classList.remove('active');
      document.getElementById('modeSelection').classList.remove('hidden');
      updateStatus('connected', '已返回模式选择');
    }

    document.getElementById('realtimeBtn').onclick = function () { showWorkArea('realtime'); };
    document.getElementById('manualBtn').onclick = function () { showWorkArea('manual'); };

    document.getElementById('syncBtn').onclick = function () {
      // 第一道防线：使用 JavaScript 标志变量（更快更可靠）
      if (isManualSyncing) {
        console.log('⚠️  同步正在进行中，请勿重复点击（标志阻止）');
        return;
      }
      
      const syncBtn = document.getElementById('syncBtn');
      
      // 第二道防线：检查按钮状态
      if (syncBtn.disabled) {
        console.log('⚠️  同步正在进行中，请勿重复点击（按钮已禁用）');
        return;
      }
      
      // 检查连接状态
      if (!ws || ws.readyState !== 1) {
        log('❌ 未连接');
        updateStatus('disconnected', '连接断开');
        return;
      }
      
      // 立即设置标志和禁用按钮（双重保护）
      isManualSyncing = true;
      syncBtn.disabled = true;
      syncBtn.textContent = '同步中';
      
      // 设置超时保护：如果 60 秒内没有收到响应，自动恢复按钮
      const syncTimeout = setTimeout(() => {
        if (isManualSyncing || syncBtn.disabled) {
          console.warn('⚠️  同步超时，自动恢复按钮状态');
          isManualSyncing = false;
          syncBtn.disabled = false;
          syncBtn.textContent = '立即同步';
          updateStatus('connected', '同步超时');
        }
      }, 60000);
      
      // 保存超时 ID，以便在收到响应时清除
      syncBtn.dataset.syncTimeout = syncTimeout;
      
      log('🫳🏻 开始同步...');
      updateStatus('connected', '正在同步');
      manualDragCount = 0;
      skippedFilesSet.clear();
      gifBackupCount = 0;
      
      // 发送同步请求
      try {
        ws.send(JSON.stringify({ type: 'manual-sync' }));
      } catch (error) {
        console.error('❌ 发送同步请求失败:', error);
        clearTimeout(syncTimeout);
        isManualSyncing = false; // 重置标志
        syncBtn.disabled = false;
        syncBtn.textContent = '立即同步';
        updateStatus('connected', '发送失败');
      }
    };

    document.getElementById('stopBtn').onclick = function() {
      stopRealtimeSync();
      showModeSelection(); 
    }

    function stopRealtimeSync() {
      // 无论当前模式是什么，只要 WebSocket 连接存在，就发送停止命令
      // 这样可以确保在关闭插件时，所有正在运行的监听都会被停止
      if (ws && ws.readyState === 1) {
        try {
        ws.send(JSON.stringify({ type: 'stop-realtime' }));
          log('⏸️  已停止同步监听');
        } catch (error) {
          console.error('停止同步监听失败:', error);
        }
      }
    }

    document.getElementById('locateFrameBtn').onclick = function () {
      parent.postMessage({ pluginMessage: { type: 'locate-frame' } }, '*');
    };

    document.getElementById('backBtn').onclick = function () { 
      stopRealtimeSync();
      showModeSelection(); 
    };

    function setQRCodeImages() {
      const qrGoogleScreenshot = document.getElementById('qrGoogleScreenshot');
      const qrGoogleAlbum = document.getElementById('qrGoogleAlbum');
      const qrIcloudScreenshot = document.getElementById('qrIcloudScreenshot');
      const qrIcloudAlbum = document.getElementById('qrIcloudAlbum');
      
      const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const uris = getQRCodeURI(isDark);
      
      if (qrGoogleScreenshot) qrGoogleScreenshot.src = uris.googleScreenshot || uris.google;
      if (qrGoogleAlbum) qrGoogleAlbum.src = uris.googleAlbum || uris.google;
      if (qrIcloudScreenshot) qrIcloudScreenshot.src = uris.icloudScreenshot || uris.icloud;
      if (qrIcloudAlbum) qrIcloudAlbum.src = uris.icloudAlbum || uris.icloud;
    }

    function setIdStepImages() {
      const idStep1Image = document.getElementById('idStep1Image');
      const idStep2Image = document.getElementById('idStep2Image');
      const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      
      if (idStep1Image) {
        idStep1Image.src = IMAGE_BASE_URL + (isDark ? 'id-step1-black.png' : 'id-step1-white.png');
      }
      if (idStep2Image) {
        idStep2Image.src = IMAGE_BASE_URL + (isDark ? 'id-step2-black.png' : 'id-step2-white.png');
      }
    }

    function updateIconColors() {
       const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
       const logoImg = document.querySelector('.logo-box img');
       const minimizedLogoImg = document.querySelector('.minimized-brand img');
       
       if (logoImg) {
         logoImg.src = IMAGE_BASE_URL + (isDark ? 'logo.svg' : 'logo.svg');
       }
       if (minimizedLogoImg) {
         minimizedLogoImg.src = IMAGE_BASE_URL + (isDark ? 'logo.svg' : 'logo.svg');
       }
    }

    function handleThemeChange() {
      setQRCodeImages();
      setIdStepImages();
      updateIconColors();
    }
    
    if (document.readyState === 'loading') {
      window.addEventListener('DOMContentLoaded', function() {
        handleThemeChange();
      });
    } else {
      handleThemeChange();
    }
    
    const themeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    themeMediaQuery.addEventListener('change', handleThemeChange);

    const viewUseCases = document.getElementById('viewUseCases');

    function updateQRCodeDisplay() {
      const qrGoogleScreenshotContainer = document.getElementById('qrGoogleScreenshotContainer');
      const qrGoogleAlbumContainer = document.getElementById('qrGoogleAlbumContainer');
      const qrIcloudScreenshotContainer = document.getElementById('qrIcloudScreenshotContainer');
      const qrIcloudAlbumContainer = document.getElementById('qrIcloudAlbumContainer');
      const googleDriveHint = document.getElementById('googleDriveHint');
      const qrCodesContainer = document.getElementById('qrCodesContainer');
      const userIdDisplaySection = document.getElementById('userIdDisplaySection');
      const noModeMessage = document.getElementById('noModeMessage');
      const qrSubtitle = document.getElementById('qrSubtitle');
      const shortcutGuideTitle = document.getElementById('shortcutGuideTitle');
      const userIdTitle = document.getElementById('userIdTitle');
      const userIdSubtitle = document.getElementById('userIdSubtitle');
      
      if (qrGoogleScreenshotContainer) qrGoogleScreenshotContainer.style.display = 'none';
      if (qrGoogleAlbumContainer) qrGoogleAlbumContainer.style.display = 'none';
      if (qrIcloudScreenshotContainer) qrIcloudScreenshotContainer.style.display = 'none';
      if (qrIcloudAlbumContainer) qrIcloudAlbumContainer.style.display = 'none';
      // if (googleDriveHint) googleDriveHint.style.display = 'none';
      if (userIdDisplaySection) userIdDisplaySection.style.display = 'none';
      if (noModeMessage) noModeMessage.style.display = 'none';
      if (qrSubtitle) qrSubtitle.style.display = 'none';
      if (qrCodesContainer) qrCodesContainer.style.display = 'none';
      if (userIdSubtitle) userIdSubtitle.style.display = 'none'; // Always hide original subtitles
      
      if (currentSyncMode === 'drive' && typeof ENABLE_GOOGLE_DRIVE !== 'undefined' && ENABLE_GOOGLE_DRIVE) {
        if (qrCodesContainer) qrCodesContainer.style.display = 'grid';
        if (qrGoogleScreenshotContainer) qrGoogleScreenshotContainer.style.display = 'flex';
        if (qrGoogleAlbumContainer) qrGoogleAlbumContainer.style.display = 'flex';
        
        if (userIdDisplaySection) userIdDisplaySection.style.display = 'block';
        
        // Google Mode Titles
        if (shortcutGuideTitle) shortcutGuideTitle.textContent = '01 扫码获取快捷指令';
        if (userIdTitle) userIdTitle.textContent = '02 将 User ID 填入指令的文本框中';
        
      } else if (currentSyncMode === 'icloud') {
        if (qrCodesContainer) qrCodesContainer.style.display = 'grid';
        if (qrIcloudScreenshotContainer) qrIcloudScreenshotContainer.style.display = 'flex';
        if (qrIcloudAlbumContainer) qrIcloudAlbumContainer.style.display = 'flex';
        
        // iCloud Mode Titles
        if (shortcutGuideTitle) shortcutGuideTitle.textContent = '扫码获取快捷指令';
      } else {
        // No mode selected or unknown mode
        if (noModeMessage) noModeMessage.style.display = 'block';
      }
    }

    // Tab Switching Logic
    const tabDesktop = document.getElementById('tabDesktop');
    const tabMobile = document.getElementById('tabMobile');
    const contentDesktop = document.getElementById('contentDesktop');
    const contentMobile = document.getElementById('contentMobile');

    let currentTab = 'desktop';
    
    function switchTab(tab) {
        if (tab === currentTab) return; // 如果已经是当前tab，不执行切换
        
        const isGoingRight = (currentTab === 'desktop' && tab === 'mobile');
        const oldContent = currentTab === 'desktop' ? contentDesktop : contentMobile;
        const newContent = tab === 'desktop' ? contentDesktop : contentMobile;
        
        // 更新tab按钮状态
        if (tab === 'desktop') {
            tabDesktop.classList.add('active');
            tabMobile.classList.remove('active');
        } else {
            tabDesktop.classList.remove('active');
            tabMobile.classList.add('active');
        }
        
        // 旧内容滑出
        oldContent.classList.add(isGoingRight ? 'slide-out-left' : 'slide-out-right');
        oldContent.classList.remove('active');
        
        // 等待旧内容滑出后，显示新内容
        setTimeout(() => {
            oldContent.style.display = 'none';
            oldContent.classList.remove('slide-out-left', 'slide-out-right');
            
            // 显示新内容
            newContent.style.display = 'block';
            newContent.classList.add(isGoingRight ? 'slide-in-right' : 'slide-in-left');
            
            // 在动画结束后清理动画类
            setTimeout(() => {
                newContent.classList.remove('slide-in-left', 'slide-in-right');
                newContent.classList.add('active');
            }, 300);
        }, 150); // 滑出动画的一半时间，实现交叉淡入淡出
        
        currentTab = tab;
        
        // Trigger QR updates when mobile tab is active
        if (tab === 'mobile') {
            updateQRCodeDisplay();
            if (ws && ws.readyState === 1) {
                if (!currentSyncMode) {
                    ws.send(JSON.stringify({ type: 'get-sync-mode' }));
                }
                ws.send(JSON.stringify({ type: 'get-user-id' }));
            }
        }
    }

    if (tabDesktop) tabDesktop.onclick = function() { switchTab('desktop'); };
    if (tabMobile) tabMobile.onclick = function() { switchTab('mobile'); };

    function openSettings(defaultTab = 'desktop') {
      if (isMinimized) toggleMinimize();
      
      // Request info
      if (ws && ws.readyState === 1) {
           ws.send(JSON.stringify({ type: 'get-sync-mode' }));
           ws.send(JSON.stringify({ type: 'get-user-id' }));
           // 请求 GIF 备份设置
           ws.send(JSON.stringify({ type: 'get-gif-backup-setting' }));
           ws.send(JSON.stringify({ type: 'get-keep-gif-in-icloud-setting' }));
      }
      parent.postMessage({ pluginMessage: { type: 'get-plugin-version' } }, '*');
      
      updateSyncModeDisplay();
      loadSizeSettings();
      loadLayoutSettings();
      
      // 初始化tab状态（无动画）
      currentTab = defaultTab;
      if (defaultTab === 'desktop') {
          tabDesktop.classList.add('active');
          tabMobile.classList.remove('active');
          contentDesktop.style.display = 'block';
          contentDesktop.classList.add('active');
          contentMobile.style.display = 'none';
          contentMobile.classList.remove('active');
      } else {
          tabDesktop.classList.remove('active');
          tabMobile.classList.add('active');
          contentDesktop.style.display = 'none';
          contentDesktop.classList.remove('active');
          contentMobile.style.display = 'block';
          contentMobile.classList.add('active');
          updateQRCodeDisplay();
      }
      
      settingsOverlay.classList.add('show');
    }

    viewUseCases.onclick = function() { openSettings('mobile'); };

    // Update QRCode display check to look for mobile tab
    function checkQRCodeVisibility() {
        return settingsOverlay.classList.contains('show') && tabMobile.classList.contains('active');
    }

    const settingsOverlay = document.getElementById('settingsOverlay');
    const openSettingsBtn = document.getElementById('openSettings');
    const settingsClose = document.getElementById('settingsClose');
    const switchToDrive = document.getElementById('switchToDrive');
    const switchToAliyun = document.getElementById('switchToAliyun');
    const switchToIcloud = document.getElementById('switchToIcloud');
    
    if (typeof ENABLE_GOOGLE_DRIVE !== 'undefined' && !ENABLE_GOOGLE_DRIVE) {
      if (switchToDrive) switchToDrive.style.display = 'none';
      // Hide others handled in updateQRCodeDisplay
    }
    
    if (typeof ENABLE_ALIYUN !== 'undefined' && !ENABLE_ALIYUN) {
      if (switchToAliyun) switchToAliyun.style.display = 'none';
    }
    
    const imageWidthInput = document.getElementById('imageWidthInput');
    const imageHeightInput = document.getElementById('imageHeightInput');
    const saveSizeSettingsBtn = document.getElementById('saveSizeSettings');
    const clearSizeSettingsBtn = document.getElementById('clearSizeSettings');
    const frameColumnsInput = document.getElementById('frameColumnsInput');
    const saveLayoutSettingsBtn = document.getElementById('saveLayoutSettings');
    const clearLayoutSettingsBtn = document.getElementById('clearLayoutSettings');
    const toggleMinimizeBtn = document.getElementById('toggleMinimize');
    const minimizeIcon = document.getElementById('minimizeIcon');
    const appRoot = document.querySelector('.app');
    
    const gifBackupSection = document.getElementById('gifBackupSection');
    const gifBackupToggle = document.getElementById('gifBackupToggle');
    const keepGifInIcloudSection = document.getElementById('keepGifInIcloudSection');
    const keepGifInIcloudToggle = document.getElementById('keepGifInIcloudToggle');

    // Save button (consolidated)
    const saveSettingsBtn = document.getElementById('globalSaveBtn');
    
    // Track original values to detect changes
    let originalSettings = {
      imageWidth: '',
      imageHeight: '',
      frameColumns: '',
      backupGif: false,
      keepGifInIcloud: false
    };
    
    // Track current values
    let currentSettings = {
      imageWidth: '',
      imageHeight: '',
      frameColumns: '',
      backupGif: false,
      keepGifInIcloud: false
    };
    
    // Check for changes and update save button state
    function checkSettingsChanges() {
      // Compare current inputs with original settings
      const widthChanged = imageWidthInput ? (imageWidthInput.value != originalSettings.imageWidth) : false;
      const heightChanged = imageHeightInput ? (imageHeightInput.value != originalSettings.imageHeight) : false;
      const columnsChanged = frameColumnsInput ? (frameColumnsInput.value != originalSettings.frameColumns) : false;
      
      let gifBackupChanged = false;
      const gifBackupToggle = document.getElementById('gifBackupToggle');
      // 检测 GIF 备份开关变更（只要元素存在且可见就检测，不依赖 currentSyncMode）
      if (gifBackupToggle && gifBackupToggle.offsetParent !== null) {
        gifBackupChanged = (gifBackupToggle.checked !== originalSettings.backupGif);
        currentSettings.backupGif = gifBackupToggle.checked;
      }
      
      let keepGifChanged = false;
      const keepGifInIcloudToggle = document.getElementById('keepGifInIcloudToggle');
      // 检测 iCloud GIF 保留开关变更（只要元素存在且可见就检测，不依赖 currentSyncMode）
      if (keepGifInIcloudToggle && keepGifInIcloudToggle.offsetParent !== null) {
        keepGifChanged = (keepGifInIcloudToggle.checked !== originalSettings.keepGifInIcloud);
        currentSettings.keepGifInIcloud = keepGifInIcloudToggle.checked;
      }
      
      const hasChanges = widthChanged || heightChanged || columnsChanged || gifBackupChanged || keepGifChanged;
      
      if (saveSettingsBtn) {
        if (hasChanges) {
          saveSettingsBtn.disabled = false;
          saveSettingsBtn.classList.remove('disabled');
        } else {
          saveSettingsBtn.disabled = true;
          saveSettingsBtn.classList.add('disabled');
        }
      }
      
      // Update current settings tracking for inputs
      if (imageWidthInput) currentSettings.imageWidth = imageWidthInput.value;
      if (imageHeightInput) currentSettings.imageHeight = imageHeightInput.value;
      if (frameColumnsInput) currentSettings.frameColumns = frameColumnsInput.value;
    }
    
    // Add event listeners to inputs
    if (imageWidthInput) imageWidthInput.addEventListener('input', checkSettingsChanges);
    if (imageHeightInput) imageHeightInput.addEventListener('input', checkSettingsChanges);
    if (frameColumnsInput) frameColumnsInput.addEventListener('input', checkSettingsChanges);
    
    if (gifBackupToggle) {
      gifBackupToggle.onchange = function() {
        checkSettingsChanges();
      };
    }
    
    if (keepGifInIcloudToggle) {
      keepGifInIcloudToggle.onchange = function() {
        checkSettingsChanges();
      };
    }
    
    function loadSizeSettings() {
      parent.postMessage({ pluginMessage: { type: 'get-size-settings' } }, '*');
    }
    
    // Consolidated save function
    function saveAllSettings() {
      if (!saveSettingsBtn || saveSettingsBtn.disabled) return;
      if (!imageWidthInput || !imageHeightInput || !frameColumnsInput) {
        console.error('Settings inputs not initialized');
        return;
      }
      
      const width = imageWidthInput.value.trim();
      const height = imageHeightInput.value.trim();
      const columns = frameColumnsInput.value.trim();
      
      if (width && (isNaN(width) || parseInt(width) <= 0)) {
        showToast('宽度必须是大于0的数字', 'error');
        return;
      }
      if (height && (isNaN(height) || parseInt(height) <= 0)) {
        showToast('高度必须是大于0的数字', 'error');
        return;
      }
      if (columns && (isNaN(columns) || parseInt(columns) <= 0)) {
        showToast('布局每行必须是大于0的数字', 'error');
        return;
      }
      
      // 1. Save Size Settings
      parent.postMessage({
        pluginMessage: {
          type: 'update-size-settings',
          width: width ? parseInt(width) : null,
          height: height ? parseInt(height) : null
        }
      }, '*');
      
      // 2. Save Layout Settings
      parent.postMessage({
        pluginMessage: {
          type: 'update-layout-settings',
          columns: columns ? parseInt(columns) : null
        }
      }, '*');
      
      // 3. Save GIF Backup Setting (if visible and changed)
      if (gifBackupToggle && gifBackupToggle.offsetParent !== null) {
        if (gifBackupToggle.checked !== originalSettings.backupGif) {
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
              type: 'update-gif-backup-setting',
              enabled: gifBackupToggle.checked
            }));
          } else {
            console.warn('⚠️ WebSocket 未连接，无法保存 GIF 备份设置');
          }
        }
      }
      
      // 4. Save Keep GIF in iCloud Setting (if visible and changed)
      if (keepGifInIcloudToggle && keepGifInIcloudToggle.offsetParent !== null) {
        if (keepGifInIcloudToggle.checked !== originalSettings.keepGifInIcloud) {
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
              type: 'update-keep-gif-in-icloud-setting',
              enabled: keepGifInIcloudToggle.checked
            }));
          } else {
            console.warn('⚠️ WebSocket 未连接，无法保存 iCloud GIF 保留设置');
          }
        }
      }
      
      // Update original settings to match current state (reset change detection)
      originalSettings.imageWidth = width;
      originalSettings.imageHeight = height;
      originalSettings.frameColumns = columns;
      if (gifBackupToggle) originalSettings.backupGif = gifBackupToggle.checked;
      if (keepGifInIcloudToggle) originalSettings.keepGifInIcloud = keepGifInIcloudToggle.checked;
      
      checkSettingsChanges();
      
      // Show success toast and close settings
      showToast('设置已保存', 'success');
      setTimeout(() => {
        closeSettings();
      }, 300);
    }
    
    if (saveSettingsBtn) {
      saveSettingsBtn.onclick = saveAllSettings;
    }
    
    function loadLayoutSettings() {
      parent.postMessage({ pluginMessage: { type: 'get-layout-settings' } }, '*');
    }
    
    function loadServerPath() {
      parent.postMessage({ pluginMessage: { type: 'get-server-path' } }, '*');
    }
    
    openSettingsBtn.onclick = function() {
      openSettings('desktop');
    };
    
    // 全局变量：跟踪待更新的类型
    let pendingUpdateType = null; // 'plugin' or 'server'
    let pendingUpdateData = {};
    
    // 处理插件更新信息
    function handlePluginUpdateInfo(data) {
      latestPluginVersion = data.latestVersion;
      pluginUpdateUrl = data.updateUrl;
      
      // 如果还没有收到真实的插件版本信息，暂存更新信息，等待版本信息到达后再处理
      if (currentPluginVersion === null) {
        console.log('⏳ 插件版本信息尚未到达，暂存更新信息');
        pendingPluginUpdateInfo = data;
        return;
      }
      
      // 比较版本号
      if (data.hasUpdate && compareVersions(latestPluginVersion, currentPluginVersion) > 0) {
        // 检查是否是用户已经点击"稍后"忽略的版本
        const shouldShow = !dismissedPluginVersion || compareVersions(latestPluginVersion, dismissedPluginVersion) > 0;
        
        if (shouldShow) {
          // 有新版本，且不是用户已忽略的版本，显示顶部通知条
          pendingUpdateType = 'plugin';
          pendingUpdateData = data;
          showUpdateBanner('plugin', currentPluginVersion, latestPluginVersion);
          console.log(`📢 发现新版本: v${currentPluginVersion} → v${latestPluginVersion}`);
        } else {
          console.log(`🔕 用户已忽略版本 v${dismissedPluginVersion}，不再显示`);
        }
      } else {
        console.log(`✅ 已是最新版本: v${currentPluginVersion}`);
      }
    }
    
    // 处理服务器更新信息
    function handleServerUpdateInfo(data) {
      if (data.hasUpdate) {
        // 检查是否是用户已经点击"稍后"忽略的版本
        const shouldShow = !dismissedServerVersion || compareVersions(data.latestVersion, dismissedServerVersion) > 0;
        
        if (shouldShow) {
          // 如果已经有插件更新待处理，服务器更新优先
          pendingUpdateType = 'server';
          pendingUpdateData = data;
          showUpdateBanner('server', data.currentVersion, data.latestVersion);
          console.log(`📢 发现新版本: v${data.currentVersion} → v${data.latestVersion}`);
        } else {
          console.log(`🔕 用户已忽略版本 v${dismissedServerVersion}，不再显示`);
        }
      }
    }
    
    // 显示顶部更新通知条（统一显示，不区分插件/服务器）
    function showUpdateBanner(componentName, currentVer, latestVer) {
      const banner = document.getElementById('updateBanner');
      const text = document.getElementById('updateBannerText');
      
      if (banner && text) {
        // 统一显示为"发现新版本 v版本号"
        text.textContent = `发现新版本 v${latestVer}`;
        banner.classList.add('show');
        
        // 如果当前未最小化，调整窗口高度以适应 Banner
        if (typeof isMinimized !== 'undefined' && !isMinimized) {
          parent.postMessage({
            pluginMessage: { type: 'resize', width: 360, height: 460 }
          }, '*');
        }
      }
    }
    
    // 隐藏顶部更新通知条
    function hideUpdateBanner() {
      const banner = document.getElementById('updateBanner');
      if (banner) {
        banner.classList.remove('show');
        // 确保样式被重置（配合最小化逻辑）
        banner.style.display = '';
        
        // 如果当前未最小化，恢复窗口高度
        if (typeof isMinimized !== 'undefined' && !isMinimized) {
          parent.postMessage({
            pluginMessage: { type: 'resize', width: 360, height: 400 }
          }, '*');
        }
      }
    }
    
    // 处理插件版本信息
    function handlePluginVersionInfo(data) {
      currentPluginVersion = data.version || '1.0.0';
      console.log('📦 当前插件版本:', currentPluginVersion);
      
      // 如果有暂存的更新信息，现在可以处理了
      if (pendingPluginUpdateInfo) {
        console.log('📦 处理暂存的插件更新信息');
        const tempData = pendingPluginUpdateInfo;
        pendingPluginUpdateInfo = null;
        handlePluginUpdateInfo(tempData);
      }
    }
    
    // 比较版本号（简单版本，支持 x.y.z 格式）
    function compareVersions(v1, v2) {
      const parts1 = v1.split('.').map(Number);
      const parts2 = v2.split('.').map(Number);
      const maxLength = Math.max(parts1.length, parts2.length);
      
      for (let i = 0; i < maxLength; i++) {
        const part1 = parts1[i] || 0;
        const part2 = parts2[i] || 0;
        if (part1 > part2) return 1;
        if (part1 < part2) return -1;
      }
      return 0;
    }
    
    // 处理统一更新进度（插件 + 服务器）
    function handleUpdateProgress(data) {
      const bannerBtn = document.getElementById('updateBannerNow');
      
      if (data.status === 'downloading') {
        showToast(data.message || '正在下载...', 'loading');
        if (bannerBtn) {
          bannerBtn.disabled = true;
          bannerBtn.textContent = '下载中...';
        }
        // 不修改 banner 主文字，保持"发现新版本 vX.X.X"
      } else if (data.status === 'installing') {
        showToast(data.message || '正在安装...', 'loading');
        if (bannerBtn) {
          bannerBtn.textContent = '安装中...';
        }
        // 不修改 banner 主文字
      } else if (data.status === 'completed') {
        const successMsg = data.message || `更新完成！已更新 ${data.updatedCount || 0} 个文件`;
        showToast(successMsg, 'success');
        
        // 隐藏更新通知条
        hideUpdateBanner();
        
        // 更新版本（如果提供）
        if (data.version) {
          currentPluginVersion = data.version.replace(/^v/, '');
        }
        
        // 清除待更新标记和忽略记录
        pendingUpdateType = null;
        pendingUpdateData = {};
        dismissedPluginVersion = null;
        dismissedServerVersion = null;
        
        // 3秒后提示用户重启插件
        setTimeout(() => {
          showToast('更新完成！请关闭并重新打开插件', 'success');
        }, 3000);
        
      } else if (data.status === 'error') {
        showToast(data.message || '更新失败', 'error');
        // 重置按钮状态，但保持 banner 主文字不变
        if (bannerBtn) {
          bannerBtn.disabled = false;
          bannerBtn.textContent = '立即更新';
        }
      }
    }
    
    // 保留旧函数名作为别名（兼容性）
    function handlePluginUpdateProgress(data) {
      handleUpdateProgress(data);
    }
    
    function handleServerUpdateProgress(data) {
      handleUpdateProgress(data);
    }
    
    // SVG Icons for Toast
    function getToastIcon(type) {
      if (type === 'success') {
        return '<svg viewBox="0 0 24 24" fill="none"><circle cx="12" cy="12" r="10" fill="currentColor"/><path d="M16.5 9.5l-5.5 5.5-3-3" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
      } else if (type === 'error') {
        return '<svg viewBox="0 0 24 24" fill="none"><circle cx="12" cy="12" r="10" fill="currentColor"/><path d="M12 8v5M12 16.5v.5" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
      } else if (type === 'loading') {
        return '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="animation: spin 1s linear infinite;"><circle cx="12" cy="12" r="10" stroke-dasharray="31.416" stroke-dashoffset="7.854" opacity="0.3"></circle><circle cx="12" cy="12" r="10" stroke-dasharray="31.416" stroke-dashoffset="23.562"></circle></svg>';
      }
      return '';
    }
    
    // Add spin animation for loading icon
    const style = document.createElement('style');
    style.textContent = '@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }';
    document.head.appendChild(style);
    
    function showToast(message, type = 'info') {
      const toast = document.getElementById('toast');
      if (!toast) return;
      
      const iconEl = toast.querySelector('.toast-icon');
      const messageEl = toast.querySelector('.toast-message');
      
      if (!iconEl || !messageEl) return;
      
      // Remove emoji and trailing ellipsis from message
      let cleanMessage = message
        .replace(/✅|❌|⏳|⚠️|📸|📍/g, '')
        .replace(/\.\.\./g, '')
        .trim();
      
      // Set icon
      if (type === 'success' || type === 'error' || type === 'loading') {
        iconEl.innerHTML = getToastIcon(type);
        iconEl.style.display = 'flex';
      } else {
        iconEl.innerHTML = '';
        iconEl.style.display = 'none';
      }
      
      // Set message
      messageEl.textContent = cleanMessage;
      messageEl.innerHTML = cleanMessage; // Allow HTML content
      
      // Set toast class
      toast.className = 'toast';
      if (type === 'success') {
        toast.classList.add('success');
      } else if (type === 'error') {
        toast.classList.add('error');
      } else if (type === 'loading') {
        toast.classList.add('loading');
      }
      
      // Show toast
      setTimeout(() => {
        toast.classList.add('show');
      }, 10);
      
      // Hide toast after 2 seconds
      setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
          iconEl.innerHTML = '';
          messageEl.textContent = '';
        }, 300);
      }, 2000);
    }

    function showToastWithAction(message, actionText, actionCallback) {
      const toast = document.getElementById('toast');
      if (!toast) return;
      
      const iconEl = toast.querySelector('.toast-icon');
      const messageEl = toast.querySelector('.toast-message');
      
      if (!iconEl || !messageEl) return;
      
      // Validate parameters
      if (!message || !actionText) {
        console.error('showToastWithAction: message or actionText is missing');
        return;
      }
      
      // Set success icon
      iconEl.innerHTML = getToastIcon('success');
      iconEl.style.display = 'flex';
      
      // Create message with action link
      messageEl.innerHTML = `${message} <span class="toast-action">${actionText}</span>`;
      
      // Add click handler to action link
      const actionLink = messageEl.querySelector('.toast-action');
      if (actionLink && actionCallback) {
        actionLink.onclick = (e) => {
          e.stopPropagation();
          actionCallback();
        };
      }
      
      // Set toast class
      toast.className = 'toast success';
      
      // Show toast
      setTimeout(() => {
        toast.classList.add('show');
      }, 10);
      
      // Hide toast after 3 seconds (longer for action)
      setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
          iconEl.innerHTML = '';
          messageEl.innerHTML = '';
        }, 300);
      }, 3000);
    }

    function closeSettings() {
      // Reset all inputs and toggles to original saved values
      // This discards any unsaved changes
      if (imageWidthInput) imageWidthInput.value = originalSettings.imageWidth || '';
      if (imageHeightInput) imageHeightInput.value = originalSettings.imageHeight || '';
      if (frameColumnsInput) frameColumnsInput.value = originalSettings.frameColumns || '';
      
      const gifBackupToggle = document.getElementById('gifBackupToggle');
      if (gifBackupToggle) gifBackupToggle.checked = originalSettings.backupGif || false;
      
      const keepGifInIcloudToggle = document.getElementById('keepGifInIcloudToggle');
      if (keepGifInIcloudToggle) keepGifInIcloudToggle.checked = originalSettings.keepGifInIcloud || false;
      
      // Reset change detection
      checkSettingsChanges();
      
      settingsOverlay.classList.remove('show');
    }

    function updateSyncModeDisplay() {
      const driveBtn = document.getElementById('switchToDrive');
      const aliyunBtn = document.getElementById('switchToAliyun');
      const icloudBtn = document.getElementById('switchToIcloud');
      
      if (driveBtn) driveBtn.style.display = (typeof ENABLE_GOOGLE_DRIVE !== 'undefined' && ENABLE_GOOGLE_DRIVE) ? 'flex' : 'none';
      
      const showGoogleDrive = (currentSyncMode === 'drive' && typeof ENABLE_GOOGLE_DRIVE !== 'undefined' && ENABLE_GOOGLE_DRIVE);
      const qrGoogleScreenshotContainer = document.getElementById('qrGoogleScreenshotContainer');
      const qrGoogleAlbumContainer = document.getElementById('qrGoogleAlbumContainer');
      const googleDriveHint = document.getElementById('googleDriveHint');

      if (qrGoogleScreenshotContainer) qrGoogleScreenshotContainer.style.display = showGoogleDrive ? 'flex' : 'none';
      if (qrGoogleAlbumContainer) qrGoogleAlbumContainer.style.display = showGoogleDrive ? 'flex' : 'none';
      // if (googleDriveHint) googleDriveHint.style.display = showGoogleDrive ? 'block' : 'none';
      
      if (aliyunBtn) aliyunBtn.style.display = (typeof ENABLE_ALIYUN !== 'undefined' && ENABLE_ALIYUN) ? 'flex' : 'none';
      
      // Use box-shadow for selected state instead of border color for better visibility on cards
      if (driveBtn) {
          driveBtn.style.borderColor = (currentSyncMode === 'drive') ? 'var(--accent)' : 'var(--border)';
          driveBtn.style.background = (currentSyncMode === 'drive') ? 'var(--bg-card-hover)' : 'var(--bg-card)';
          if (currentSyncMode === 'drive') driveBtn.classList.add('selected');
          else driveBtn.classList.remove('selected');
      }
      if (aliyunBtn) {
          aliyunBtn.style.borderColor = (currentSyncMode === 'aliyun' || currentSyncMode === 'oss') ? 'var(--accent)' : 'var(--border)';
          aliyunBtn.style.background = (currentSyncMode === 'aliyun' || currentSyncMode === 'oss') ? 'var(--bg-card-hover)' : 'var(--bg-card)';
          if (currentSyncMode === 'aliyun' || currentSyncMode === 'oss') aliyunBtn.classList.add('selected');
          else aliyunBtn.classList.remove('selected');
      }
      if (icloudBtn) {
          icloudBtn.style.borderColor = (currentSyncMode === 'icloud') ? 'var(--accent)' : 'var(--border)';
          icloudBtn.style.background = (currentSyncMode === 'icloud') ? 'var(--bg-card-hover)' : 'var(--bg-card)';
          if (currentSyncMode === 'icloud') icloudBtn.classList.add('selected');
          else icloudBtn.classList.remove('selected');
      }
      
      // Show/Hide GIF Backup Section (Google Drive Only)
      if (gifBackupSection) {
        if (currentSyncMode === 'drive' && typeof ENABLE_GOOGLE_DRIVE !== 'undefined' && ENABLE_GOOGLE_DRIVE) {
          gifBackupSection.style.display = 'block';
          // Request setting state when showing
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'get-gif-backup-setting' }));
          }
        } else {
          gifBackupSection.style.display = 'none';
        }
      }
      
      // Show/Hide Keep GIF in iCloud Section (iCloud Only)
      if (keepGifInIcloudSection) {
        if (currentSyncMode === 'icloud') {
          keepGifInIcloudSection.style.display = 'block';
          // Request setting state when showing
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'get-keep-gif-in-icloud-setting' }));
          }
        } else {
          keepGifInIcloudSection.style.display = 'none';
        }
      }
    }

    settingsClose.onclick = closeSettings;
    settingsOverlay.addEventListener('click', function (e) {
      if (e.target === settingsOverlay) closeSettings();
    });
    document.addEventListener('keydown', function (e) {
      if (e.key === 'Escape' && settingsOverlay.classList.contains('show')) {
        closeSettings();
      }
    });

    if (switchToDrive) {
      switchToDrive.onclick = function () {
        if (!ENABLE_GOOGLE_DRIVE) return;
        if (currentSyncMode === 'drive') return;
        
        showToast('正在切换', 'loading');
        if (ws && ws.readyState === 1) {
          ws.send(JSON.stringify({ type: 'switch-sync-mode', mode: 'drive' }));
        }
      };
    }

    if (switchToAliyun) {
      switchToAliyun.onclick = function () {
        if (typeof ENABLE_ALIYUN !== 'undefined' && !ENABLE_ALIYUN) return;
        if (currentSyncMode === 'aliyun') return;

        showToast('正在切换', 'loading');
        if (ws && ws.readyState === 1) {
          ws.send(JSON.stringify({ type: 'switch-sync-mode', mode: 'aliyun' }));
        }
      };
    }

    switchToIcloud.onclick = function () {
      if (currentSyncMode === 'icloud') return;
      showToast('正在切换', 'loading');
      if (ws && ws.readyState === 1) {
        ws.send(JSON.stringify({ type: 'switch-sync-mode', mode: 'icloud' }));
      }
    };

    function toggleMinimize() {
      isMinimized = !isMinimized;
      const currentIcon = document.getElementById('minimizeIcon');
      const updateBanner = document.getElementById('updateBanner');
      
      if (!currentIcon) return;
      
      if (isMinimized) {
        appRoot.classList.add('minimized');
        closeSettings(); // Use closeSettings to discard unsaved changes
        
        // 最小化时隐藏更新横幅
        // 检查 classList.contains('show') 因为这是主要的显示状态
        if (updateBanner && (updateBanner.classList.contains('show') || updateBanner.style.display === 'flex' || updateBanner.style.display === 'block')) {
          updateBanner.dataset.wasVisible = 'true';
          updateBanner.style.display = 'none';
        }
        
        // Toggle icon path to Maximize (No slash)
        toggleMinimizeBtn.setAttribute('title', '恢复');
        toggleMinimizeBtn.classList.add('no-tooltip'); // 禁用最大化按钮的 tooltip
        currentIcon.innerHTML = '<polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline>';
        
        parent.postMessage({
          pluginMessage: { type: 'resize', width: 130, height: 44 }
        }, '*');
      } else {
        appRoot.classList.remove('minimized');
        
        let isBannerVisible = false;
        // 恢复时显示更新横幅
        if (updateBanner && updateBanner.dataset.wasVisible === 'true') {
          updateBanner.style.display = ''; // 清除内联样式，让 CSS .show 生效
          delete updateBanner.dataset.wasVisible;
          isBannerVisible = true;
        } else if (updateBanner && updateBanner.classList.contains('show')) {
          // 如果没有 wasVisible 标记但有 .show 类（可能是逻辑边缘情况），也认为是显示的
          isBannerVisible = true;
        }
        
        // Toggle icon path to Minimize
        toggleMinimizeBtn.setAttribute('title', '最小化');
        toggleMinimizeBtn.classList.remove('no-tooltip'); // 恢复最小化按钮的 tooltip
        currentIcon.innerHTML = '<polyline points="4 14 10 14 10 20"></polyline><polyline points="20 10 14 10 14 4"></polyline>';
        
        // 根据是否有 Banner 调整窗口高度
        const height = isBannerVisible ? 460 : 400;
        parent.postMessage({
          pluginMessage: { type: 'resize', width: 360, height: height }
        }, '*');
      }
    }

    toggleMinimizeBtn.onclick = toggleMinimize;
    
    // 更新通知条按钮事件
    const updateBannerCloseBtn = document.getElementById('updateBannerClose');
    const updateBannerNowBtn = document.getElementById('updateBannerNow');
    
    if (updateBannerCloseBtn) {
      updateBannerCloseBtn.onclick = function() {
        // 记录用户忽略的版本，避免重复提示同一版本
        if (pendingUpdateType === 'plugin' && latestPluginVersion) {
          dismissedPluginVersion = latestPluginVersion;
          console.log(`🔕 用户关闭了插件更新提示 v${latestPluginVersion}`);
        } else if (pendingUpdateType === 'server' && pendingUpdateData.latestVersion) {
          dismissedServerVersion = pendingUpdateData.latestVersion;
          console.log(`🔕 用户关闭了服务器更新提示 v${pendingUpdateData.latestVersion}`);
        }
        
        hideUpdateBanner();
      };
    }
    
    if (updateBannerNowBtn) {
      updateBannerNowBtn.onclick = function() {
        // 禁用按钮防止重复点击
        updateBannerNowBtn.disabled = true;
        updateBannerNowBtn.textContent = '更新中...';
        
        // 统一全量更新（插件 + 服务器所有代码）
        if (ws && ws.readyState === 1) {
          // 发送统一更新请求
          ws.send(JSON.stringify({ type: 'update-full' }));
          console.log('📤 发送全量更新请求（插件 + 服务器）');
          
          // 不修改 banner 主文字，保持"发现新版本 vX.X.X"
          // 进度信息通过 handleUpdateProgress 处理（只修改按钮文字）
        } else {
          showToast('未连接到服务器', 'error');
          updateBannerNowBtn.disabled = false;
          updateBannerNowBtn.textContent = '立即更新';
        }
        
        // 注：已移除旧的分类更新逻辑（插件和服务器分开更新）
        // 现在统一使用 update-full 进行全量更新
      };
    }

    window.onmessage = function (event) {
      var msg = event.data.pluginMessage;
      if (!msg) return;

      if (msg.type === 'plugin-closing') {
        stopRealtimeSync();
      } else if (msg.type === 'export-batch-start') {
        // Start export flow
        totalExports = msg.total || 0;
        completedExports = 0;
        isExporting = true;
        
        console.log('🎬 开始批量导出，总数:', totalExports);
        
        // Add exporting class to button
        if (exportGifBtn) {
          exportGifBtn.classList.add("exporting");
          exportGifBtn.classList.remove("success");
          // 修改 tooltip 为停止导出
          exportGifBtn.setAttribute('data-tooltip', '停止导出 GIF');
        }
        
        if (totalExports > 0) {
          startSmoothProgress(); // Start smooth progress animation
        } else {
          console.warn('⚠️ totalExports 为 0 或 undefined');
        }
        
        // Reset button state
        const exportBtn = document.getElementById('exportGifBtn');
        if (exportBtn) {
            exportBtn.classList.remove('success');
        }
      } else if (msg.type === 'export-gif-error') {
        showToast(msg.error, 'error');
        // Reset button state
        stopSmoothProgress();
        const exportBtn = document.getElementById('exportGifBtn');
        if (exportBtn) {
            exportBtn.classList.remove('success');
            const ring = exportBtn.querySelector('.progress-ring');
            if (ring) ring.style.opacity = 0;
        }
        isExporting = false;
      } else if (msg.type === 'compose-annotated-gif') {
        // Forward message to server
        console.log('📨 UI 收到 compose-annotated-gif 消息');
        console.log('   Frame名称:', msg.frameName);
        console.log('   GIF数量:', msg.gifInfos ? msg.gifInfos.length : 0);
        if (msg.gifInfos) {
          msg.gifInfos.forEach((gif, idx) => {
            console.log(`      ${idx + 1}. ${gif.filename} @ (${gif.bounds.x}, ${gif.bounds.y})`);
          });
        }
        console.log('   批次:', `${msg.batchIndex + 1}/${msg.batchTotal}`);
        console.log('   WebSocket状态:', ws ? ws.readyState : 'ws is null');
        
        if (ws && ws.readyState === WebSocket.OPEN) {
          console.log('   ✅ WebSocket已连接，发送消息到服务器');
          ws.send(JSON.stringify(msg));
          console.log('   ✅ 消息已发送');
        } else {
          console.error('   ❌ WebSocket未连接，无法发送消息');
          showToast('未连接到服务器', 'error');
          // Reset button state
          const exportBtn = document.getElementById('exportGifBtn');
          if (exportBtn) {
              exportBtn.classList.remove('success');
              const ring = exportBtn.querySelector('.progress-ring');
              if (ring) ring.style.opacity = 0;
          }
          isExporting = false;
          stopSmoothProgress();
        }
      } else if (msg.type === 'frame-created') {
        log('✅ 画板已创建');
      } else if (msg.type === 'frame-located') {
        if (msg.success) log('📍 ' + msg.message);
        else log('❌ ' + msg.message);
      } else if (msg.type === 'screenshot-added') {
        if (msg.success) {
          screenshotCount++;
          document.getElementById('count').textContent = screenshotCount;
          
          if (ws && ws.readyState === WebSocket.OPEN) {
            // 优先使用 plugin 返回的 ID
            const driveFileId = msg.driveFileId || (currentFileIdType === 'drive' ? currentFileId : null);
            const ossFileId = msg.ossFileId || (currentFileIdType === 'oss' ? currentFileId : null);
            
            if (driveFileId || ossFileId) {
              try {
                const confirmMessage = {
                  type: 'screenshot-received',
                  filename: msg.filename || '未命名文件',
                  timestamp: Date.now()
                };
                if (ossFileId) confirmMessage.ossFileId = ossFileId;
                if (driveFileId) confirmMessage.driveFileId = driveFileId;
                
                ws.send(JSON.stringify(confirmMessage));
                
                if (!msg.driveFileId && !msg.ossFileId) {
                    currentFileId = null;
                    currentFileIdType = null;
                }
              } catch (error) {
                console.error('❌ 发送确认失败:', error);
              }
            }
          }
        } else {
          log('❌ 添加失败: ' + (msg.error || '未知错误'));
          
          // 如果添加失败，但已经备份到本地，也发送确认以删除云端文件
          if (currentFileBackedUp) {
            log('⚠️  导入 Figma 失败，但文件已备份到本地，确认删除云端文件');
            showToast('Figma 导入失败，已保存到本地', 'warning');
            
            if (ws && ws.readyState === WebSocket.OPEN) {
              // 优先使用 plugin 返回的 ID
              const driveFileId = msg.driveFileId || (currentFileIdType === 'drive' ? currentFileId : null);
              const ossFileId = msg.ossFileId || (currentFileIdType === 'oss' ? currentFileId : null);
              
              if (driveFileId || ossFileId) {
                try {
                  const confirmMessage = {
                    type: 'screenshot-received',
                    filename: msg.filename || '未命名文件',
                    timestamp: Date.now()
                  };
                  if (ossFileId) confirmMessage.ossFileId = ossFileId;
                  if (driveFileId) confirmMessage.driveFileId = driveFileId;
                  
                  ws.send(JSON.stringify(confirmMessage));
                  
                  // Reset
                  if (!msg.driveFileId && !msg.ossFileId) {
                      currentFileId = null;
                      currentFileIdType = null;
                  }
                  currentFileBackedUp = false;
                } catch (error) {
                  console.error('❌ 发送确认失败:', error);
                }
              }
            }
          }
        }
      } else if (msg.type === 'file-needs-manual-drag') {
        manualDragCount++;
        const reasonText = msg.reason === 'undefined-error' ? '导入失败' : '未知原因';
        log(`⚠️  ${msg.filename} 需手动导入`);
        
        if (ws && ws.readyState === WebSocket.OPEN) {
          try {
            const failMessage = {
              type: 'screenshot-failed',
              filename: msg.filename,
              error: msg.error || 'undefined错误',
               keepFile: true
            };
            
            const driveFileId = msg.driveFileId || (currentFileIdType === 'drive' ? currentFileId : null);
            const ossFileId = msg.ossFileId || (currentFileIdType === 'oss' ? currentFileId : null);
            
            if (ossFileId) failMessage.ossFileId = ossFileId;
            if (driveFileId) failMessage.driveFileId = driveFileId;
            
            ws.send(JSON.stringify(failMessage));
            
            if (!msg.driveFileId && !msg.ossFileId) {
                currentFileId = null;
                currentFileIdType = null;
            }
          } catch (error) {
            console.error('发送失败消息失败:', error);
          }
        }
        updateStatus('connected', '');
      } else if (msg.type === 'size-settings-loaded') {
        if (msg.width) imageWidthInput.value = msg.width;
        if (msg.height) imageHeightInput.value = msg.height;
      } else if (msg.type === 'size-settings-updated') {
        // Toast now handled by unified saveAllSettings function
        // No individual toast needed to avoid duplicates
      } else if (msg.type === 'layout-settings-loaded') {
        if (msg.columns) frameColumnsInput.value = msg.columns;
      } else if (msg.type === 'layout-settings-updated') {
        // Toast now handled by unified saveAllSettings function
        // No individual toast needed to avoid duplicates
      } else if (msg.type === 'server-path-loaded') {
        if (msg.path) {
          serverInstallPath = msg.path;
          const pathEl = document.getElementById('server-path-placeholder');
          if (pathEl) {
            pathEl.textContent = serverInstallPath;
            pathEl.style.color = 'inherit';
            console.log('✅ 已加载保存的服务器路径:', serverInstallPath);
          }
        }
      } else if (msg.type === 'plugin-version-info') {
        // 获取插件版本信息
        handlePluginVersionInfo(msg);
      }
    };

    const logContainer = document.getElementById('logContainer');
    const logHeader = document.getElementById('logHeader');
    const logToggleText = document.getElementById('logToggleText');

    function collapseLog() {
      logContainer.classList.add('collapsed');
      logToggleText.textContent = '展开';
    }

    function expandLog() {
      logContainer.classList.remove('collapsed');
      logToggleText.textContent = '收起';
    }

    logHeader.addEventListener('click', function () {
      const isCollapsed = logContainer.classList.contains('collapsed');
      if (isCollapsed) expandLog();
      else collapseLog();
    });

    connect();
    loadServerPath(); // 加载保存的服务器路径
    // 请求当前插件版本
    parent.postMessage({ pluginMessage: { type: 'get-plugin-version' } }, '*');

    // // 临时显示 Update Banner 用于调整样式（开发调试用）
    // setTimeout(() => {
    //   const banner = document.getElementById('updateBanner');
    //   const text = document.getElementById('updateBannerText');
    //   if (banner && text) {
    //     text.textContent = '发现新版本 v1.0.2';
    //     banner.classList.add('show');
    //     console.log('🎨 临时显示 Update Banner 用于样式调整');
    //   }
    // }, 500);

    window.addEventListener('beforeunload', function () {
      stopRealtimeSync();
    });
    
    
    // Copy User ID Logic
    const copyUserIdBtn = document.getElementById('copyUserIdBtn');
    if (copyUserIdBtn) {
      copyUserIdBtn.onclick = function() {
        const userIdEl = document.getElementById('displayUserId');
        if (!userIdEl) return;
        
        const userId = userIdEl.textContent.trim();
        if (!userId || userId === '正在获取...') {
          showToast('User ID 尚未获取', 'error');
          return;
        }
        
        const textArea = document.createElement("textarea");
        textArea.value = userId;
        document.body.appendChild(textArea);
        textArea.select();
        try {
          document.execCommand('copy');
          showToast('User ID 已复制', 'success');
        } catch (err) {
          showToast('复制失败', 'error');
        }
        document.body.removeChild(textArea);
      };
    }
      // ==========================================
    // Export GIF Logic
    // ==========================================
    
    let totalExports = 0;
    let completedExports = 0;
    let isExporting = false;
    let successTimer = null;
    let circumference = 0;
    let progressCircle = null;
    let progressRing = null;
    let exportGifBtn = null;
    let smoothProgressInterval = null;
    let currentSmoothProgress = 0;
    
    // 跟踪窗口焦点状态（用于判断是否显示 toast）
    let windowHasFocus = !document.hidden;
    
    // 监听窗口焦点和可见性变化
    window.addEventListener('focus', () => {
      windowHasFocus = true;
      console.log('🔍 窗口获得焦点');
    });
    
    window.addEventListener('blur', () => {
      windowHasFocus = false;
      console.log('🔍 窗口失去焦点');
    });
    
    document.addEventListener('visibilitychange', () => {
      windowHasFocus = !document.hidden;
      console.log('🔍 窗口可见性变化:', document.hidden ? '隐藏' : '可见');
    });

    // Initialize after DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
        exportGifBtn = document.getElementById("exportGifBtn");
        progressRing = exportGifBtn ? exportGifBtn.querySelector(".progress-ring") : null;
        progressCircle = exportGifBtn ? exportGifBtn.querySelector(".progress-ring__circle") : null;
        
        // Initialize Progress Ring
        if (progressCircle) {
            const radius = progressCircle.r.baseVal.value;
            circumference = radius * 2 * Math.PI;
            progressCircle.style.strokeDasharray = `${circumference} ${circumference}`;
            progressCircle.style.strokeDashoffset = circumference;
        }

        if (exportGifBtn) {
            exportGifBtn.onclick = () => {
                if (isExporting) {
                    // Cancel Export
                    console.log('🛑 用户取消导出');
                    cancelExport();
                } else {
                    // Start Export
                    parent.postMessage({ pluginMessage: { type: "export-annotated-gif" } }, "*");
                }
            };
        }
    });

    function setExportProgress(percent) {
        // Re-check elements if null (just in case)
        if (!progressCircle || !progressRing) {
             exportGifBtn = document.getElementById("exportGifBtn");
             progressRing = exportGifBtn ? exportGifBtn.querySelector(".progress-ring") : null;
             progressCircle = exportGifBtn ? exportGifBtn.querySelector(".progress-ring__circle") : null;
             if (progressCircle && circumference === 0) {
                 const radius = progressCircle.r.baseVal.value;
                 circumference = radius * 2 * Math.PI;
                 progressCircle.style.strokeDasharray = `${circumference} ${circumference}`;
             }
        }
        
        if (!progressCircle || !progressRing) return;
        
        const offset = circumference - (percent / 100) * circumference;
        progressCircle.style.strokeDashoffset = offset;
        progressRing.style.opacity = 1;
    }

    // 更新真实进度
    function updateRealProgress(percent, message) {
        // 如果有消息，可以更新状态文本（如果有状态显示区域的话）
        if (message) {
            console.log(`📊 进度 ${percent}%: ${message}`);
            // 可选：更新按钮文字显示当前状态
            if (exportGifBtn && !exportGifBtn.classList.contains('success')) {
               const btnText = exportGifBtn.querySelector('span');
               if (btnText) btnText.textContent = `导出中 ${percent}%`;
            }
        }

        // 基于当前批次进度的计算
        // 假设每个 GIF 的处理进度是独立的，这里我们主要关注当前的 percent
        // 但为了防止进度条倒退（当处理下一个 GIF 时），我们需要综合考虑
        
        // 简单策略：直接使用服务器返回的百分比作为当前目标
        // 但为了平滑，我们不直接 set，而是更新 target，让 smooth interval 去追赶
        
        // 实际上，服务器现在的进度是针对单个请求的。
        // 如果是批量导出，我们需要结合 completedExports 和 totalExports 来计算总进度
        // 总进度 = (已完成数量 * 100 + 当前正在处理的百分比) / 总数量
        
        let batchProgress = percent;
        if (totalExports > 1) {
            batchProgress = ((completedExports * 100) + percent) / totalExports;
        }
        
        // 确保进度不倒退
        if (batchProgress > currentSmoothProgress) {
             currentSmoothProgress = batchProgress;
             setExportProgress(currentSmoothProgress);
        }
    }

    // Smooth progress simulation for better UX
    // 现在主要作为"心跳"动画，防止用户以为卡死
    function startSmoothProgress() {
        if (smoothProgressInterval) clearInterval(smoothProgressInterval);
        
        // 初始进度
        currentSmoothProgress = 2;
        setExportProgress(currentSmoothProgress);
        
        if (exportGifBtn) {
           const btnText = exportGifBtn.querySelector('span');
           if (btnText) btnText.textContent = '准备中...';
        }
        
        smoothProgressInterval = setInterval(() => {
            // 仅仅做极缓慢的增加，作为"我还在运行"的信号
            // 如果真实进度来了，currentSmoothProgress 会被 updateRealProgress 大幅更新
            
            // 如果卡在某个进度太久，最多自动爬升 5%
            // 比如当前是 30%，最多自动爬到 35%，然后等待服务器消息
            
            // 这里我们只做非常微小的蠕动，每 100ms 增加 0.05%
            // 这样 1秒增加 0.5%，1分钟增加 30%
            // 并在 95% 处封顶
            
            if (currentSmoothProgress < 95) {
                currentSmoothProgress += 0.05;
                setExportProgress(currentSmoothProgress);
            }
            
        }, 100); 
    }

    function stopSmoothProgress() {
        if (smoothProgressInterval) {
            clearInterval(smoothProgressInterval);
            smoothProgressInterval = null;
        }
    }

    function createSplashParticles(rect) {
        const particleCount = 12;
        const colors = ["#34C759", "#32D74B", "#248A3D"]; // Shades of green
        
        for (let i = 0; i < particleCount; i++) {
            const particle = document.createElement("div");
            particle.classList.add("splash-particle");
            document.body.appendChild(particle);
            
            // Random position around center
            const angle = (i / particleCount) * 360 + (Math.random() * 30 - 15);
            const distance = 20 + Math.random() * 15;
            
            // Start at button center
            const startX = rect.left + rect.width / 2;
            const startY = rect.top + rect.height / 2;
            
            particle.style.left = `${startX}px`;
            particle.style.top = `${startY}px`;
            particle.style.background = colors[Math.floor(Math.random() * colors.length)];
            
            // Calculate destination
            const rad = angle * Math.PI / 180;
            const tx = Math.cos(rad) * distance;
            const ty = Math.sin(rad) * distance;
            
            particle.style.setProperty("--tx", `${tx}px`);
            particle.style.setProperty("--ty", `${ty}px`);
            
            particle.style.animation = `splash-anim 0.6s cubic-bezier(0.165, 0.84, 0.44, 1) forwards`;
            
            // Cleanup
            setTimeout(() => {
                if (particle.parentNode) document.body.removeChild(particle);
            }, 600);
        }
    }

    function cancelExport() {
        console.log('🛑 用户点击取消导出');
        
        // 立即停止平滑进度动画
        stopSmoothProgress();
        
        // 完全重置所有状态
        isExporting = false;
        totalExports = 0;
        completedExports = 0;
        currentSmoothProgress = 0;
        
        // 重置 UI 到初始状态
        if (exportGifBtn) {
            exportGifBtn.classList.remove("exporting");
            exportGifBtn.classList.remove("success");
            // 恢复原始 tooltip
            exportGifBtn.setAttribute('data-tooltip', '导出 GIF');
        }
        
        // 立即隐藏进度环（无过渡效果，确保立即消失）
        if (progressRing) {
            progressRing.style.transition = 'none';
            progressRing.style.opacity = '0';
            // 短暂延迟后恢复过渡效果，用于下次导出
            setTimeout(() => {
                if (progressRing) progressRing.style.transition = 'opacity 0.3s ease';
            }, 50);
        }
        
        // 重置进度到 0
        if (progressCircle) {
            progressCircle.style.transition = 'none';
            progressCircle.style.strokeDashoffset = circumference;
            setTimeout(() => {
                if (progressCircle) progressCircle.style.transition = 'stroke-dashoffset 0.2s linear';
            }, 50);
        }
        
        // 通知 code.js 取消
        parent.postMessage({ pluginMessage: { type: "cancel-gif-export" } }, "*");
        
        // 通知服务器取消所有进行中的处理
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: "cancel-gif-export" }));
            console.log('   📤 已发送取消请求到服务器');
        }
        
        // 显示取消提示
        showToast('已取消导出', 'info');
        
        console.log('   ✅ 所有状态已重置，可以重新开始导出');
    }

    function handleExportSuccess() {
        completedExports++;
        
        console.log(`✅ 导出成功 ${completedExports}/${totalExports}`);
        
        // On final completion, stop smooth progress and show toast
        if (completedExports >= totalExports && totalExports > 0) {
            console.log('🎉 所有导出完成！');
            
            stopSmoothProgress();
            setExportProgress(100);
            
            setTimeout(() => {
                isExporting = false;
                
                // Remove exporting class
                if (exportGifBtn) {
                    exportGifBtn.classList.remove("exporting");
                    // 恢复原始 tooltip
                    exportGifBtn.setAttribute('data-tooltip', '导出 GIF');
                }
                
                // Hide progress ring
                if (progressRing) progressRing.style.opacity = 0;
                if (progressCircle) progressCircle.style.strokeDashoffset = circumference;
                
                // Show success toast with "查看" link (only if window is visible and has focus)
                const count = totalExports || completedExports || 1;
                
                // 检查窗口是否有焦点（不是最小化或隐藏状态）
                console.log('🔍 检查窗口状态:');
                console.log('   windowHasFocus:', windowHasFocus);
                console.log('   document.hidden:', document.hidden);
                console.log('   document.hasFocus():', document.hasFocus());
                
                // 使用多个条件确保窗口真的可见
                const isWindowVisible = windowHasFocus && !document.hidden && document.hasFocus();
                
                if (isWindowVisible) {
                    console.log('✅ 窗口可见，显示成功 Toast，数量:', count);
                    showToastWithAction(`已导出 ${count} 段 GIF`, '查看', () => {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({ type: "open-folder" }));
                        }
                    });
                } else {
                    console.log('❌ 窗口已最小化/隐藏，跳过显示 Toast');
                }
            }, 300);
        }
    }

    function handleExportError() {
        completedExports++;
        
        // On final completion (even with errors), stop smooth progress
        if (totalExports > 0 && completedExports >= totalExports) {
            stopSmoothProgress();
            setExportProgress(100);
            
            setTimeout(() => {
                isExporting = false;
                
                // Remove exporting class
                if (exportGifBtn) {
                    exportGifBtn.classList.remove("exporting");
                    // 恢复原始 tooltip
                    exportGifBtn.setAttribute('data-tooltip', '导出 GIF');
                }
                
                // Hide progress ring
                if (progressRing) progressRing.style.opacity = 0;
                if (progressCircle) progressCircle.style.strokeDashoffset = circumference;
                
                // Error toast is already shown by individual error handlers
            }, 300);
        }
    }
  </script>
</body>
</html>