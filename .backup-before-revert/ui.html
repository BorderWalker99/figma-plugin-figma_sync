<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ScreenSync</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Staatliches&family=Archivo+Black&display=swap" rel="stylesheet">
  <style>
    /*========================
      Design System: Apple Liquid Glass
      Inspired by iOS 26 / macOS Tahoe
    ========================*/
    :root {
      /* Colors - Clean macOS Style */
      --bg-app: #F5F5F7;
      --bg-card: #FFFFFF;
      
      /* Liquid Glass Variables (Light Theme) - Clean macOS style */
      --glass-bg: rgba(255, 255, 255, 0.95);
      --glass-bg-hover: rgba(255, 255, 255, 0.98);
      --glass-bg-active: rgba(248, 248, 250, 0.95);
      --glass-blur: 20px;
      --glass-border: rgba(0, 0, 0, 0.08);
      --glass-border-subtle: rgba(0, 0, 0, 0.05);
      --glass-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
      --glass-shadow-hover: 0 4px 12px rgba(0, 0, 0, 0.06);
      --glass-highlight: inset 0 1px 0 rgba(255, 255, 255, 1);
      --glass-specular: linear-gradient(135deg, rgba(255,255,255,0.6) 0%, rgba(255,255,255,0) 50%);
      
      /* Neumorphism Colors (Light Theme) - Ultra subtle */
      --neu-shadow-light: rgba(255, 255, 255, 0.8);
      --neu-shadow-dark: rgba(0, 0, 0, 0.04);
      
      --neu-ring-gradient: linear-gradient(145deg, rgba(255,255,255,1), rgba(255,255,255,0.6));
      --neu-ring-inner-shadow: inset 1px 1px 2px rgba(255,255,255,1);
      --neu-face-bg: rgba(255, 255, 255, 0.85);
      --neu-face-shadow: 
        inset 1px 1px 2px rgba(255,255,255,1), 
        inset -1px -1px 2px rgba(0,0,0,0.03);
      
      --neu-face-bg-hover: rgba(255, 255, 255, 0.95);
      --neu-face-bg-active: rgba(250, 250, 252, 0.9);
      --neu-face-shadow-active: 
        inset 2px 2px 4px rgba(0,0,0,0.05),
        inset -1px -1px 2px rgba(255,255,255,0.8);

      /* ==========================================================================
         Unified Green Token System
         Based on Realtime Sync Button Icon (#mainStartBtn.active .icon-on)
         ========================================================================== */
      --unified-green: #40D468; /* Brighter green for light mode */
      --unified-green-glow: rgba(64, 212, 104, 0.35);
      
      /* Status Pill Variables - Clean flat style */
      --pill-recessed-bg: #F0F0F2;
      --pill-recessed-shadow: 
          inset 1px 1px 2px rgba(0, 0, 0, 0.03),
          inset -1px -1px 2px rgba(255, 255, 255, 0.6);
      --pill-screen-text: var(--unified-green);
      --pill-screen-text-glow: var(--unified-green-glow);
      --pill-interactive-bg: #F0F0F2;
      
      /* Active State */
      --power-green: var(--unified-green);
      --neu-glow: var(--unified-green-glow);
      
      /* Background colors */
      --bg-card-hover: #FFFFFF;
      --bg-app: #F5F5F7;
      --bg-card: #FFFFFF;
      
      /* Logo Colors */
      --logo-color-primary: #007AFF;

      /* Text Color Hierarchy (Light Mode - 三级体系) */
      --text-primary: #a3a3a7;      /* 一级：标题、主要内容 */
      --text-secondary: #bababf;    /* 二级：副标题、说明文字 */
      --text-tertiary: #d0d0d5;     /* 三级：辅助信息、占位符 */
      
      /* Accent Blue */
      --accent: #0066FF;
      --accent-soft: rgba(0, 102, 255, 0.1);
      
      /* Switch Green Gradient - Match status pill green */
      --switch-active-gradient: linear-gradient(145deg, var(--unified-green), #2A9C46);
      
      --success: var(--unified-green);
      --info: #3B82F6;
      --warning: #F59E0B;
      --danger: #FF3B30;
      
      --divider: rgba(0, 0, 0, 0.06);
      --border: rgba(0, 0, 0, 0.1);
      
      /* Shadows - Ultra subtle for clean macOS look */
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.02);
      --shadow-md: 0 2px 8px rgba(0, 0, 0, 0.04);
      --shadow-lg: 0 4px 16px rgba(0, 0, 0, 0.06);
      --shadow-inner: inset 0 1px 1px rgba(255,255,255,0.8);
      
      /* Upload dropzone (Light) */
      --bg-inset: #F0F0F2;
      
      /* Timeline/Preview colors (Light) */
      --preview-bg: #1a1a1a;
      --track-bar-bg: #333333;
      --track-frame-bg: #2a2a2a;
      --preview-text: #888888;
      --preview-error: #FF6B6B;
      
      /* Focus/Selection blue */
      --focus-blue: #4A90D9;
      --focus-blue-glow: rgba(74, 144, 217, 0.3);
      
      /* Feature card accent colors */
      --feature-realtime: #FFCC00;
      --feature-realtime-bg: rgba(255, 204, 0, 0.15);
      
      /* Radius */
      --radius-xs: 4px;
      --radius-s: 8px;
      --radius-m: 12px;
      --radius-l: 16px;
      --radius-xl: 24px;
      --radius-pill: 999px;
      
      /* Input/Button specific radius */
      --radius-input: 10px;
      --radius-btn: 12px;
      
      /* Animation */
      --ease-spring: cubic-bezier(0.25, 0.8, 0.25, 1);
      --ease-out: cubic-bezier(0.33, 1, 0.68, 1);
    }

    /* Timeline Editor Styles */
    .timeline-track-row {
      display: flex;
      align-items: center;
      gap: 12px;
      height: 36px;
    }
    .track-label {
      width: 100px;
      font-size: 12px;
      color: var(--text-secondary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-align: right;
    }
    .track-area {
      flex: 1;
      height: 24px;
      background: var(--bg-inset);
      border-radius: var(--radius-xs);
      position: relative;
      /* overflow: hidden; Removed to allow handles to be grabbed easily */ 
      box-shadow: var(--shadow-inner);
    }
    .track-bar {
      position: absolute;
      top: 2px;
      bottom: 2px;
      background: var(--track-bar-bg);
      border-radius: var(--radius-xs);
      cursor: grab;
      min-width: 10px;
      overflow: hidden;
      display: flex;
      align-items: stretch;
      border: 1px solid rgba(255,255,255,0.15);
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }
    .track-bar:active {
      cursor: grabbing;
    }
    .track-bar-filmstrip {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      display: flex;
      overflow: hidden;
      border-radius: var(--radius-xs);
      /* Width will be set dynamically based on track-area width */
    }
    .track-bar-frame {
      flex: 0 0 auto;
      width: 40px; /* Fixed width per frame */
      min-width: 0;
      background-size: auto 100%; /* Height fills, width maintains aspect ratio */
      background-position: center;
      background-repeat: no-repeat;
      background-color: var(--track-frame-bg);
      border-right: 1px solid rgba(0,0,0,0.4);
    }
    .track-bar-frame:last-child {
      border-right: none;
    }
    .track-handle {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 10px; /* Wider hit area */
      cursor: col-resize;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(to right, rgba(0,0,0,0.4), transparent, transparent, rgba(0,0,0,0.4));
    }
    .track-handle::after {
      content: '';
      width: 4px;
      height: 14px;
      background: rgba(255,255,255,0.8);
      border-radius: 2px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.5);
    }
    .track-handle.left { 
      left: 0; 
      border-radius: 3px 0 0 3px;
      background: linear-gradient(to right, rgba(0,0,0,0.5), transparent);
    }
    .track-handle.right { 
      right: 0; 
      border-radius: 0 3px 3px 0;
      background: linear-gradient(to left, rgba(0,0,0,0.5), transparent);
    }

    /* Export Choice Button Style - Liquid Glass */
    .export-choice-btn {
      position: relative;
      display: flex;
      align-items: center;
      gap: 12px;
      width: 100%;
      padding: 14px 16px;
      background: var(--glass-bg);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid var(--glass-border-subtle);
      border-radius: var(--radius-l);
      cursor: pointer;
      transition: all 0.25s cubic-bezier(0.25, 0.8, 0.25, 1);
      box-shadow: 
        0 1px 4px rgba(0, 0, 0, 0.03),
        inset 0 1px 0 rgba(255, 255, 255, 0.4);
    }
    .export-choice-btn:hover {
      background: var(--glass-bg-hover);
      border-color: var(--glass-border);
      box-shadow: 
        0 2px 6px rgba(0, 0, 0, 0.04),
        inset 0 1px 0 rgba(255, 255, 255, 0.5);
    }
    .export-choice-btn:hover .export-choice-arrow {
      opacity: 0.9;
    }
    .export-choice-btn:active {
      background: var(--glass-bg-active);
      box-shadow: 
        0 1px 2px rgba(0, 0, 0, 0.02),
        inset 0 1px 1px rgba(0, 0, 0, 0.01);
    }
    
    .export-choice-icon {
      width: 36px;
      height: 36px;
      border-radius: var(--radius-input);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      background: rgba(0, 0, 0, 0.03);
      color: var(--text-secondary);
    }
    .export-choice-icon svg {
      color: var(--text-secondary);
    }
    
    .export-choice-arrow {
      color: var(--text-secondary);
      transition: all 0.25s ease;
    }
    
    @media (prefers-color-scheme: dark) {
      .export-choice-btn {
        box-shadow: 
          0 4px 16px rgba(0, 0, 0, 0.25),
          inset 0 1px 0 rgba(255, 255, 255, 0.08);
      }
      .export-choice-btn:hover {
        box-shadow: 
          0 8px 24px rgba(0, 0, 0, 0.35),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
      }
      .export-choice-btn:active {
        box-shadow: 
          0 2px 8px rgba(0, 0, 0, 0.3),
          inset 0 1px 2px rgba(0, 0, 0, 0.2);
      }
      .export-choice-icon {
        background: rgba(255, 255, 255, 0.05);
      }
    }

    /* Preview layer styles */
    .preview-layer {
        pointer-events: none;
        transition: opacity 0.15s ease;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg-app: #1C1C1E;
        --bg-card: #2C2C2E;
        --bg-card-hover: #3A3A3C;
        
        /* Liquid Glass Variables (Dark Theme) */
        --glass-bg: rgba(40, 40, 42, 0.7);
        --glass-bg-hover: rgba(50, 50, 52, 0.75);
        --glass-bg-active: rgba(35, 35, 37, 0.65);
        --glass-blur: 24px;
        --glass-border: rgba(255, 255, 255, 0.12);
        --glass-border-subtle: rgba(255, 255, 255, 0.08);
        --glass-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        --glass-shadow-hover: 0 12px 40px rgba(0, 0, 0, 0.4);
        --glass-highlight: inset 0 1px 0 rgba(255, 255, 255, 0.1);
        --glass-specular: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 50%);
        
        /* Neumorphism Colors (Dark Theme) */
        --neu-shadow-light: rgba(255, 255, 255, 0.04);
        --neu-shadow-dark: rgba(0, 0, 0, 0.5);
        
        --neu-ring-gradient: linear-gradient(145deg, rgba(255,255,255,0.1), rgba(255,255,255,0.02));
        --neu-ring-inner-shadow: inset 1px 1px 2px rgba(255,255,255,0.06);
        --neu-face-bg: rgba(44, 44, 46, 0.8);
        --neu-face-shadow: 
          inset 1px 1px 2px rgba(255,255,255,0.06), 
          inset -1px -1px 2px rgba(0,0,0,0.2);
        
        --neu-face-bg-hover: rgba(58, 58, 60, 0.85);
        --neu-face-bg-active: rgba(40, 40, 42, 0.75);
        --neu-face-shadow-active: 
          inset 2px 2px 4px rgba(0,0,0,0.35),
          inset -1px -1px 2px rgba(255,255,255,0.04);
        
        /* Unified Green Token - Dark Theme Override */
        --unified-green-glow: rgba(77, 227, 79, 0.45);
        --neu-glow: var(--unified-green-glow);

        /* Status Pill Variables - Liquid Glass Style (Dark) */
        --pill-recessed-bg: rgba(40, 40, 42, 0.7);
        --pill-recessed-shadow: 
            0 4px 16px rgba(0, 0, 0, 0.3),
            inset 0 1px 0 rgba(255, 255, 255, 0.08);
        --pill-screen-text: var(--unified-green);
        --pill-screen-text-glow: var(--unified-green-glow);
        --pill-interactive-bg: rgba(44, 44, 46, 0.75);

        /* Logo Colors Dark Mode */
        --logo-color-primary: #0A84FF;

        /* Text Color Hierarchy (Dark Mode - 三级体系) */
        --text-primary: #98989D;      /* 一级：标题、主要内容 */
        --text-secondary: #636366;    /* 二级：副标题、说明文字 */
        --text-tertiary: #545456;     /* 三级：辅助信息、占位符 */
        
        --accent: #0A84FF;
        --accent-soft: rgba(10, 132, 255, 0.15);
        
        /* Switch Green Gradient (Dark) */
        --switch-active-gradient: linear-gradient(145deg, var(--unified-green), #248A3D);
        
        --divider: rgba(255, 255, 255, 0.08);
        --border: rgba(255, 255, 255, 0.1);
        
        --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.25);
        --shadow-md: 0 8px 24px rgba(0, 0, 0, 0.35);
        
        /* Upload dropzone */
        --bg-inset: rgba(28, 28, 30, 0.8);
        
        /* Timeline/Preview colors (Dark) */
        --preview-bg: #1a1a1a;
        --track-bar-bg: #404040;
        --track-frame-bg: #2a2a2a;
        --preview-text: #888888;
        --preview-error: #FF6B6B;
        
        /* Focus/Selection blue (Dark) */
        --focus-blue: #5AA3F0;
        --focus-blue-glow: rgba(90, 163, 240, 0.35);
        
        /* Feature card accent colors (Dark) */
        --feature-realtime: #FFD60A;
        --feature-realtime-bg: rgba(255, 214, 10, 0.15);
      }
    }

    /* CSS Refactoring: Settings Content */
    .settings-section {
        margin-bottom: 12px;
        padding: 0;
    }

    /* Add extra space for the first section to avoid clipping hover effects */
    .tab-content > .settings-section:first-child {
        padding-top: 4px;
    }

    .settings-section:last-child {
        margin-bottom: 0;
    }

    .settings-section h3 {
        font-size: 13px;
        margin: 0 0 8px 0;
        font-weight: 600;
        color: var(--text-primary);
    }
    
    /* Inline styled titles in modal - override inline styles */
    #userIdTitle, #shortcutGuideTitle {
        color: var(--text-primary) !important;
    }

    * {
      box-sizing: border-box;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    
    /* Global Skeuomorphism Text Shadow - Applied to all text elements */
    button, .modal-title, .section-title, .tab-btn, .hero-mode-title, 
    .metric-value, .metric-label, .settings-section h3, .toast, .log-title,
    .btn span, .control-label, .card-title, .card-desc, .input-prefix,
    .update-banner-text, .user-id-display #displayUserId, .connection-pill,
    h1, h2, h3, h4, h5, h6, p, span, label {
        text-shadow: 0 1px 1px rgba(255, 255, 255, 0.5);
    }
    
    @media (prefers-color-scheme: dark) {
        button, .modal-title, .section-title, .tab-btn, .hero-mode-title, 
        .metric-value, .metric-label, .settings-section h3, .toast, .log-title,
        .btn span, .control-label, .card-title, .card-desc, .input-prefix,
        .update-banner-text, .user-id-display #displayUserId, .connection-pill,
        h1, h2, h3, h4, h5, h6, p, span, label {
            text-shadow: 0 1px 1px rgba(0, 0, 0, 0.3);
        }
    }
    
    /* Exceptions - Remove text shadow from input fields and their content */
    .input-wrapper input,
    .input-wrapper input::placeholder {
        text-shadow: none;
    }
    
    /* Global Skeuomorphism Icon Shadow - Applied to all icons */
    svg, .icon-btn svg, .neumorphic-btn svg, .close-btn svg,
    .toast-icon svg, .connection-pill svg, .card-icon svg,
    .update-banner-icon svg, .btn svg {
        filter: drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
    }
    
    @media (prefers-color-scheme: dark) {
        svg, .icon-btn svg, .neumorphic-btn svg, .close-btn svg,
        .toast-icon svg, .connection-pill svg, .card-icon svg,
        .update-banner-icon svg, .btn svg {
            filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
        }
    }
    
    /* Special handling for icons that already have specific filters */
    .connection-pill.connected svg {
        filter: drop-shadow(0 0 6px var(--neu-glow)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
    }
    
    @media (prefers-color-scheme: dark) {
        .connection-pill.connected svg {
            /* Reduce glow spread in dark theme for subtler effect */
            filter: drop-shadow(0 0 4px var(--neu-glow)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
        }
    }
    
    #mainStartBtn.active .icon-on,
    #mainStartBtn.active:hover .icon-on {
        /* Stronger double-layer glow */
        filter: drop-shadow(0 0 6px var(--unified-green-glow)) drop-shadow(0 0 12px var(--unified-green-glow)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
    }
    
    @media (prefers-color-scheme: dark) {
        #mainStartBtn.active .icon-on,
        #mainStartBtn.active:hover .icon-on {
            /* Stronger double-layer glow for dark mode */
            filter: drop-shadow(0 0 8px var(--unified-green-glow)) drop-shadow(0 0 16px var(--unified-green-glow)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
        }
    }
    
    .progress-ring__circle {
        filter: drop-shadow(0 0 3px var(--unified-green-glow)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
    }
    
    @media (prefers-color-scheme: dark) {
        .progress-ring__circle {
            filter: drop-shadow(0 0 2px var(--unified-green-glow)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
        }
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden; /* 禁止页面滚动 */
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", Arial, sans-serif;
      background: var(--bg-app);
      color: var(--text-primary);
      font-size: 13px;
      line-height: 1.4;
      user-select: none;
    }

    /* Layout */
    .app {
      display: flex;
      flex-direction: column;
      height: 100vh;
      padding: 16px;
      gap: 8px;
      box-sizing: border-box;
      transition: all 0.4s var(--ease-spring);
      overflow: hidden; /* 禁止容器滚动 */
    }

    .app.minimized {
      padding: 0;
      background: transparent;
    }
    
    /* 最小化时隐藏 toast */
    .app.minimized .toast {
      display: none !important;
      opacity: 0 !important;
      pointer-events: none !important;
    }
    
    .app.minimized .main-content,
    .app.minimized .status-bar {
      display: none;
    }

    /* Header */
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-shrink: 0;
      height: 32px; /* Fixed header height */
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 8px;
      height: 24px;
      
      /* Fade-in animation on load */
      animation: fadeInScale 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
      animation-delay: 0.05s;
      opacity: 0;
    }

    .logo-box {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
    }
    
    .logo-box svg {
        display: block;
        width: 24px;
        height: 24px;
        /* Enhanced Skeuomorphism - Embossed/Inset effect */
        filter: drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5)) drop-shadow(0 -0.5px 0.5px rgba(0, 0, 0, 0.15));
    }

    @media (prefers-color-scheme: dark) {
        .logo-box svg {
            filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3)) drop-shadow(0 -0.5px 0.5px rgba(255, 255, 255, 0.05));
        }
    }
    

    .app-title {
      font-family: 'Archivo Black', sans-serif;
      font-weight: 400;
      font-size: 18px;
      letter-spacing: -0.01em;
      line-height: 1;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      /* Skeuomorphic text shadow - embedded/engraved effect */
      text-shadow: 0 1px 1px rgba(255, 255, 255, 0.5);
    }
    
    @media (prefers-color-scheme: dark) {
      .app-title {
        text-shadow: 0 1px 1px rgba(0, 0, 0, 0.3);
    }
    }

    /* Legacy .connection-pill styles removed to prevent conflicts with new Neumorphic styles */
    .connection-pill:empty {
        display: none;
    }
    
    /* 减少右箭头和文字之间的间距 */

    @media (prefers-color-scheme: dark) {
        .connection-pill {
            background: var(--glass-bg);
            color: var(--text-secondary);
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }
        .connection-pill.connected {
            background: var(--glass-bg);
        }
        .connection-pill.waiting {
            background: var(--glass-bg);
        }
        .connection-pill.reconnect {
            background: rgba(255, 59, 48, 0.25);
            border-color: rgba(255, 59, 48, 0.3);
        }
        .connection-pill.reconnect:hover {
            background: rgba(255, 59, 48, 0.35);
        }
        .connection-pill.interactive {
            box-shadow: 
                0 6px 20px rgba(0, 0, 0, 0.35),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: 16px; /* Increased gap for neumorphic button shadows */
    }

    /* Icon Button - Liquid Glass Style */
    .icon-btn {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 1px solid var(--glass-border-subtle);
      outline: none;
      background: var(--glass-bg);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.25s cubic-bezier(0.25, 0.8, 0.25, 1);
      position: relative;
      z-index: 100;
      padding: 2px;
      overflow: visible;
      
      /* Liquid Glass Shadow - Ultra subtle */
      box-shadow: 
        0 1px 3px rgba(0, 0, 0, 0.03),
        inset 0 1px 0 rgba(255, 255, 255, 0.4);
      
      /* Fade-in animation */
      animation: glassPopIn 0.4s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
      opacity: 0;
    }
    
    /* Toolbar icons appear together */
    #openFolder,
    #openSettings,
    #toggleMinimize { 
      animation-delay: 0.3s; 
    }
    
    /* Inner Face - Liquid Glass */
    .neu-icon-inner {
        width: 100%;
        height: 100%;
        border-radius: 50%;
        background: transparent;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.25s ease;
        pointer-events: none;
    }

    /* Icon Styling */
    .icon-btn svg {
      width: 16px;
      height: 16px;
      color: var(--text-secondary);
      transition: all 0.25s ease;
      filter: drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
      stroke-width: inherit; 
    }

    /* Force specific stroke width for folder icon */
    #openFolder svg {
        stroke-width: 3px !important;
    }
    
    @media (prefers-color-scheme: dark) {
        .icon-btn svg {
            filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
        }
        .icon-btn {
            box-shadow: 
                0 2px 8px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }
    }

    /* Hover State */
    .icon-btn:hover {
      transform: scale(1.05);
      background: var(--glass-bg-hover);
      border-color: var(--glass-border);
      box-shadow: 
        0 2px 6px rgba(0, 0, 0, 0.04),
        inset 0 1px 0 rgba(255, 255, 255, 0.5);
    }
    
    .icon-btn:hover .neu-icon-inner {
        background: transparent;
    }
    
    .icon-btn:hover svg {
      opacity: 1;
      color: var(--text-primary);
    }

    /* Active/Pressed State */
    .icon-btn:active {
      transform: scale(0.95);
      background: var(--glass-bg-active);
      box-shadow: 
        0 1px 2px rgba(0, 0, 0, 0.02),
        inset 0 1px 1px rgba(0, 0, 0, 0.01);
    }
    
    .icon-btn:active .neu-icon-inner {
        background: transparent;
    }
    
    @media (prefers-color-scheme: dark) {
        .icon-btn:hover .neu-icon-inner {
            background: rgba(255,255,255,0.1);
        }
    }
    
    @media (prefers-color-scheme: dark) {
        .icon-btn:hover {
            background: rgba(255,255,255,0.1);
        }
    }
    
    /* Custom Select - Liquid Glass Style */
    .settings-select {
      appearance: none;
      -webkit-appearance: none;
      box-sizing: border-box;
      height: 32px;
      font-weight: 500;
      background-color: rgba(142, 142, 147, 0.12);
      border: 2px solid transparent;
      border-radius: var(--radius-input);
      padding: 0 28px 0 10px;
      font-size: 13px;
      line-height: 28px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.25s cubic-bezier(0.25, 0.8, 0.25, 1);
      /* Chevron Down SVG */
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 8px center;
      background-size: 14px;
      transition: all 0.2s ease, width 0.15s ease;
    }

    .settings-select:hover {
      background-color: rgba(142, 142, 147, 0.15);
    }

    .settings-select:focus,
    .settings-select:active {
      outline: none;
      border-color: transparent;
      box-shadow: none;
    }
    
    @media (prefers-color-scheme: dark) {
        .settings-select {
            background-color: rgba(118, 118, 128, 0.24);
        }
        .settings-select:hover {
            background-color: rgba(118, 118, 128, 0.32);
        }
        .settings-select:focus,
        .settings-select:active {
            border-color: transparent;
            box-shadow: none;
        }
    }
    
    /* Language Select with SVG Flags */
    .lang-select-wrapper {
      position: relative;
      display: inline-flex;
      align-items: center;
    }
    .lang-select-display {
      box-sizing: border-box;
      height: 32px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 0 28px 0 10px;
      background-color: rgba(142, 142, 147, 0.12);
      border: 2px solid transparent;
      border-radius: var(--radius-input);
      font-size: 13px;
      font-weight: 500;
      line-height: 1;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.25s cubic-bezier(0.25, 0.8, 0.25, 1);
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 8px center;
      background-size: 14px;
      white-space: nowrap;
    }
    .lang-select-wrapper:hover .lang-select-display {
      background-color: rgba(142, 142, 147, 0.15);
    }
    .lang-select-native {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
      z-index: 1;
    }
    .lang-flag img {
      display: block;
      width: 14px;
      height: 14px;
      border-radius: 2px;
      overflow: hidden;
    }
    @media (prefers-color-scheme: dark) {
      .lang-select-display {
        background-color: rgba(118, 118, 128, 0.24);
      }
      .lang-select-wrapper:hover .lang-select-display {
        background-color: rgba(118, 118, 128, 0.32);
      }
    }

    /* Tooltip 样式 */
    .icon-btn[data-tooltip]:not(.no-tooltip)::after {
      content: attr(data-tooltip);
      position: absolute;
      top: calc(100% + 9px);
      left: 50%;
      transform: translateX(-50%) scale(0.9);
      background: var(--bg-card);
      color: var(--text-primary);
      padding: 5px 10px;
      border-radius: var(--radius-input);
      font-size: 12px;
      white-space: nowrap;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease 0s, transform 0.2s ease 0s;
      z-index: 1000;
      font-weight: 400;
      letter-spacing: 0.01em;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }
    
    /* Tooltip 小尖角 */
    .icon-btn[data-tooltip]:not(.no-tooltip)::before {
      content: '';
      position: absolute;
      top: calc(100% + 5px);
      left: 50%;
      transform: translateX(-50%) scale(0.9);
      width: 0;
      height: 0;
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
      border-bottom: 4px solid var(--bg-card);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease 0s, transform 0.2s ease 0s;
      z-index: 1001;
    }
    @media (prefers-color-scheme: dark) {
      .icon-btn[data-tooltip]:not(.no-tooltip)::after {
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
      }
    }
    
    .icon-btn[data-tooltip]:not(.no-tooltip):hover::after,
    .icon-btn[data-tooltip]:not(.no-tooltip):hover::before {
      opacity: 1;
      transform: translateX(-50%) scale(1);
      transition-delay: 0.5s;
    }

    /* Update Banner - Neumorphic Style */
    .update-banner {
      display: none;
      background: var(--neu-face-bg);
      color: var(--text-secondary);
      padding: 12px;
      font-size: 11px;
      line-height: 1.4;
      border-radius: var(--radius-m);
      animation: slideDown 0.3s ease;
      flex-shrink: 0;
      margin: 12px 2px;
      /* Raised effect */
      box-shadow: 
        -2px -2px 5px var(--neu-shadow-light),
        2px 2px 5px var(--neu-shadow-dark);
      border: 1px solid rgba(255,255,255,0.1);
    }

    @media (prefers-color-scheme: dark) {
      .update-banner {
        background: var(--neu-face-bg);
        border-color: rgba(255,255,255,0.05);
      }
    }

    .update-banner.show {
      display: block;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    /* Button Pop-out Animation: From flat/recessed to raised neumorphic */
    @keyframes iconPopOut {
      0% {
        opacity: 0;
        box-shadow: 
          inset 2px 2px 4px rgba(0, 0, 0, 0.15),
          inset -2px -2px 4px rgba(255, 255, 255, 0.7);
        transform: scale(0.9);
      }
      60% {
        transform: scale(1.05);
      }
      100% {
        opacity: 1;
        transform: scale(1);
      }
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .spinner {
      border: 2px solid var(--bg-secondary);
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    
    /* Recessed element push-in animation: From raised to recessed */
    @keyframes pushInRecessed {
      0% {
        opacity: 0;
        box-shadow: 
          -2px -2px 4px var(--neu-shadow-light),
          2px 2px 4px var(--neu-shadow-dark);
        transform: scale(1.05) translateY(-2px);
      }
      60% {
        transform: scale(0.98) translateY(1px);
      }
      100% {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }
    
    /* Simple fade-in scale for flat elements */
    @keyframes fadeInScale {
      0% {
        opacity: 0;
        transform: scale(0.95);
      }
      100% {
        opacity: 1;
        transform: scale(1);
      }
    }
    
    /* Rotate animation for loading spinner */
    @keyframes rotate {
      from {
        transform: rotate(-90deg);
      }
      to {
        transform: rotate(270deg);
      }
    }
    
    /* Icon completion glow animation - blink twice like physical LED button */
    @keyframes iconCompletionGlow {
      /* First blink - Fast rise, slower decay (LED characteristic) */
      0% {
        filter: drop-shadow(0 0 0px rgba(77, 227, 79, 0)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
        color: var(--text-primary); /* Original color */
        opacity: 0.5; /* Original opacity */
      }
      8% {
        /* Quick rise to peak brightness - Concentrated glow + GREEN color */
        filter: drop-shadow(0 0 6px rgba(77, 227, 79, 1)) drop-shadow(0 0 12px rgba(77, 227, 79, 0.9)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
        color: var(--unified-green); /* Bright green fill */
        opacity: 1; /* Full brightness */
      }
      12% {
        /* Hold at peak briefly */
        filter: drop-shadow(0 0 6px rgba(77, 227, 79, 1)) drop-shadow(0 0 12px rgba(77, 227, 79, 0.9)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
        color: var(--unified-green); /* Bright green fill */
        opacity: 1; /* Full brightness */
      }
      25% {
        /* Gradual decay with afterglow */
        filter: drop-shadow(0 0 3px rgba(77, 227, 79, 0.5)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
        color: var(--unified-green); /* Still green */
        opacity: 1; /* Full brightness */
      }
      32% {
        /* Complete fade */
        filter: drop-shadow(0 0 0px rgba(77, 227, 79, 0)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
        color: var(--text-primary); /* Back to original */
        opacity: 0.5; /* Back to original */
      }
      
      /* Brief pause between blinks */
      40% {
        filter: drop-shadow(0 0 0px rgba(77, 227, 79, 0)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
        color: var(--text-primary); /* Original color */
        opacity: 0.5; /* Original opacity */
      }
      
      /* Second blink - Same pattern */
      48% {
        filter: drop-shadow(0 0 6px rgba(77, 227, 79, 1)) drop-shadow(0 0 12px rgba(77, 227, 79, 0.9)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
        color: var(--unified-green); /* Bright green fill */
        opacity: 1; /* Full brightness */
      }
      52% {
        filter: drop-shadow(0 0 6px rgba(77, 227, 79, 1)) drop-shadow(0 0 12px rgba(77, 227, 79, 0.9)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
        color: var(--unified-green); /* Bright green fill */
        opacity: 1; /* Full brightness */
      }
      65% {
        filter: drop-shadow(0 0 3px rgba(77, 227, 79, 0.5)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
        color: var(--unified-green); /* Still green */
        opacity: 1; /* Full brightness */
      }
      72%, 100% {
        filter: drop-shadow(0 0 0px rgba(77, 227, 79, 0)) drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
        color: var(--text-primary); /* Back to original */
        opacity: 0.5; /* Back to original */
      }
    }
    
    @media (prefers-color-scheme: dark) {
      @keyframes iconCompletionGlow {
        /* First blink - More pronounced for dark theme */
        0% {
          filter: drop-shadow(0 0 0px rgba(77, 227, 79, 0)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
          color: var(--text-primary); /* Original color */
          opacity: 0.5; /* Original opacity */
        }
        8% {
          /* Concentrated bright glow + GREEN color - Use unified green values */
          filter: drop-shadow(0 0 5px rgba(77, 227, 79, 1)) drop-shadow(0 0 10px rgba(77, 227, 79, 0.8)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
          color: var(--unified-green); /* Unified green fill */
          opacity: 1; /* Full brightness */
        }
        12% {
          filter: drop-shadow(0 0 5px rgba(77, 227, 79, 1)) drop-shadow(0 0 10px rgba(77, 227, 79, 0.8)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
          color: var(--unified-green); /* Unified green fill */
          opacity: 1; /* Full brightness */
        }
        25% {
          filter: drop-shadow(0 0 3px rgba(77, 227, 79, 0.4)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
          color: var(--unified-green); /* Still green */
          opacity: 1; /* Full brightness */
        }
        32% {
          filter: drop-shadow(0 0 0px rgba(77, 227, 79, 0)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
          color: var(--text-primary); /* Back to original */
          opacity: 0.5; /* Back to original */
        }
        
        /* Brief pause */
        40% {
          filter: drop-shadow(0 0 0px rgba(77, 227, 79, 0)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
          color: var(--text-primary); /* Original color */
          opacity: 0.5; /* Original opacity */
        }
        
        /* Second blink */
        48% {
          filter: drop-shadow(0 0 5px rgba(77, 227, 79, 1)) drop-shadow(0 0 10px rgba(77, 227, 79, 0.8)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
          color: var(--unified-green); /* Unified green fill */
          opacity: 1; /* Full brightness */
        }
        52% {
          filter: drop-shadow(0 0 5px rgba(77, 227, 79, 1)) drop-shadow(0 0 10px rgba(77, 227, 79, 0.8)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
          color: var(--unified-green); /* Unified green fill */
          opacity: 1; /* Full brightness */
        }
        65% {
          filter: drop-shadow(0 0 3px rgba(77, 227, 79, 0.4)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
          color: var(--unified-green); /* Still green */
          opacity: 1; /* Full brightness */
        }
        72%, 100% {
          filter: drop-shadow(0 0 0px rgba(77, 227, 79, 0)) drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
          color: var(--text-primary); /* Back to original */
          opacity: 0.5; /* Back to original */
        }
      }
    }
    
    /* Apply animation class with custom easing for LED-like effect */
    .icon-completion-glow {
      animation: iconCompletionGlow 1.4s cubic-bezier(0.22, 1, 0.36, 1);
    }

    .update-banner-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .update-banner-info {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .update-banner-icon {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
      color: var(--text-secondary);
    }

    .update-banner-text {
      flex: 1;
      font-weight: 500;
      font-size: 13px;
      color: var(--text-secondary);
    }

    .update-banner-actions {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-shrink: 0;
    }

    .update-banner-btn {
      padding: 6px 12px;
      border-radius: var(--radius-s);
      font-size: 12px;
      font-weight: 500;
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
      /* Neumorphic Button Style */
      background: var(--neu-face-bg);
      color: var(--text-secondary);
      box-shadow: 
        -2px -2px 5px var(--neu-shadow-light),
        2px 2px 5px var(--neu-shadow-dark);
    }

    .update-banner-btn.primary {
      color: var(--accent);
      font-weight: 600;
    }

    .update-banner-btn.primary:hover {
      filter: brightness(1.1);
    }
    
    .update-banner-btn:active {
      box-shadow: 
        inset 2px 2px 5px var(--neu-shadow-dark),
        inset -2px -2px 5px var(--neu-shadow-light);
    }
    
    /* 透明状态：去除拟物效果，仅显示文字 */
    .update-banner-btn.primary.transparent {
      background: transparent;
      color: var(--text-secondary);
      font-weight: 500;
      cursor: default;
      pointer-events: none;
      box-shadow: none;
    }
    
    .update-banner-btn.primary.transparent:hover {
      filter: none;
      box-shadow: none;
    }

    .update-banner-btn.secondary {
      /* Uses default neumorphic style defined in .update-banner-btn */
    }

    .update-banner-btn.secondary:hover {
      color: var(--text-primary);
    }

    .update-banner-btn:disabled {
      /* opacity: 0.5; */ /* Disable default opacity reduction */
      opacity: 1; /* Keep full opacity */
      cursor: not-allowed;
      /* box-shadow: none; */ /* Keep the shadow (button style) */
      color: var(--text-tertiary); /* Disabled state uses quaternary */
      /* Actually user wants to maintain button style during download, so maybe keep original color or slight change */
    }

    .update-banner-close {
      width: 26px;
      height: 26px;
      padding: 0;
      background: var(--neu-face-bg);
      border: none;
      border-radius: 50%;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      flex-shrink: 0;
      /* Neumorphic Style */
      box-shadow: 
        -2px -2px 5px var(--neu-shadow-light),
        2px 2px 5px var(--neu-shadow-dark);
    }

    .update-banner-close svg {
      width: 12px;
      height: 12px;
    }

    .update-banner-close:hover {
      color: var(--text-primary);
    }

    .update-banner-close:active {
      box-shadow: 
        inset 2px 2px 5px var(--neu-shadow-dark),
        inset -2px -2px 5px var(--neu-shadow-light);
    }

    /* Main Content Area */
    .main-content {
      flex: 1;
      position: relative;
      overflow: visible;
    }

    /* Mode Selection View */
    .mode-selection {
      display: flex;
      flex-direction: column;
      gap: 12px;
      height: 100%;
      animation: zoomIn 0.4s var(--ease-out);
      text-align: center;
    }

    .section-title {
      font-size: 15px;
      font-weight: 700;
      margin: 0 0 4px 0;
      letter-spacing: -0.02em;
      color: var(--text-tertiary);
      opacity: 0.8;
    }

    .section-desc {
      color: var(--text-secondary);
        font-size: 12px;
        margin-bottom: 8px;
    }

    .card-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .feature-card {
      background: var(--bg-card);
      border: 1px solid transparent;
      border-radius: var(--radius-m);
      padding: 15px;
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: space-between;
      text-align: left;
      gap: 0;
      cursor: pointer;
      transition: all 0.3s var(--ease-spring);
      box-shadow: var(--shadow-sm);
      position: relative;
      overflow: visible; /* Allow glow effects */
    }

    .feature-card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .card-icon {
      width: 40px;
      height: 40px;
      border-radius: 50%; /* Circular icons */
      /* background: var(--bg-app); */
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      transition: all 0.3s ease;
      margin-bottom: 0;
      margin-right: 12px;
    }
    
    .card-icon img {
        width: 24px;
        height: 24px;
    }

    .card-content {
      flex: 1;
      width: 100%;
    }

    .card-title {
      font-weight: 600;
      font-size: 14px;
      margin-bottom: 2px;
      color: var(--text-primary);
    }

    .card-desc {
      font-size: 12px;
      color: var(--text-secondary);
      line-height: 1.4;
    }

    /* Upload mode cards - centered titles */
    .feature-card.mode-card {
      align-items: center;
    }
    
    .feature-card.mode-card .card-icon {
      margin-right: 0;
      margin-bottom: 4px;
    }
    
    .feature-card.mode-card .card-content {
      text-align: center;
    }
    
    .feature-card.mode-card .card-title {
      text-align: center;
    }
    
    .feature-card.mode-card .card-desc {
      text-align: center;
    }

    /* Selected Checkmark */
    .checkmark {
      position: absolute;
      top: 0;
      right: 0;
      background: var(--accent);
      width: 24px;
      height: 24px;
      border-bottom-left-radius: calc(var(--radius-m) - 1px);
      border-top-right-radius: calc(var(--radius-m) - 1px); /* Match card radius */
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    .checkmark svg {
      width: 14px;
      height: 14px;
      color: white;
    }

    .feature-card.selected .checkmark {
      display: flex;
    }
    
    .chevron {
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-tertiary);
      margin-left: 8px;
    }
    
    .chevron svg {
        width: 20px; 
        height: 20px;
    }

    /* Main Content Reset */
    .main-content {
      height: 100%;
      display: flex;
      flex-direction: column;
    }

    /* Realtime Header & Status Pill Alignment */
    .realtime-header {
      width: 100%;
      display: flex;
      justify-content: flex-end;
      padding: 24px 24px 0 0; /* Padding prevents shadow clipping */
      box-sizing: border-box;
      overflow: visible; /* Allow close button to extend outside */
    }
    
    /* Status Pill - Liquid Glass Style */
    .connection-pill {
        /* Liquid Glass Effect */
        background: var(--glass-bg);
        backdrop-filter: blur(var(--glass-blur));
        -webkit-backdrop-filter: blur(var(--glass-blur));
        border: 1px solid var(--glass-border-subtle);
        box-shadow: 
            0 2px 8px rgba(0, 0, 0, 0.04),
            inset 0 1px 0 rgba(255, 255, 255, 0.4);

        border-radius: var(--radius-pill); /* Pill shape */
        padding: 0 14px; /* Horizontal padding */
        height: 34px;    /* Fixed Height */
        width: fit-content; /* 自动适应内容宽度（hug content） */
        min-width: fit-content; /* 确保不会被压缩 */
        flex-shrink: 0; /* 防止在 flex 容器中被压缩 */
        
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px; /* Gap between dot and text */
        
        position: relative;
        z-index: 10;
        overflow: visible;
            
        color: var(--pill-screen-text); /* Green text */
        font-weight: 600;
        font-size: 13px;
        /* Smooth transitions — explicitly list properties (avoid 'all' which
           breaks fit-content restoration by trying to animate width) */
        transition: background 0.3s cubic-bezier(0.25, 0.8, 0.25, 1),
                    color 0.3s cubic-bezier(0.25, 0.8, 0.25, 1),
                    box-shadow 0.3s cubic-bezier(0.25, 0.8, 0.25, 1),
                    border-color 0.3s cubic-bezier(0.25, 0.8, 0.25, 1),
                    opacity 0.3s cubic-bezier(0.25, 0.8, 0.25, 1),
                    transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        white-space: nowrap;
        opacity: 1; /* 默认可见，初始 fade-in 由 .pill-initial 控制 */
    }
    
    /* 首次加载 fade-in 动画（仅初始状态使用，后续 updateStatus 不会重复触发） */
    .connection-pill.pill-initial {
        animation: fadeInGlass 0.4s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
        animation-delay: 0.1s;
        opacity: 0;
    }
    
    @keyframes fadeInGlass {
        from {
            opacity: 0;
            transform: scale(0.95);
        }
        to {
            opacity: 1;
            transform: scale(1);
        }
    }

    /* Specular highlight for glass look */
    .connection-pill::before {
        content: "";
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        border-radius: var(--radius-pill);
        background: var(--glass-specular);
        pointer-events: none;
        z-index: -1;
        opacity: 0.6;
    }
    
    /* Interactive State - Liquid Glass Raised */
    .connection-pill.interactive {
        background: var(--glass-bg-hover);
        border-color: var(--glass-border);
        box-shadow: 
            0 3px 10px rgba(0, 0, 0, 0.05),
            inset 0 1px 0 rgba(255, 255, 255, 0.5);
        cursor: pointer;
    }

    /* Interactive - Enhanced specular */
    .connection-pill.interactive::before {
        background: var(--glass-specular);
        opacity: 0.8;
    }
    
    /* Bezel (Outer Ring) - Hidden in Liquid Glass style */
    .connection-pill .bezel {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        border-radius: var(--radius-pill);
        background: transparent;
        z-index: -2;
        opacity: 0;
        transition: opacity 0.3s ease;
    }
    
    .connection-pill.interactive .bezel {
        opacity: 0;
    }
    
    /* Face (Inner Surface) - Hidden in Liquid Glass style */
    .connection-pill .face {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        border-radius: var(--radius-pill);
        background: transparent;
        z-index: -1;
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    .connection-pill.interactive .face {
        opacity: 0;
    }

    /* Status Dot Style */
    .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background-color: currentColor; /* Inherit color from parent by default */
        flex-shrink: 0;
        transition: all 0.3s ease;
    }

    /* Connected State - Screen text color */
    .connection-pill.connected {
        color: var(--pill-screen-text);
        /* text-shadow inherited from global rule */
    }
    
    .connection-pill.connected .status-dot {
        background-color: var(--pill-screen-text);
        /* Only the dot glows - single layer is enough */
        box-shadow: 0 0 6px var(--pill-screen-text), 0 0 12px var(--pill-screen-text-glow);
    }
    
    @media (prefers-color-scheme: dark) {
        .connection-pill.connected .status-dot {
            /* Reduce glow spread in dark theme */
            box-shadow: 0 0 5px var(--pill-screen-text), 0 0 10px var(--pill-screen-text-glow);
        }
        
        /* Interactive button in dark theme - remove white edge glow */
        .connection-pill.interactive {
            /* Only use dark shadows, no white highlights */
            box-shadow: 
                5px 5px 10px var(--neu-shadow-dark),
                -2px -2px 6px rgba(255, 255, 255, 0.02); /* Minimal highlight */
        }
        
        /* Reduce white highlights on bezel and face in dark theme */
        .connection-pill.interactive .bezel {
            box-shadow: inset 1px 1px 2px rgba(255,255,255,0.02); /* Much darker */
        }
        
        .connection-pill.interactive .face {
            box-shadow: 
                inset 1px 1px 2px rgba(255,255,255,0.03),
                inset -1px -1px 2px rgba(0,0,0,0.3);
        }
        
        .connection-pill.interactive::before {
            /* Reduce screen gloss in dark theme */
            background: linear-gradient(145deg, rgba(255,255,255,0.03) 0%, transparent 100%);
        }
    }
    
    /* Apply glow to SVGs inside connected pill - handled by global rule now */
    
    /* Disconnected State - Red Text & Red Glowing Dot */
    .connection-pill.reconnect {
        color: var(--danger);
    }

    .connection-pill.reconnect .status-dot {
        background-color: var(--danger);
        box-shadow: 0 0 6px var(--danger), 0 0 12px rgba(255, 59, 48, 0.6);
    }
    
    @media (prefers-color-scheme: dark) {
        .connection-pill.reconnect .status-dot {
             box-shadow: 0 0 5px var(--danger), 0 0 10px rgba(255, 69, 58, 0.4);
        }
    }

    /* Offline State - Gray Text & Gray Dot (No Glow) */
    .connection-pill.offline {
        color: var(--text-tertiary);
    }
    
    .connection-pill.offline .status-dot {
        background-color: var(--text-tertiary);
        box-shadow: none; /* No glow for offline */
    }

    /* Waiting / Warning State */
    .connection-pill.waiting {
        color: var(--accent); /* Blue instead of Orange */
        /* Keep recessed style - no button shadow override */
        box-shadow: var(--pill-recessed-shadow);
    }
    
    .connection-pill.waiting .status-dot {
         background-color: var(--accent);
         box-shadow: 0 0 6px var(--accent), 0 0 12px var(--accent-soft);
    }
    
    @media (prefers-color-scheme: dark) {
        .connection-pill.waiting .status-dot {
             box-shadow: 0 0 5px #007AFF, 0 0 10px rgba(0, 122, 255, 0.3); /* Subtler for dark theme */
        }
    }

    /* Status Pill Close Button - Liquid Glass Style (matches .close-btn) */
    .connection-pill .pill-close-btn {
        position: absolute;
        top: -7px;
        right: -7px;
        width: 20px;
        height: 20px;
        padding: 0;
        border-radius: 50%;
        background: var(--glass-bg);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        border: 1px solid var(--glass-border-subtle);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        color: var(--text-secondary);
        opacity: 0;
        transform: scale(0.8);
        transition: opacity 0.2s ease, transform 0.2s ease, background 0.25s ease, box-shadow 0.25s ease, border-color 0.25s ease;
        z-index: 10;
        /* Liquid Glass Shadow */
        box-shadow: 
            0 2px 8px rgba(0, 0, 0, 0.08),
            inset 0 1px 0 rgba(255, 255, 255, 0.5);
    }

    /* Close Button Ring - Liquid Glass */
    .connection-pill .pill-close-btn::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: 50%;
        background: var(--glass-specular);
        z-index: -2;
        pointer-events: none;
        opacity: 0.5;
    }

    /* Close Button Face - Liquid Glass */
    .connection-pill .pill-close-btn::after {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: 50%;
        background: transparent;
        z-index: -1;
        transition: all 0.25s ease;
        pointer-events: none;
    }

    .connection-pill .pill-close-btn svg {
        width: 8px;
        height: 8px;
        position: relative;
        z-index: 1;
        color: var(--text-secondary);
        stroke: currentColor;
        transition: all 0.25s ease;
    }

    .connection-pill.interactive:hover .pill-close-btn {
        opacity: 1;
        transform: scale(1);
    }

    .connection-pill .pill-close-btn:hover {
        background: var(--glass-bg-hover);
        border-color: var(--glass-border);
        transform: scale(1.05);
        box-shadow: 
            0 4px 12px rgba(0, 0, 0, 0.12),
            inset 0 1px 0 rgba(255, 255, 255, 0.6);
    }

    .connection-pill .pill-close-btn:hover::after {
        background: transparent;
    }

    .connection-pill .pill-close-btn:hover svg {
        opacity: 1;
        color: var(--text-primary);
    }

    .connection-pill .pill-close-btn:active {
        transform: scale(0.95);
        background: var(--glass-bg-active);
        box-shadow: 
            0 1px 4px rgba(0, 0, 0, 0.1),
            inset 0 1px 2px rgba(0, 0, 0, 0.05);
    }

    .connection-pill .pill-close-btn:active::after {
        background: var(--neu-face-bg-active);
        box-shadow: var(--neu-face-shadow-active);
    }

    /* Realtime Center Layout */
    .realtime-center {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      padding: 0 12px 60px 12px; /* Side padding prevents button shadow clipping */
      box-sizing: border-box;
      overflow: visible; /* Ensure glow effects are not clipped */
    }

    .controls-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      overflow: visible; /* Ensure glow effects are not clipped */
    }

    .control-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      overflow: visible;
    }

    .control-label {
      font-size: 13px;
      font-weight: 500;
      color: var(--text-primary);
      letter-spacing: 0.5px;
    }

    #realtimeLabel.control-label {
        font-size: 15px; /* Realtime label becomes 15px */
    }

    /* Neumorphic Buttons - Liquid Glass Style */
    .neumorphic-btn {
      border: none;
      outline: none;
      background: var(--glass-bg);
      backdrop-filter: blur(var(--glass-blur));
      -webkit-backdrop-filter: blur(var(--glass-blur));
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      color: var(--text-secondary);
      transition: all 0.25s cubic-bezier(0.25, 0.8, 0.25, 1);
      padding: 0;
      overflow: visible;
      
      /* Liquid Glass Shadow - Subtle */
      box-shadow: 
        0 2px 8px rgba(0, 0, 0, 0.03),
        inset 0 1px 0 rgba(255, 255, 255, 0.4);
      
      /* Fade-in animation */
      animation: glassPopIn 0.4s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
      opacity: 0;
    }
    
    @keyframes glassPopIn {
        from {
            opacity: 0;
            transform: scale(0.9);
        }
        to {
            opacity: 1;
            transform: scale(1);
        }
    }
    
    /* Stagger animation delays for main buttons */
    .neumorphic-btn:nth-of-type(1) { animation-delay: 0.1s; }
    .neumorphic-btn:nth-of-type(2) { animation-delay: 0.15s; }
    .neumorphic-btn:nth-of-type(3) { animation-delay: 0.2s; }
    
    /* The Ring (Specular Highlight) */
    .neumorphic-btn::before {
        content: "";
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        border-radius: 50%;
        
        /* Specular gradient */
        background: var(--glass-specular);
        
        z-index: -2;
        pointer-events: none;
        opacity: 0.6;
    }
    
    /* The Face (Inner Glass Surface) */
    .neumorphic-btn::after {
        content: "";
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0; 
        border-radius: 50%;
        background: transparent;
            
        z-index: -1;
        transition: all 0.25s ease;
        pointer-events: none;
    }
    
    /* Hover State */
    .neumorphic-btn:hover {
      transform: translateY(-2px);
      background: var(--glass-bg-hover);
      border-color: var(--glass-border);
      box-shadow: 
        0 4px 12px rgba(0, 0, 0, 0.05),
        inset 0 1px 0 rgba(255, 255, 255, 0.5);
    }
    
    .neumorphic-btn:hover::after {
        background: transparent;
    }
    
    .neumorphic-btn:hover::before {
        opacity: 0.8;
    }

    /* Pressed / Active State */
    .neumorphic-btn:active, .neumorphic-btn.pressed {
      transform: translateY(0);
      background: var(--glass-bg-active);
      box-shadow: 
        0 2px 6px rgba(0, 0, 0, 0.03),
        inset 0 1px 2px rgba(0, 0, 0, 0.02);
    }
    
    .neumorphic-btn:active::after, .neumorphic-btn.pressed::after {
        background: transparent;
    }

    /* Button Sizes */
    .neumorphic-btn.large {
      width: 120px;
      height: 120px;
    }
    
    /* Adjust ring size for large button if needed */
    .neumorphic-btn.large::after {
        top: 0; left: 0; right: 0; bottom: 0;
    }

    .neumorphic-btn.small {
      width: 60px;
      height: 60px;
    }

    /* Icon Styling - Must be above layers */
    .neumorphic-btn svg, 
    .neumorphic-btn .btn-text,
    .neumorphic-btn .progress-ring {
      position: relative;
      z-index: 1;
      transition: all 0.25s ease;
    }
    
    .neumorphic-btn svg {
      color: var(--text-secondary);
    }
    
    .neumorphic-btn:hover svg {
        opacity: 1;
        color: var(--text-primary);
    }
    
    .neumorphic-btn:active svg {
        opacity: 1;
        color: var(--text-primary);
    }

    .neumorphic-btn.large svg {
      width: 52px;
      height: 52px;
      stroke-width: 3;
    }

    .neumorphic-btn.small svg {
      width: 20px;
      height: 20px;
      stroke-width: 2.5;
    }

    /* Active State (Running) - Green Glow & Light */
    .neumorphic-btn.large.active::after {
       /* Keep pressed state or just light up? 
          Usually light up. Let's keep it convex but glowing icon. */
       background: var(--neu-face-bg);
       box-shadow: var(--neu-face-shadow);
    }

    /* Override standard active styles for main button since we toggle SVGs */
    #mainStartBtn.active svg {
      filter: none;
    }
    
    /* Glow for icon-on - handled by global rule now */
    
    /* Main Start Button Icons Toggle */
    #mainStartBtn .icon-off {
        display: block;
        width: 56px; /* Updated size for new icon */
        height: 56px;
        color: var(--text-secondary);
        transition: opacity 0.3s ease, color 0.3s ease;
    }
    
    #mainStartBtn:hover .icon-off {
        opacity: 1; /* Darken on hover */
        color: var(--text-primary); /* Darken on hover */
    }
    
    #mainStartBtn .icon-on {
        display: none;
        width: 56px; /* Updated size for new icon */
        height: 56px;
    }

    #mainStartBtn.active .icon-off {
        display: none;
    }

    #mainStartBtn.active .icon-on {
        display: block;
        opacity: 1 !important; /* Always full brightness when active, even without hover */
        color: var(--power-green); /* Green color when active */
    }
    
    /* Ensure icon-on stays bright even on hover */
    #mainStartBtn.active:hover .icon-on {
        opacity: 1 !important;
        color: var(--power-green);
    }

    /* Special styling for Manual Sync Icon */
    .neumorphic-btn.small svg.icon-manual-sync {
      width: 24px; /* Slightly larger for better visibility */
      height: 24px;
    }
    
    /* Special styling for Export Icon */
    .neumorphic-btn.small svg.icon-export {
      width: 23px; /* Match manual sync icon size */
      height: 23px;
    }

    /* Work Area View */
    .work-area {
      display: none;
      flex-direction: column;
      height: 100%;
      animation: zoomIn 0.4s var(--ease-spring);
      overflow: visible;
    }
    
    .work-area.active {
      display: flex;
    }

    /* Compact Status Hero - Optimized Layout */
    .status-hero {
      background: var(--bg-card);
      border-radius: var(--radius-m);
      padding: 16px 16px 20px 16px;
      /* border: 1px solid var(--border); */
      box-shadow: var(--shadow-sm);
      position: relative;
      overflow: visible; /* Allow glow effects */
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .hero-header {
      display: flex;
      align-items: center;
        justify-content: space-between;
        width: 100%;
    }
    
    .hero-mode-info {
      display: flex;
      align-items: center;
        gap: 8px;
    }
    
    /* New compact mode icon */
    .hero-icon-sm {
        width: 22px;
        height: 22px;
        border-radius: 50%;
      display: flex;
      align-items: center;
        justify-content: center;
        flex-shrink: 0;
    }
    
    .hero-icon-sm svg {
        width: 12px;
        height: 12px;
    }

    .hero-mode-title {
        font-size: 15px;
        font-weight: 600;
        color: var(--text-primary);
    }

    /* Main metric layout */
    .hero-main-metric {
      display: flex;
        align-items: baseline;
        justify-content: center;
        gap: 8px;
        padding: 8px 0;
    }

    .count-display {
      font-size: 48px;
      font-weight: 700;
      letter-spacing: -0.02em;
      color: var(--text-primary);
      line-height: 1;
      font-variant-numeric: tabular-nums;
    }

    .metric-label {
        font-size: 13px;
        color: var(--text-secondary);
        font-weight: 500;
    }

    /* Action buttons container */
    .action-buttons {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: auto; /* Push to bottom */
    }

    .btn {
      width: 100%;
      padding: 10px;
      border-radius: var(--radius-btn);
      font-weight: 600;
      cursor: pointer;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: all 0.25s cubic-bezier(0.25, 0.8, 0.25, 1);
      position: relative;
      background: rgba(142, 142, 147, 0.18);
      color: var(--text-primary);
    }

    /* Button Specular Highlight - Hidden */
    .btn::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: var(--radius-btn);
        background: transparent;
        z-index: -2;
        pointer-events: none;
        opacity: 0;
    }
    
    /* Button Inner - Hidden */
    .btn::after {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: var(--radius-btn);
        background: transparent;
        z-index: -1;
        transition: all 0.25s ease;
        pointer-events: none;
    }
    
    .btn span, .btn svg {
        position: relative;
        z-index: 1;
    }
    
    .btn:hover {
        background: rgba(142, 142, 147, 0.22);
    }
    
    .btn:active {
        background: rgba(142, 142, 147, 0.12);
    }
    
    @media (prefers-color-scheme: dark) {
        .btn {
            background: rgba(118, 118, 128, 0.32);
            color: var(--text-primary);
        }
        .btn:hover {
            background: rgba(118, 118, 128, 0.40);
        }
        .btn:active {
            background: rgba(118, 118, 128, 0.24);
        }
    }

    .btn:active {
      box-shadow: 
        -3px -3px 6px var(--neu-shadow-light),
        3px 3px 6px var(--neu-shadow-dark);
    }
    
    .btn:active::after {
        background: var(--neu-face-bg-active);
        box-shadow: var(--neu-face-shadow-active);
    }

        .btn-primary {
      color: var(--text-primary);
      background: rgba(142, 142, 147, 0.18);
        }
    
        .btn-primary:hover {
      background: rgba(142, 142, 147, 0.22);
        }
    
    .btn-primary:active {
        background: rgba(142, 142, 147, 0.12);
    }
    
    .btn-primary::after {
        background: transparent;
    }
    
    @media (prefers-color-scheme: dark) {
        .btn-primary {
            background: rgba(118, 118, 128, 0.32);
            color: var(--text-primary);
        }
        .btn-primary:hover {
            background: rgba(118, 118, 128, 0.40);
        }
        .btn-primary:active {
            background: rgba(118, 118, 128, 0.24);
        }
    }

    .btn-secondary {
      color: var(--text-primary);
    }

    .btn-secondary:hover {
      background: rgba(142, 142, 147, 0.22);
        }
    
    .btn-secondary:hover::after {
        background: transparent;
    }

    .btn-danger {
        color: var(--danger);
    }
    
    .btn-danger:hover {
        box-shadow: 
          -7px -7px 14px var(--neu-shadow-light),
          7px 7px 14px var(--neu-shadow-dark);
    }
    
    .btn-danger:hover::after {
        background: var(--neu-face-bg-hover);
    }
    
    @media (prefers-color-scheme: dark) {
        .btn-danger {
            color: var(--danger);
        }
    }

    /* Log Area */
    .log-wrapper {
        flex: 1;
        min-height: 0;
        /* border: 1px solid var(--border); */
        border-radius: var(--radius-s);
        background: var(--bg-card);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        margin-bottom: 12px;
    }
    
    .log-header {
        padding: 6px 12px;
        background: rgba(0,0,0,0.02);
        /* border-bottom: 1px solid var(--border); */
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        height: 28px;
    }
    
    .log-title {
        font-size: 12px;
        font-weight: 600;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    .log-content {
        flex: 1;
        padding: 8px 12px;
        overflow-y: auto;
        font-family: "SF Mono", Menlo, monospace;
        font-size: 12px;
        line-height: 1.6;
        color: var(--text-secondary);
        white-space: pre-wrap;
        transition: all 0.3s ease;
    }
    
    .log-wrapper.collapsed .log-content {
        display: none;
    }
    .log-wrapper.collapsed {
        flex: 0 0 auto;
    }

    /* Info Box */
    .info-box {
      background: var(--accent-soft);
      /* border: 1px solid rgba(0, 122, 255, 0.1); */
      color: var(--accent);
      padding: 12px;
      border-radius: var(--radius-s);
      font-size: 12px;
      margin-bottom: 8px;
      display: none;
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0);
      backdrop-filter: blur(0px);
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
      
      /* Hidden state properties */
      opacity: 0;
      visibility: hidden; /* Use visibility instead of display:none */
      pointer-events: none;
      
      /* Transitions including visibility delay */
      transition: opacity 0.25s cubic-bezier(0.33, 1, 0.68, 1),
                  background 0.25s cubic-bezier(0.33, 1, 0.68, 1),
                  backdrop-filter 0.25s cubic-bezier(0.33, 1, 0.68, 1),
                  visibility 0s linear 0.25s; /* Delay hiding visibility */
    }

    /* Modal Overlay - Show State */
    .modal-overlay.show {
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(8px);
      transition-delay: 0s; /* No delay when showing */
    }

    .modal {
      width: 90%;
      max-width: 360px;
      background: var(--glass-bg);
      backdrop-filter: blur(var(--glass-blur));
      -webkit-backdrop-filter: blur(var(--glass-blur));
      border-radius: var(--radius-l);
      padding: 0;
      transform: scale(0.92) translateY(20px);
      opacity: 0;
      transition: transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1),
                  opacity 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      overflow: visible;
      position: relative;
      
      /* Liquid Glass Effect */
      border: 1px solid var(--glass-border);
      box-shadow: var(--glass-shadow);
    }

    .modal-overlay:not(.hidden) .modal {
      transform: scale(1) translateY(0);
      opacity: 1;
    }

    .modal-content {
        padding: 20px;
        overflow-y: auto;
        overflow-x: visible; /* Allow glow effects to show */
        flex: 0 1 auto;
        position: relative;
        z-index: 1;
        opacity: 0;
        transform: translateY(10px);
        transition: opacity 0.4s cubic-bezier(0.33, 1, 0.68, 1) 0.1s,
                    transform 0.4s cubic-bezier(0.33, 1, 0.68, 1) 0.1s;
        scrollbar-width: thin;
        scrollbar-color: var(--text-tertiary) transparent;
    }
    
    .modal-content::-webkit-scrollbar {
        width: 6px;
    }
    
    .modal-content::-webkit-scrollbar-track {
        background: transparent;
    }
    
    .modal-content::-webkit-scrollbar-thumb {
        background-color: var(--text-tertiary);
        border-radius: 3px;
    }
    
    .modal-content::-webkit-scrollbar-thumb:hover {
        background-color: var(--text-tertiary);
    }

    .modal-overlay:not(.hidden) .modal-content {
        opacity: 1;
        transform: translateY(0);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 20px 8px 20px; 
      border-bottom: 1px solid var(--divider);
      background: transparent;
      z-index: 10;
      position: relative;
      flex-shrink: 0;
      opacity: 0;
      transform: translateY(-10px);
      transition: opacity 0.3s cubic-bezier(0.33, 1, 0.68, 1) 0.05s,
                  transform 0.3s cubic-bezier(0.33, 1, 0.68, 1) 0.05s;
    }

    .modal-overlay:not(.hidden) .modal-header {
        opacity: 1;
        transform: translateY(0);
    }

    .modal-title {
      font-size: 15px;
      font-weight: 700;
      color: var(--text-primary);
    }
    
    /* Modal Tabs */
    .modal-tabs {
        display: flex;
        gap: 20px;
        align-items: center;
    }

    .tab-btn {
        background: transparent;
        border: none;
        padding:  0;
        font-size: 14px;
        font-weight: 600;
        color: var(--text-tertiary);
        cursor: pointer;
        position: relative;
        transition: color 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .tab-btn::after {
        content: '';
        position: absolute;
        bottom: -9px; /* Adjust based on header padding */
        left: 50%;
        right: 50%;
        height: 2px;
        background: var(--text-primary);
        border-radius: 2px;
        opacity: 0;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .tab-btn:hover {
        color: var(--text-secondary);
    }

    .tab-btn.active {
        color: var(--text-primary);
    }
    
    .tab-btn.active::after {
        left: 0;
        right: 0;
        opacity: 1;
    }
    
    /* Tab Content Animation */
    .tab-content {
        opacity: 0;
        transform: translateX(-20px);
        transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1), 
                    transform 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                    height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        display: none;
        overflow: visible; /* Allow glow effects */
    }
    
    .tab-content.active {
        opacity: 1;
        transform: translateX(0);
    }
    
    .tab-content.slide-out-left {
        opacity: 0;
        transform: translateX(-20px);
    }
    
    .tab-content.slide-out-right {
        opacity: 0;
        transform: translateX(20px);
    }
    
    .tab-content.slide-in-left {
        animation: slideInLeft 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }
    
    .tab-content.slide-in-right {
        animation: slideInRight 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }
    
    @keyframes slideInLeft {
        from {
            opacity: 0;
            transform: translateX(-20px);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }
    
    @keyframes slideInRight {
        from {
            opacity: 0;
            transform: translateX(20px);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }
    
    /* Modal buttons - proper height */
    .modal .btn {
      height: auto;
    }
    
    .close-btn {
        width: 26px;
        height: 26px;
        padding: 0;
        border-radius: 50%;
        background: var(--glass-bg);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        border: 1px solid var(--glass-border-subtle);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        color: var(--text-secondary);
        transition: all 0.25s cubic-bezier(0.25, 0.8, 0.25, 1);
        transform: scale(1);
        position: relative;
        font-weight: 500;
        
        /* Liquid Glass Shadow */
        box-shadow: 
          0 2px 8px rgba(0, 0, 0, 0.08),
          inset 0 1px 0 rgba(255, 255, 255, 0.5);
    }
    
    /* Close Button Ring - Liquid Glass */
    .close-btn::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: 50%;
        background: var(--glass-specular);
        z-index: -2;
        pointer-events: none;
        opacity: 0.5;
    }
    
    /* Close Button Face - Liquid Glass */
    .close-btn::after {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: 50%;
        background: transparent;
        z-index: -1;
        transition: all 0.25s ease;
        pointer-events: none;
    }
    
    .close-btn svg {
        position: relative;
        z-index: 1;
        transition: all 0.25s ease;
        color: var(--text-secondary);
        stroke: currentColor;
    }
    
    .close-btn:hover {
        background: var(--glass-bg-hover);
        border-color: var(--glass-border);
        transform: scale(1.05);
        box-shadow: 
          0 4px 12px rgba(0, 0, 0, 0.12),
          inset 0 1px 0 rgba(255, 255, 255, 0.6);
    }
    
    .close-btn:hover svg {
        opacity: 1;
        color: var(--text-primary) !important;
    }
    
    .close-btn:hover::after {
        background: transparent;
    }
    
    .close-btn:active {
        transform: scale(0.95);
        background: var(--glass-bg-active);
        box-shadow: 
          0 1px 4px rgba(0, 0, 0, 0.1),
          inset 0 1px 2px rgba(0, 0, 0, 0.05);
    }
    
    .close-btn:active::after {
        background: var(--neu-face-bg-active);
        box-shadow: var(--neu-face-shadow-active);
    }
    
    /* Upload Modal Icon - Liquid Glass Style */
    .neu-icon-large {
        background: var(--glass-bg);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        border: 1px solid var(--glass-border-subtle);
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08), inset 0 1px 0 rgba(255, 255, 255, 0.5);
    }
    
    .neu-icon-large svg {
        color: var(--text-secondary);
        stroke: currentColor;
    }

    @media (prefers-color-scheme: dark) {
        .neu-icon-large {
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
    }
    
    /* Upload Modal Button Styling - Liquid Glass */
    #select-files-btn {
        background: var(--glass-bg);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        border: 1px solid var(--glass-border-subtle);
        border-radius: var(--radius-input);
        box-shadow: 
            0 4px 16px rgba(0, 0, 0, 0.08),
            inset 0 1px 0 rgba(255, 255, 255, 0.5);
        transition: all 0.25s cubic-bezier(0.25, 0.8, 0.25, 1);
    }
    
    #select-files-btn::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: var(--radius-input);
        background: var(--glass-specular);
        z-index: -2;
        pointer-events: none;
        opacity: 0.5;
    }
    
    #select-files-btn::after {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: var(--radius-input);
        background: transparent;
        z-index: -1;
        transition: all 0.25s ease;
        pointer-events: none;
    }
    
    #select-files-btn:hover {
        background: var(--glass-bg-hover);
        border-color: var(--glass-border);
        transform: translateY(-1px);
        box-shadow: 
            0 6px 20px rgba(0, 0, 0, 0.12),
            inset 0 1px 0 rgba(255, 255, 255, 0.6);
    }
    
    #select-files-btn:hover::after {
        background: transparent;
    }
    
    #select-files-btn:active {
        transform: translateY(0);
        background: var(--glass-bg-active);
        box-shadow: 
            0 2px 8px rgba(0, 0, 0, 0.1),
            inset 0 1px 2px rgba(0, 0, 0, 0.05);
    }
    
    #select-files-btn:active::after {
        background: transparent;
    }
    
    @media (prefers-color-scheme: dark) {
        #select-files-btn {
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }
    }
    
    /* Upload Modal - Prevent scroll */
    #uploadGifOverlay .modal {
        max-height: 90vh;
        overflow: visible;
    }

    #uploadGifOverlay .modal-content {
        overflow: visible;
    }

    /* QR Code Zoom Modal */
    #qrZoomOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.25s ease, visibility 0.25s ease;
      cursor: zoom-out;
    }

    #qrZoomOverlay.show {
      opacity: 1;
      visibility: visible;
    }

    #qrZoomOverlay .qr-zoom-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      transform: scale(0.9);
      transition: transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    #qrZoomOverlay.show .qr-zoom-content {
      transform: scale(1);
    }

    #qrZoomOverlay .qr-zoom-image {
      width: 200px;
      height: 200px;
      border-radius: var(--radius-m);
      background: white;
      padding: 12px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
    }

    #qrZoomOverlay .qr-zoom-label {
      font-size: 14px;
      color: rgba(255, 255, 255, 0.9);
      font-weight: 500;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    /* QR Code clickable style */
    .qr-clickable {
      cursor: zoom-in;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .qr-clickable:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .qr-clickable:active {
      transform: scale(1.02);
    }
    
    /* Hide number input spinners */
    input[type=number]::-webkit-inner-spin-button, 
    input[type=number]::-webkit-outer-spin-button { 
        -webkit-appearance: none; 
        margin: 0; 
    }

    /* Input Styles - Liquid Glass Style */
    .input-wrapper {
      display: flex;
      align-items: center;
      background: rgba(142, 142, 147, 0.12);
      border-radius: var(--radius-input);
      padding: 0 14px;
      height: 36px;
      border: 2px solid transparent;
      transition: all 0.25s cubic-bezier(0.25, 0.8, 0.25, 1);
      position: relative;
    }
    
    /* Subtle inner highlight for depth */
    .input-wrapper::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: var(--radius-input);
        background: transparent;
        pointer-events: none;
        z-index: -1;
        opacity: 0;
    }
    
    @media (prefers-color-scheme: dark) {
        .input-wrapper {
            background: rgba(118, 118, 128, 0.24);
        }
    }
    
    .input-wrapper:focus-within {
        border-color: var(--focus-blue);
        box-shadow: 0 0 0 3px var(--focus-blue-glow);
    }

    .input-prefix {
        color: var(--text-secondary);
        font-size: 13px;
        margin-right: 8px;
        font-weight: 500;
        white-space: nowrap;
        position: relative;
        z-index: 1;
    }

    /* Reset default input styles for use inside wrapper */
    .input-wrapper input {
        border: none;
        background: transparent;
        position: relative;
        z-index: 1;
        color: var(--text-secondary); /* Changed to grey */
        font-weight: 400;
        padding: 0;
        margin: 0;
        width: 100%;
        height: 100%;
        outline: none;
        box-shadow: none;
        font-size: 13px;
    }
    
    /* Focus state for input wrapper (applied via JS or :focus-within if wrapper supported it, 
       but here we likely target the wrapper based on input focus if structure allows, 
       or target input itself if wrapper style is on input) */
    /* Assuming .input-wrapper styles the container, we need to see how it's defined.
       Searching for .input-wrapper definition... */
    
    /* Placeholder color */
    .input-wrapper input::placeholder {
        color: var(--text-tertiary);
    }
    
    /* User ID Display Container - Liquid Glass Style */
    .user-id-display {
        background: rgba(142, 142, 147, 0.12);
        padding: 0 14px;
        height: 36px;
        border-radius: var(--radius-input);
        display: flex;
        align-items: center;
        justify-content: space-between;
        position: relative;
        border: 2px solid transparent;
    }
    
    @media (prefers-color-scheme: dark) {
        .user-id-display {
            background: rgba(118, 118, 128, 0.24);
        }
    }
    
    /* Hide scrollbar in User ID display */
    .user-id-display .id-content {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none; /* Firefox */
        -ms-overflow-style: none; /* IE/Edge */
        margin-right: 8px;
        white-space: nowrap;
        flex: 1; /* Allow content to take available space */
        position: relative;
        z-index: 1;
    }
    
    .user-id-display .id-content::-webkit-scrollbar {
        display: none; /* Chrome/Safari/Webkit */
        width: 0;
        height: 0;
    }
    
    .user-id-display::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: var(--radius-s);
        background: linear-gradient(145deg, transparent 0%, rgba(255,255,255,0.1) 100%);
        pointer-events: none;
        z-index: -1;
        opacity: 0.5;
    }
    
    @media (prefers-color-scheme: dark) {
        .user-id-display::before {
            background: linear-gradient(145deg, transparent 0%, rgba(255,255,255,0.05) 100%);
        }
    }
    
    .user-id-display #displayUserId {
        color: var(--logo-color-primary); /* Changed to blue */
        font-family: 'SF Mono', 'Menlo', monospace;
        font-size: 13px;
        font-weight: 500;
        letter-spacing: 0.5px;
        position: relative;
        z-index: 1;
    }
    
    .user-id-display button {
        position: relative;
        z-index: 1;
    }

    /* Toast - Liquid Glass Style */
    .toast {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%) translateY(-100px);
      background: var(--glass-bg);
      backdrop-filter: blur(var(--glass-blur));
      -webkit-backdrop-filter: blur(var(--glass-blur));
      border: 1px solid var(--glass-border-subtle);
      border-radius: var(--radius-xl);
      padding: 8px 12px;
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.5);
      font-size: 13px;
      font-weight: 500;
      color: var(--text-primary);
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: all 0.5s var(--ease-spring);
      white-space: nowrap;
      width: fit-content;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    @media (prefers-color-scheme: dark) {
        .toast {
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.35),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }
    }
    
    .toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
      pointer-events: auto;
    }
    
    .toast-icon {
      width: 14px;
      height: 14px;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .toast-icon svg {
      width: 100%;
      height: 100%;
    }
    
    .toast.success .toast-icon {
      color: var(--success);
    }
    
    .toast.error .toast-icon {
      color: var(--danger);
    }
    
    .toast.loading .toast-icon {
      color: var(--text-secondary);
    }
    
    .toast.loading .toast-icon svg {
      stroke: currentColor;
    }
    
    .toast.info .toast-icon {
      color: var(--info);
    }
    
    .toast.warning .toast-icon {
      color: var(--warning);
    }
    
    .toast-action {
      cursor: pointer;
      text-decoration: underline;
      text-underline-offset: 2px;
      margin-left: 6px;
      transition: opacity 0.2s ease;
    }
    
    .toast-action:hover {
      opacity: 0.8;
    }

    /* Utilities */
    .hidden { display: none !important; }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    @keyframes zoomIn {
      from { opacity: 0; transform: scale(0.92); }
      to { opacity: 1; transform: scale(1); }
    }
    
    /* Minimized State Styles */
    .minimized-toolbar {
        display: none;
        background: transparent;
        border: none;
        padding: 4px 4px 4px 12px;
        align-items: center;
        justify-content: space-between;
        box-shadow: none;
        height: 100%;
        animation: zoomIn 0.3s var(--ease-spring);
    }
    
    .app.minimized .minimized-toolbar {
        display: flex;
    }

    .minimized-brand {
      display: flex;
        align-items: center;
        gap: 6px;
        color: var(--text-primary);
    }
    
    .minimized-logo-box {
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .minimized-logo-box svg {
      display: block;
        width: 18px;
        height: 18px;
      /* Skeuomorphism - Embossed/Inset effect at path level */
      filter: drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5)) drop-shadow(0 -0.5px 0.5px rgba(0, 0, 0, 0.15));
    }

    @media (prefers-color-scheme: dark) {
      .minimized-logo-box svg {
        filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3)) drop-shadow(0 -0.5px 0.5px rgba(255, 255, 255, 0.05));
      }
    }
    
    .minimized-title {
      font-family: 'Archivo Black', sans-serif;
      font-weight: 400;
      font-size: 15px;
      margin-top: 2px;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      /* Skeuomorphic text shadow - embedded/engraved effect */
      text-shadow: 0 1px 1px rgba(255, 255, 255, 0.5);
    }
    
    @media (prefers-color-scheme: dark) {
      .minimized-title {
        text-shadow: 0 1px 1px rgba(0, 0, 0, 0.3);
      }
    }
    
    /* Minimized Toolbar Button - Liquid Glass Style (same as icon-btn) */
    .minimized-btn {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        border: 1px solid var(--glass-border-subtle);
        outline: none;
        background: var(--glass-bg);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.25s cubic-bezier(0.25, 0.8, 0.25, 1);
        position: relative;
        padding: 2px;
        overflow: visible;
        
        /* Liquid Glass Shadow */
        box-shadow: 
            0 2px 8px rgba(0, 0, 0, 0.08),
            inset 0 1px 0 rgba(255, 255, 255, 0.5);
    }
    
    /* Icon Styling */
    .minimized-btn svg {
        width: 15px; 
        height: 15px;
        color: var(--text-secondary);
        transition: all 0.25s ease;
        filter: drop-shadow(0 1px 1px rgba(255, 255, 255, 0.5));
    }
    
    @media (prefers-color-scheme: dark) {
        .minimized-btn {
            box-shadow: 
                0 2px 8px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }
        .minimized-btn svg {
            filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
        }
    }
    
    /* Hover State */
    .minimized-btn:hover {
        transform: scale(1.05);
        background: var(--glass-bg-hover);
        border-color: var(--glass-border);
        box-shadow: 
            0 4px 12px rgba(0, 0, 0, 0.12),
            inset 0 1px 0 rgba(255, 255, 255, 0.6);
    }
    
    .minimized-btn:hover .neu-icon-inner {
        background: transparent;
    }
    
    .minimized-btn:hover svg {
        opacity: 1;
        color: var(--text-primary);
    }
    
    /* Active State */
    .minimized-btn:active {
        transform: scale(0.95);
        background: var(--glass-bg-active);
        box-shadow: 
            0 1px 4px rgba(0, 0, 0, 0.1),
            inset 0 1px 2px rgba(0, 0, 0, 0.05);
    }
    
    .minimized-btn:active .neu-icon-inner {
        background: transparent;
    }
    
    .app.minimized .header {
        display: none;
    }
    
    /* Theme Specific Images */
    img.no-invert {
        filter: none !important;
      }

    /* SVG Icons */
    .svg-icon {
        width: 16px;
        height: 16px;
        stroke-width: 2.5;
        stroke: currentColor;
        fill: none;
        stroke-linecap: round;
        stroke-linejoin: round;
    }
    
    .svg-icon-sm {
        width: 15px;
        height: 15px;
    }

    /* Apple Switch - Liquid Glass Style */
    .switch {
      position: relative;
      display: inline-block;
      width: 46px;
      height: 28px;
      flex-shrink: 0;
    }

    .switch input { 
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(142, 142, 147, 0.15);
      transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      border-radius: 34px;
    }

    /* Track subtle highlight */
    .slider::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 34px;
      background: transparent;
      pointer-events: none;
      z-index: -1;
      opacity: 0;
    }

    .slider::after {
      position: absolute;
      content: "";
      height: 24px;
      width: 24px;
      left: 2px;
      bottom: 2px;
      background: white;
      transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      border-radius: 50%;
      z-index: 2;
      box-shadow: 
        0 2px 6px rgba(0, 0, 0, 0.15),
        0 1px 2px rgba(0, 0, 0, 0.1);
    }

    input:checked + .slider {
      background: var(--switch-active-gradient);
    }

    input:checked + .slider::before {
      background: transparent;
      opacity: 0;
    }

    input:checked + .slider::after {
      transform: translateX(18px);
      box-shadow: 
        0 2px 6px rgba(0, 0, 0, 0.2),
        0 1px 2px rgba(0, 0, 0, 0.1);
    }
    
    @media (prefers-color-scheme: dark) {
        .slider {
            background: rgba(118, 118, 128, 0.32);
        }
        .slider::after {
            background: #FFFFFF;
        }
    }

    @media (prefers-color-scheme: dark) {
      /* Adjust thumb (::after) reflection for dark theme */
      .slider::after {
        box-shadow: 
          -3px -3px 6px var(--neu-shadow-light),
          3px 3px 6px var(--neu-shadow-dark),
          inset 1px 1px 1px rgba(255,255,255,0.08); /* Much subtler inner highlight */
      }
      
      input:checked + .slider {
        box-shadow: 
          inset 2px 2px 4px rgba(0, 0, 0, 0.4),
          inset -1px -1px 2px rgba(255, 255, 255, 0.08),
          0 0 5px var(--pill-screen-text-glow); /* Match status pill glow */
      }
      
      input:checked + .slider::before {
        background: linear-gradient(145deg, transparent 0%, rgba(255,255,255,0.08) 100%);
        opacity: 0.6;
      }
      
      input:checked + .slider::after {
        box-shadow: 
          -3px -3px 6px rgba(255, 255, 255, 0.1),
          3px 3px 6px rgba(0, 0, 0, 0.4),
          inset 1px 1px 1px rgba(255,255,255,0.15); /* Much subtler inner highlight */
      }
      
      .slider::before {
        background: linear-gradient(145deg, transparent 0%, rgba(255,255,255,0.05) 100%);
      }
    }

    /* Export GIF Button & Animations */
    /* Export GIF Button & Animations */
    #exportGifBtn {
        position: relative;
        overflow: visible; 
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.4s cubic-bezier(0.33, 1, 0.68, 1); /* Apple easeOut */
        color: var(--text-primary); /* Match other .icon-btn */
        padding: 0; /* Remove padding to center content exactly */
    }
    
    /* Progress Ring */
    .progress-ring {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.4s ease-out; /* Smooth fade out */
        z-index: 10;
    }
    
    /* 确保非导出状态下进度环完全隐藏 */
    #exportGifBtn:not(.exporting) .progress-ring {
        opacity: 0 !important;
    }
    
    .progress-ring__circle {
        fill: transparent;
        stroke: var(--unified-green); /* Green color */
        stroke-width: 5.5; /* Thicker stroke */
        stroke-linecap: round;
        transition: stroke-dashoffset 0.2s linear, stroke 0.3s ease;
        /* filter handled by global rule now */
    }
    
    /* Keep progress ring green on hover */
    #exportGifBtn.exporting:hover .progress-ring__circle {
        stroke: var(--unified-green); /* Keep green color */
    }

    /* Success State */
    #exportGifBtn.success {
        background-color: var(--success) !important;
        color: white !important;
        transform: scale(1.05); /* Subtle pulse */
        opacity: 1 !important; /* Force opacity to 100% in success state */
    }
    
    #exportGifBtn.success:hover {
        opacity: 1 !important; /* Maintain 100% opacity on hover in success state */
    }
    
    #exportGifBtn.success .progress-ring {
        opacity: 0;
    }

    /* Icon Morphing */
    .icon-wrapper {
        position: relative;
        width: 16px;
        height: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .icon-gif, .icon-stop, .icon-folder {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1); /* Bouncy spring */
        pointer-events: none;
        transform-origin: center center;
    }

    .icon-stop {
        opacity: 0;
        transform: scale(0.55) rotate(45deg);
        stroke-width: 2.5 !important; /* 更明显的加粗效果 */
    }
    
    /* 导出中且悬停时显示停止图标 */
    #exportGifBtn.exporting:hover .icon-gif {
        opacity: 0;
        transform: scale(0.6) rotate(-45deg);
    }
    
    #exportGifBtn.exporting:hover .icon-stop {
        opacity: 1;
        transform: scale(0.91) rotate(0deg);
    }

    .icon-folder {
        opacity: 0;
        transform: scale(0.4) rotate(45deg);
    }
    
    #exportGifBtn.success .icon-gif {
        opacity: 0;
        transform: scale(0.4) rotate(-45deg);
    }
    
    #exportGifBtn.success .icon-folder {
        opacity: 1;
        transform: scale(1) rotate(0deg);
    }

    /* Splash Effect */
    .splash-particle {
        position: absolute;
        width: 3px; /* Smaller particles */
        height: 3px;
        background: var(--success);
        border-radius: 50%;
        pointer-events: none;
        opacity: 0;
        z-index: 100;
      }
    
    @keyframes splash-anim {
        0% { transform: translate(0, 0) scale(1); opacity: 0.8; }
        50% { opacity: 1; }
        100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
    }
    /* ========================================
       Start Screen / Realtime Mode UI (Neumorphic)
       ======================================== */
    .realtime-header {
        display: flex;
        justify-content: flex-end; /* Right align status */
        padding: 16px 0px;
        top: 0;
        left: 0;
        right: 0;
        z-index: 10;
        pointer-events: none;
        overflow: visible; /* Allow close button to extend outside */
    }
    
    .realtime-header > * {
        pointer-events: auto;
    }
    
    .realtime-center {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 32px;
        margin-top: -20px; /* Optical centering adjustment */
        overflow: visible; /* Ensure glow effects are not clipped */
    }
    
    /* Controls Row - 3 Buttons Layout */
    .controls-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        width: 100%;
        overflow: visible; /* Ensure glow effects are not clipped */
    }
    
    .control-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        overflow: visible; /* Ensure glow effects are not clipped */
    }
    
    /* Control label hover removed - use static primary color */
    
    /* Duplicated styles removed */
  </style>
  <script>
    // GitHub 图片资源基础 URL
    const IMAGE_BASE_URL = 'https://raw.githubusercontent.com/BorderWalker99/figma-plugin-figma_sync/refs/heads/main/images/';
    
    // 根据主题获取二维码（使用 GitHub URL）
    function getQRCodeURI(isDark) {
      return {
        google: IMAGE_BASE_URL + (isDark ? 'qr-google-white.png' : 'qr-google-black.png'),
        googleScreenshot: IMAGE_BASE_URL + (isDark ? 'qr-google-white.png' : 'qr-google-black.png'),
        googleAlbum: IMAGE_BASE_URL + (isDark ? 'qr-google-album-white.png' : 'qr-google-album-black.png'),
        icloud: IMAGE_BASE_URL + (isDark ? 'qr-icloud-white.png' : 'qr-icloud-black.png'),
        icloudScreenshot: IMAGE_BASE_URL + (isDark ? 'qr-icloud-white.png' : 'qr-icloud-black.png'),
        icloudAlbum: IMAGE_BASE_URL + (isDark ? 'qr-icloud-album-white.png' : 'qr-icloud-album-black.png')
      };
    }
  </script>
</head>

<body>
  <div class="app">
    <!-- Header -->
    <div class="header">
      <div class="brand">
        <div class="logo-box">
          <svg width="18" height="18" viewBox="0 0 39 39" fill="none" xmlns="http://www.w3.org/2000/svg">
            <g clip-path="url(#clip0_1184_47)">
              <path d="M22.6328 0.916016H10.1807C4.65782 0.916016 0.180664 5.39317 0.180664 10.916V23.3681C0.180664 28.891 4.65782 33.3681 10.1807 33.3681H22.6328C28.1556 33.3681 32.6328 28.891 32.6328 23.3681V10.916C32.6328 5.39317 28.1556 0.916016 22.6328 0.916016Z" fill="#007AFF" fill-opacity="0.5"/>
              <path d="M28.6328 5.91602H16.1807C10.6578 5.91602 6.18066 10.3932 6.18066 15.916V28.3681C6.18066 33.891 10.6578 38.3681 16.1807 38.3681H28.6328C34.1556 38.3681 38.6328 33.891 38.6328 28.3681V15.916C38.6328 10.3932 34.1556 5.91602 28.6328 5.91602Z" fill="#007AFF"/>
              <g clip-path="url(#clip1_1184_47)">
                <path d="M22.4443 22.4091C22.4443 20.5015 23.9907 18.9551 25.8983 18.9551C27.8059 18.9551 29.3523 20.5015 29.3523 22.4091C29.3523 24.3167 27.8059 25.8631 25.8983 25.8631C23.9907 25.8631 22.4443 24.3167 22.4443 22.4091Z" fill="white"/>
                <path d="M25.8593 11.5872C25.9486 11.5803 26.0391 11.5762 26.1301 11.5762C28.0375 11.5763 29.5835 13.123 29.5835 15.0305C29.5833 16.9379 28.0374 18.4837 26.1301 18.4839C26.039 18.4839 25.9486 18.4789 25.8593 18.472V18.4848H22.8638C22.76 18.4848 22.6758 18.4006 22.6758 18.2968V11.7642C22.6758 11.6603 22.76 11.5762 22.8638 11.5762H25.8593V11.5872Z" fill="white"/>
                <path d="M19.023 11.5872C18.9338 11.5803 18.8433 11.5762 18.7522 11.5762C16.8448 11.5763 15.2988 13.123 15.2988 15.0305C15.299 16.9379 16.8449 18.4837 18.7522 18.4839C18.8433 18.4839 18.9337 18.4789 19.023 18.472V18.4848H22.0185C22.1224 18.4848 22.2065 18.4006 22.2065 18.2968V11.7642C22.2065 11.6603 22.1224 11.5762 22.0185 11.5762H19.023V11.5872Z" fill="white"/>
                <path d="M19.023 18.9661C18.9338 18.9592 18.8433 18.9551 18.7522 18.9551C16.8448 18.9553 15.2988 20.502 15.2988 22.4094C15.299 24.3168 16.8449 25.8626 18.7522 25.8628C18.8433 25.8628 18.9337 25.8578 19.023 25.8509V25.8637H22.0185C22.1224 25.8637 22.2065 25.7795 22.2065 25.6757V19.1431C22.2065 19.0392 22.1224 18.9551 22.0185 18.9551H19.023V18.9661Z" fill="white"/>
                <path d="M19.023 26.3489C18.9338 26.342 18.8433 26.3379 18.7522 26.3379C16.8448 26.3381 15.2988 27.8848 15.2988 29.7922C15.299 31.6996 16.8449 33.2454 18.7522 33.2456C20.5442 33.2456 22.018 31.8813 22.19 30.1346H22.2065V26.5259C22.2065 26.4221 22.1224 26.3379 22.0185 26.3379H19.023V26.3489Z" fill="white"/>
              </g>
            </g>
            <defs>
              <clipPath id="clip0_1184_47">
                <rect width="39" height="39" fill="white"/>
              </clipPath>
              <clipPath id="clip1_1184_47">
                <rect width="15.98" height="22.56" fill="white" transform="translate(14.416 10.8633)"/>
              </clipPath>
            </defs>
          </svg>
      </div>
        <div>
          <div class="app-title">SYNC</div>
        </div>
      </div>
      <div class="header-actions">
        <button id="openFolder" class="icon-btn" data-tooltip="打开文件夹" data-i18n-tooltip="tooltip_open_folder">
           <div class="neu-icon-inner">
           <!-- Increased stroke-width to 3 and added style attribute to force it -->
           <svg class="svg-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" style="transform: scale(0.85); stroke-width: 2.9px !important;">
             <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
           </svg>
           </div>
        </button>
        <button id="openSettings" class="icon-btn" data-tooltip="设置" data-i18n-tooltip="tooltip_settings">
           <div class="neu-icon-inner">
           <svg class="svg-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" style="stroke-width: 2.4px !important;">
             <circle cx="12" cy="12" r="3"></circle>
             <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
           </svg>
           </div>
        </button>
        <button id="toggleMinimize" class="icon-btn" data-tooltip="最小化窗口" data-i18n-tooltip="tooltip_minimize">
            <!-- Icon will be updated by JS, but default is minimize -->
            <div class="neu-icon-inner">
            <svg id="minimizeIcon" class="svg-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" style="stroke-width: 2.5px !important;">
              <polyline points="4 14 10 14 10 20"></polyline>
              <polyline points="20 10 14 10 14 4"></polyline>
            </svg>
            </div>
        </button>
      </div>
    </div>
    
    <!-- Update Banner -->
    <div class="update-banner" id="updateBanner">
      <div class="update-banner-content">
        <div class="update-banner-info">
          <svg class="update-banner-icon" viewBox="0 0 24 24" fill="currentColor">
            <path d="M19 9l1.25-2.75L23 5l-2.75-1.25L19 1l-1.25 2.75L15 5l2.75 1.25L19 9zm-7.5.5L9 4 6.5 9.5 1 12l5.5 2.5L9 20l2.5-5.5L17 12l-5.5-2.5z"/>
          </svg>
          <div class="update-banner-text" id="updateBannerText">发现新版本 v1.0.2</div>
        </div>
        <div class="update-banner-actions">
          <button class="update-banner-btn primary" id="updateBannerNow" data-i18n="banner_update_now">立即更新</button>
          <button class="update-banner-close" id="updateBannerClose">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
        </div>
      </div>
    </div>
    
    <!-- Minimized Toolbar (Visible only when minimized) -->
    <div class="minimized-toolbar">
        <div class="minimized-brand">
          <div class="minimized-logo-box">
            <svg width="18" height="18" viewBox="0 0 39 39" fill="none" xmlns="http://www.w3.org/2000/svg">
              <g clip-path="url(#clip0_1184_47_min)">
                <path d="M22.6328 0.916016H10.1807C4.65782 0.916016 0.180664 5.39317 0.180664 10.916V23.3681C0.180664 28.891 4.65782 33.3681 10.1807 33.3681H22.6328C28.1556 33.3681 32.6328 28.891 32.6328 23.3681V10.916C32.6328 5.39317 28.1556 0.916016 22.6328 0.916016Z" fill="#007AFF" fill-opacity="0.5"/>
                <path d="M28.6328 5.91602H16.1807C10.6578 5.91602 6.18066 10.3932 6.18066 15.916V28.3681C6.18066 33.891 10.6578 38.3681 16.1807 38.3681H28.6328C34.1556 38.3681 38.6328 33.891 38.6328 28.3681V15.916C38.6328 10.3932 34.1556 5.91602 28.6328 5.91602Z" fill="#007AFF"/>
                <g clip-path="url(#clip1_1184_47_min)">
                  <path d="M22.4443 22.4091C22.4443 20.5015 23.9907 18.9551 25.8983 18.9551C27.8059 18.9551 29.3523 20.5015 29.3523 22.4091C29.3523 24.3167 27.8059 25.8631 25.8983 25.8631C23.9907 25.8631 22.4443 24.3167 22.4443 22.4091Z" fill="white"/>
                  <path d="M25.8593 11.5872C25.9486 11.5803 26.0391 11.5762 26.1301 11.5762C28.0375 11.5763 29.5835 13.123 29.5835 15.0305C29.5833 16.9379 28.0374 18.4837 26.1301 18.4839C26.039 18.4839 25.9486 18.4789 25.8593 18.472V18.4848H22.8638C22.76 18.4848 22.6758 18.4006 22.6758 18.2968V11.7642C22.6758 11.6603 22.76 11.5762 22.8638 11.5762H25.8593V11.5872Z" fill="white"/>
                  <path d="M19.023 11.5872C18.9338 11.5803 18.8433 11.5762 18.7522 11.5762C16.8448 11.5763 15.2988 13.123 15.2988 15.0305C15.299 16.9379 16.8449 18.4837 18.7522 18.4839C18.8433 18.4839 18.9337 18.4789 19.023 18.472V18.4848H22.0185C22.1224 18.4848 22.2065 18.4006 22.2065 18.2968V11.7642C22.2065 11.6603 22.1224 11.5762 22.0185 11.5762H19.023V11.5872Z" fill="white"/>
                  <path d="M19.023 18.9661C18.9338 18.9592 18.8433 18.9551 18.7522 18.9551C16.8448 18.9553 15.2988 20.502 15.2988 22.4094C15.299 24.3168 16.8449 25.8626 18.7522 25.8628C18.8433 25.8628 18.9337 25.8578 19.023 25.8509V25.8637H22.0185C22.1224 25.8637 22.2065 25.7795 22.2065 25.6757V19.1431C22.2065 19.0392 22.1224 18.9551 22.0185 18.9551H19.023V18.9661Z" fill="white"/>
                  <path d="M19.023 26.3489C18.9338 26.342 18.8433 26.3379 18.7522 26.3379C16.8448 26.3381 15.2988 27.8848 15.2988 29.7922C15.299 31.6996 16.8449 33.2454 18.7522 33.2456C20.5442 33.2456 22.018 31.8813 22.19 30.1346H22.2065V26.5259C22.2065 26.4221 22.1224 26.3379 22.0185 26.3379H19.023V26.3489Z" fill="white"/>
                </g>
              </g>
              <defs>
                <clipPath id="clip0_1184_47_min">
                  <rect width="39" height="39" fill="white"/>
                </clipPath>
                <clipPath id="clip1_1184_47_min">
                  <rect width="15.98" height="22.56" fill="white" transform="translate(14.416 10.8633)"/>
                </clipPath>
              </defs>
            </svg>
          </div>
          <span class="minimized-title">SYNC</span>
          </div>
         <button class="minimized-btn" onclick="toggleMinimize()">
       <div class="neu-icon-inner">
           <svg class="svg-icon" style="width: 15px; height: 15px; stroke-width: 2.5px !important;" viewBox="0 0 24 24"><polyline points="13 5 19 5 19 11"></polyline><polyline points="11 19 5 19 5 13"></polyline></svg>
       </div>
        </button>
    </div>

    <!-- Main Content -->
    <div class="main-content">

    <!-- 🧪 DEV ONLY: Toast Icons Preview -->
    <div id="toastIconsPreview" style="
      display: none;
      flex-direction: column;
      gap: 8px;
      padding: 12px;
      margin: 12px;
      background: var(--bg-card);
      border-radius: var(--radius-m);
      border: 1px dashed var(--border);
    ">
      <div style="font-size: 11px; color: var(--text-tertiary); margin-bottom: 4px;">🧪 Toast Icons Preview (DEV)</div>
      
      <!-- Success -->
      <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: var(--bg-inset); border-radius: var(--radius-s);">
        <div style="width: 14px; height: 14px; color: var(--success); display: flex; align-items: center;">
          <svg viewBox="0 0 24 24" fill="none"><circle cx="12" cy="12" r="10" fill="currentColor"/><path d="M16.5 9.5l-5.5 5.5-3-3" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/></svg>
        </div>
        <span style="font-size: 12px; color: var(--text-primary);">Success - 操作成功</span>
      </div>
      
      <!-- Error -->
      <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: var(--bg-inset); border-radius: var(--radius-s);">
        <div style="width: 14px; height: 14px; color: var(--danger); display: flex; align-items: center;">
          <svg viewBox="0 0 24 24" fill="none"><circle cx="12" cy="12" r="10" fill="currentColor"/><path d="M12 8v5M12 16.5v.5" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/></svg>
        </div>
        <span style="font-size: 12px; color: var(--text-primary);">Error - 操作失败</span>
      </div>
      
      <!-- Loading -->
      <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: var(--bg-inset); border-radius: var(--radius-s);">
        <div style="width: 14px; height: 14px; color: var(--text-secondary); display: flex; align-items: center;">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" style="animation: spin 1s linear infinite;"><circle cx="12" cy="12" r="10" stroke-dasharray="31.416" stroke-dashoffset="7.854" opacity="0.3"></circle><circle cx="12" cy="12" r="10" stroke-dasharray="31.416" stroke-dashoffset="23.562"></circle></svg>
        </div>
        <span style="font-size: 12px; color: var(--text-primary);">Loading - 加载中...</span>
      </div>
      
      <!-- Info -->
      <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: var(--bg-inset); border-radius: var(--radius-s);">
        <div style="width: 14px; height: 14px; color: var(--info); display: flex; align-items: center;">
          <svg viewBox="0 0 24 24" fill="none"><circle cx="12" cy="12" r="10" fill="currentColor"/><circle cx="12" cy="7.5" r="1.5" fill="white"/><path d="M12 11.5v5.5" stroke="white" stroke-width="2.5" stroke-linecap="round"/></svg>
        </div>
        <span style="font-size: 12px; color: var(--text-primary);">Info - 提示信息</span>
      </div>
      
      <!-- Warning -->
      <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: var(--bg-inset); border-radius: var(--radius-s);">
        <div style="width: 14px; height: 14px; color: var(--warning); display: flex; align-items: center;">
          <svg viewBox="0 0 24 24" fill="none"><circle cx="12" cy="12" r="10" fill="currentColor"/><path d="M12 8v5M12 16.5v.5" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/></svg>
        </div>
        <span style="font-size: 12px; color: var(--text-primary);">Warning - 警告信息</span>
      </div>
    </div>
    <!-- 🧪 END DEV ONLY -->

    <!-- Mode Selection (隐藏，默认实时模式) -->
    <div class="mode-selection hidden" id="modeSelection">
        <div>
          <h2 class="section-title" data-i18n="mode_select_title">选择同步模式</h2>
          <!-- <div class="section-desc">同步后将自动清理源文件以释放空间</div> -->
      </div>
        
        <div class="card-grid">
          <div class="feature-card" id="realtimeBtn">
            <div class="card-icon" style="color: var(--feature-realtime); background: var(--feature-realtime-bg);">
              <!-- Realtime: Lightning/Sync (Filled + Rounded) -->
              <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2.5" stroke-linejoin="round">
              <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"></path>
            </svg>
          </div>
            <div class="card-content">
              <div class="card-title" data-i18n="mode_realtime">实时模式</div>
              <div class="card-desc" data-i18n="mode_realtime_desc">手机截图 实时导入</div>
            </div>
            <div class="chevron">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>
            </div>
        </div>

          <div class="feature-card" id="manualBtn">
            <div class="card-icon" style="color: var(--accent); background: var(--accent-soft);">
               <!-- Manual: Download (Arrow + Bar) - Adjusted for visual weight -->
               <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="0">
                 <path d="M19 9h-4V3H9v6H5l7 8 7-8zM5 19v3h14v-3H5z"></path>
            </svg>
          </div>
            <div class="card-content">
              <div class="card-title" data-i18n="mode_manual">手动模式</div>
              <div class="card-desc" data-i18n="mode_manual_desc">云端截图 批量导入</div>
            </div>
            <div class="chevron">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>
            </div>
        </div>
      </div>
    </div>

    <!-- Work Area -->
      <div class="work-area" id="workArea">
        <div class="realtime-header">
                <div id="status" class="connection-pill pill-initial">等待中</div>
        </div>

        <div class="realtime-center">
            
            <div class="controls-row">
                <!-- Left: Manual Sync -->
                <div class="control-item">
                    <button id="manualSyncBtn" class="neumorphic-btn small">
                        <!-- Download Icon (与上传 icon 样式一致，箭头朝下) -->
                        <svg class="icon-manual-sync" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                            <!-- Bottom tray (与上传 icon 相同) -->
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <!-- Arrow head pointing down (上传是 17 8 12 3 7 8 朝上) -->
                            <polyline points="7 10 12 15 17 10"></polyline>
                            <!-- Arrow stem -->
                            <line x1="12" y1="3" x2="12" y2="15"></line>
                        </svg>
            
                        <!-- Progress Ring (Overlay on Edge) -->
                        <svg class="progress-ring progress-ring-manual" viewBox="0 0 60 60" style="position:absolute; width:100%; height:100%; top:0; left:0; pointer-events:none; z-index: 10; transform: rotate(-90deg); overflow: visible;">
                             <!-- Progress Circle -->
                             <circle class="progress-ring__circle" r="27.5" cx="30" cy="30" 
                                style="
                                    stroke-width: 5; 
                                    stroke: var(--unified-green); 
                                    fill: transparent; 
                                    stroke-linecap: round;
                                "/>
                        </svg>
                    </button>
                    <span class="control-label" data-i18n="label_manual_sync">手动同步</span>
        </div>

                <!-- Center: Realtime Sync -->
                <div class="control-item">
                    <button id="mainStartBtn" class="neumorphic-btn large">
                        <!-- Off State Icon (Stroke-based power icon) -->
                        <svg class="icon-off" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                            <!-- Power stem -->
                            <line x1="12" y1="2" x2="12" y2="12"></line>
                            <!-- Arc (broken circle) -->
                            <path d="M18.36 6.64A9 9 0 1 1 5.64 6.64"></path>
                        </svg>

                        <!-- On State Icon (Stroke-based power icon - green) -->
                        <svg class="icon-on" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                            <!-- Power stem -->
                            <line x1="12" y1="2" x2="12" y2="12"></line>
                            <!-- Arc (broken circle) -->
                            <path d="M18.36 6.64A9 9 0 1 1 5.64 6.64"></path>
                        </svg>
                    </button>
                    <span id="realtimeLabel" class="control-label" data-i18n="label_realtime_sync" style="transition: color 0.3s ease;">实时同步</span>
        </div>

                <!-- Right: Export GIF -->
                <div class="control-item">
                    <button id="exportGifBtn" class="neumorphic-btn small">
                        <!-- Export Icon (Stroke-based external link style) -->
                        <svg class="icon-export" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                            <!-- Rounded rectangle with open top-right corner -->
                            <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                            <!-- Arrow pointing up-right -->
                            <polyline points="15 3 21 3 21 9"></polyline>
                            <line x1="12" y1="12" x2="21" y2="3"></line>
                        </svg>
                        
                        <!-- Progress Ring (Overlay on Edge) -->
                        <svg class="progress-ring" viewBox="0 0 60 60" style="position:absolute; width:100%; height:100%; top:0; left:0; pointer-events:none; z-index: 10; transform: rotate(-90deg); overflow: visible;">
                             <!-- Progress Circle -->
                             <circle class="progress-ring__circle" r="27.5" cx="30" cy="30" 
                                style="
                                    stroke-width: 5; 
                                    stroke: var(--unified-green); 
                                    fill: transparent; 
                                    stroke-linecap: round;
                                "/>
                        </svg>
            </button>
                    <span class="control-label" data-i18n="label_export_gif">导出 GIF</span>
    </div>
  </div>

      </div>

        <!-- Hidden elements needed for logic but not UI -->
        <div class="info-box" id="infoBox" style="display:none;"></div>
        <div class="count-display" id="count" style="display:none;">0</div>
        <div id="modeSubtitle" style="display:none;"></div>
        <div class="log-wrapper" id="logContainer" style="display: none;">
          <div class="log-header" id="logHeader">
                <span class="log-title" data-i18n="log_title">系统日志</span>
                <span id="logToggleText" style="font-size:12px; color:var(--text-tertiary);" data-i18n="log_collapse">收起</span>
            </div>
          <div class="log-content" id="log"></div>
        </div>

        <!-- Legacy buttons (hidden) - KEEP THESE IDs for existing JS logic -->
        <button id="syncBtn" style="display:none;"></button>
        <button id="stopBtn" style="display:none;"></button>
        <button id="locateFrameBtn" style="display:none;"></button>
        <button id="backBtn" style="display:none;"></button>
          </div>
    </div>
  </div>


  <!-- Settings Modal -->
  <div id="settingsOverlay" class="modal-overlay">
    <div class="modal">
      <div class="modal-header">
        <div class="modal-tabs">
            <button class="tab-btn active" id="tabDesktop" data-i18n="tab_plugin">插件端</button>
            <button class="tab-btn" id="tabMobile" data-i18n="tab_mobile">手机端</button>
        </div>
        <button id="settingsClose" class="close-btn">
          <div class="neu-icon-inner" style="width: 26px; height: 26px; border-radius: 50%; display: flex; align-items: center; justify-content: center;">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </div>
        </button>
      </div>
      <div class="modal-content" id="settingsContent">
        
        <!-- Tab Content: Desktop -->
        <div id="contentDesktop" class="tab-content active">
        <!-- Cloud Provider Selection (开发者模式下显示) -->
        <div id="modeSwitchSection" class="settings-section" style="display: none;">
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px;">
                <div class="feature-card mode-card" id="switchToDrive" style="padding: 12px; flex-direction: column; height: 100%;">
                    <div class="checkmark">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 7 9 18 4 13"></polyline></svg>
                </div>
                    <div class="card-icon" style="width:32px; height:32px;">
                        <img class="no-invert" src="https://raw.githubusercontent.com/BorderWalker99/figma-plugin-figma_sync/refs/heads/main/images/google.svg" width="20" height="20">
              </div>
                    <div class="card-content" style="width:100%">
                        <div class="card-title" style="margin-bottom:2px;">Google Cloud</div>
                        <div class="card-desc" data-i18n="cloud_no_icloud">无需 iCloud</div>
            </div>
                </div>
                 <div class="feature-card mode-card" id="switchToAliyun" style="display:none; padding: 12px; flex-direction: column; height: 100%;">
                     <div class="checkmark">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>
              </div>
                     <div class="card-icon" style="width:32px; height:32px;">
                        <img class="no-invert" src="https://raw.githubusercontent.com/BorderWalker99/figma-plugin-figma_sync/refs/heads/main/images/aliyun.svg" width="20" height="20">
            </div>
                    <div class="card-content" style="width:100%">
                        <div class="card-title" style="margin-bottom:2px;" data-i18n="cloud_aliyun_oss">阿里云 OSS</div>
                        <div class="card-desc" data-i18n="cloud_object_storage">对象存储</div>
                </div>
              </div>
                 <!-- iCloud 模式 -->
                 <div class="feature-card mode-card" id="switchToIcloud" style="padding: 12px; flex-direction: column; height: 100%;">
                     <div class="checkmark">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>
            </div>
                     <div class="card-icon" style="width:32px; height:32px;">
                        <img class="no-invert" src="https://raw.githubusercontent.com/BorderWalker99/figma-plugin-figma_sync/refs/heads/main/images/icloud.svg" width="20" height="20">
          </div>
                    <div class="card-content" style="width:100%">
                        <div class="card-title" style="margin-bottom:2px;">iCloud</div>
                        <div class="card-desc" data-i18n="cloud_icloud_space">iCloud 需有空间</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Size Settings -->
        <div class="settings-section">
            <h3 data-i18n="settings_screenshot_size">截图尺寸</h3>
             <div style="display: flex; gap: 8px;">
                <div class="input-wrapper" style="flex: 1;">
                  <span class="input-prefix" data-i18n="input_width">宽</span>
                  <input type="number" id="imageWidthInput" placeholder="自适应" data-i18n-placeholder="placeholder_auto">
            </div>
                <div class="input-wrapper" style="flex: 1;">
                  <span class="input-prefix" data-i18n="input_height">高</span>
                  <input type="number" id="imageHeightInput" placeholder="自适应" data-i18n-placeholder="placeholder_auto">
            </div>
          </div>
        </div>

        <!-- Layout Settings -->
        <div class="settings-section">
            <h3 data-i18n="settings_layout">画板布局</h3>
            <div>
                <div class="input-wrapper">
                    <span class="input-prefix" data-i18n="input_per_row">每行</span>
                    <input type="number" id="frameColumnsInput" placeholder="一直横排" data-i18n-placeholder="placeholder_no_wrap">
          </div>
            </div>
        </div>

        <!-- Backup Settings -->
        <div class="settings-section" id="backupSection" style="display: flex; align-items: center; justify-content: space-between;">
            <h3 style="margin: 0;" data-i18n="settings_backup">备份到本地</h3>
            <select id="backupModeSelect" class="settings-select">
                <option value="none" data-i18n-option="backup_videos">仅视频</option>
                <option value="gif_only" data-i18n-option="backup_videos_gif">视频 + GIF</option>
                <option value="all" data-i18n-option="backup_all">视频 + GIF + 图片</option>
            </select>
        </div>

        <!-- GIF Export Algorithm (隐藏：默认使用更丝滑渐变算法) -->
        <div class="settings-section" id="gifAlgorithmSection" style="display: none;">
            <h3 style="margin: 0;" data-i18n="settings_gif_quality">GIF 画质优化</h3>
            <select id="gifAlgorithmSelect" class="settings-select">
                <option value="less_noise" data-i18n-option="gif_less_noise">更少噪点</option>
                <option value="smooth_gradient" data-i18n-option="gif_smooth_gradient" selected>更丝滑渐变</option>
            </select>
        </div>

        <!-- Language Settings -->
        <div class="settings-section" id="languageSection" style="display: flex; align-items: center; justify-content: space-between;">
            <h3 style="margin: 0;" data-i18n="settings_language">界面语言</h3>
            <div class="lang-select-wrapper">
                <div class="lang-select-display">
                    <span class="lang-flag" id="langFlag"></span>
                    <span id="langText" style = "padding-bottom: 2px;" >中文</span>
                </div>
                <select id="languageSelect" class="lang-select-native">
                    <option value="zh">中文</option>
                    <option value="en">English</option>
                </select>
            </div>
        </div>


              </div>

        <!-- Tab Content: Mobile -->
        <div id="contentMobile" class="tab-content" style="display:none;">
             <div style="display: flex; flex-direction: column; gap: 14px;">
              <div id="shortcutGuideSection"  style="display: flex; flex-direction: column; gap: 8px;">
                 <div id="shortcutGuideTitle" style="font-weight: 600; margin-bottom: 6px; font-size: 13px;" data-i18n="mobile_step1">01 配置快捷指令</div>
                 <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;" id="qrCodesContainer">
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 5px;" id="qrGoogleScreenshotContainer">
                      <img id="qrGoogleScreenshot" style="width: 72px; height: 72px;">
                      <div style="font-size: 11px; color: var(--text-secondary); text-align: center;" data-i18n="mobile_direct_capture">直接截图</div>
                      </div>
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 5px;" id="qrGoogleAlbumContainer">
                      <img id="qrGoogleAlbum" style="width: 72px; height: 72px;">
                      <div style="font-size: 11px; color: var(--text-secondary); text-align: center;" data-i18n="mobile_from_album">相册选择</div>
                  </div>
                    <!-- iCloud QR codes (hidden) -->
                    <div style="display: none; flex-direction: column; align-items: center; gap: 5px;" id="qrIcloudScreenshotContainer">
                      <img id="qrIcloudScreenshot" style="width: 72px; height: 72px;">
                      <div style="font-size: 11px; color: var(--text-secondary); text-align: center;" data-i18n="mobile_direct_capture">直接截图</div>
              </div>
                    <div style="display: none; flex-direction: column; align-items: center; gap: 5px;" id="qrIcloudAlbumContainer">
                      <img id="qrIcloudAlbum" style="width: 72px; height: 72px;">
                      <div style="font-size: 11px; color: var(--text-secondary); text-align: center;" data-i18n="mobile_from_album">相册选择</div>
                      </div>
                    </div>
                 <div id="noModeMessage" style="font-size: 12px; color: var(--text-secondary); line-height: 1.6; display: none;" data-i18n="mobile_select_storage">
                    请在"电脑端"中选择储存方式
                  </div>
              </div>

                        <div id="userIdDisplaySection">
                          <div id="userIdTitle" style="font-weight: 600; margin-bottom: 6px; font-size: 13px;" data-i18n="mobile_step2">02 您的 User ID</div>
                          <div id="userIdSubtitle" style="font-size: 12px; color: var(--text-secondary); margin-top: 4px; margin-bottom: 6px;" data-i18n="mobile_userid_hint">
                            请在快捷指令的文本框中填入此 ID:
                      </div>
                          <div class="user-id-display">
                            <div class="id-content">
                              <span id="displayUserId" data-i18n="mobile_userid_loading">正在获取...</span>
                    </div>
                    <button id="copyUserIdBtn" class="icon-btn" style="width: 24px; height: 24px; flex-shrink: 0;" title="复制 User ID" data-i18n-title="mobile_copy_userid">
                      <div class="neu-icon-inner">
                        <svg class="svg-icon" style="width: 14px; height: 14px; stroke-width: 2.5px !important;" viewBox="0 0 24 24"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                      </div>
                    </button>
                  </div>
                </div>
                  </div>
                </div>

                      </div>
                    </div>
  </div>

  <!-- QR Code Zoom Modal -->
  <div id="qrZoomOverlay">
    <div class="qr-zoom-content">
      <img id="qrZoomImage" class="qr-zoom-image" src="" alt="QR Code">
      <div id="qrZoomLabel" class="qr-zoom-label"></div>
    </div>
  </div>

  <!-- Upload GIF Modal -->
  <div id="uploadGifOverlay" class="modal-overlay" style="display: none;">
    <div class="modal" style="max-width: 420px;">
      <!-- 关闭按钮 -->
      <button id="uploadGifClose" class="close-btn" style="position: absolute; top: 16px; right: 16px; z-index: 10;">
        <div class="neu-icon-inner" style="width: 26px; height: 26px; border-radius: 50%; display: flex; align-items: center; justify-content: center;">
          <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </div>
      </button>
      
      <div class="modal-content" style="padding: 36px 32px; text-align: center;">
        <!-- 上传 Icon -->
        <div style="margin-bottom: 4px;">
          <div class="neu-icon-large" style="display: inline-flex; align-items: center; justify-content: center; width: 56px; height: 56px; border-radius: 50%; margin-bottom: 14px;">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
              <polyline points="17 8 12 3 7 8"></polyline>
              <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
          </div>
          <h2 style="font-size: 16px; font-weight: 600; margin: 0; color: var(--text-primary); letter-spacing: -0.01em;" data-i18n="upload_title">检测到需手动上传的录屏</h2>
        </div>

        <!-- 副标题 -->
        <div id="unsynced-gifs-subtitle" style="margin-bottom: 16px; color: var(--text-secondary); font-size: 13px; line-height: 1.5;">
          <!-- 动态填充文件名列表 -->
        </div>

        <!-- 隐藏的文件选择器 -->
        <input type="file" id="multi-file-input" accept=".gif,.mov,.mp4" multiple style="display: none;">

        <!-- 拖拽上传区域 - Liquid Glass Dashed Border -->
        <div id="upload-dropzone" style="
          width: 100%;
          min-height: 120px;
          border: 2px dashed var(--glass-border);
          border-radius: var(--radius-m);
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          gap: 4px;
          padding: 24px 16px;
          cursor: pointer;
          transition: all 0.2s ease;
          background: transparent;
          box-sizing: border-box;
        ">
          <!-- 主文案 -->
          <div id="dropzone-text" style="text-align: center;">
            <div style="font-size: 12px; color: var(--text-secondary);">
              <span style="color: var(--primary);" data-i18n="upload_click_or_drag">点击上传 或 拖拽文件到此处</span>
            </div>
          </div>
          
          <!-- 支持格式提示 -->
          <div style="font-size: 11px; color: var(--text-primary);" data-i18n="upload_formats">
            支持 .gif .mov .mp4 格式
          </div>
        </div>

        <!-- 上传进度（隐藏） -->
        <div id="upload-progress-container" style="display: none; margin-top: 20px;">
          <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px; font-weight: 500;" id="upload-progress-text" data-i18n="upload_uploading">正在上传...</div>
          <div style="width: 100%; height: 5px; background: var(--bg-inset); border-radius: 3px; overflow: hidden; box-shadow: inset 0 1px 2px rgba(0,0,0,0.08);">
            <div id="upload-progress-bar" style="width: 0%; height: 100%; background: linear-gradient(90deg, var(--unified-green) 0%, #4ADE80 100%); transition: width 0.3s ease;"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Timeline Editor Modal -->
  <div id="timelineEditorOverlay" class="modal-overlay">
    <div class="modal" style="width: 90%; max-width: 800px; height: 90vh; max-height: 700px; display: flex; flex-direction: column; background: var(--bg-app); border-radius: var(--radius-l); box-shadow: var(--shadow-lg); overflow: hidden;">
      <div class="modal-header" style="flex-shrink: 0; padding: 8px 16px; border-bottom: 1px solid var(--divider); display: flex; justify-content: space-between; align-items: center;">
        <h3 style="margin: 0; font-size: 14px; font-weight: 600; color: var(--text-primary);" data-i18n="timeline_title">时间线编辑</h3>
        <button id="timelineClose" class="close-btn">
          <div class="neu-icon-inner" style="width: 26px; height: 26px; border-radius: 50%; display: flex; align-items: center; justify-content: center;">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </div>
        </button>
      </div>
      
      <!-- Preview Area (click to enter fullscreen) -->
      <div id="timelinePreviewArea" style="flex-shrink: 0; height: 160px; background: var(--preview-bg); display: flex; justify-content: center; align-items: center; position: relative; overflow: hidden; border-bottom: 1px solid var(--divider); cursor: pointer;">
        <div id="timelinePreviewContainer" style="position: relative; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; pointer-events: none;">
          <div style="color: var(--preview-text); font-size: 13px;" data-i18n="timeline_loading_preview">加载预览中...</div>
        </div>
        <div style="position: absolute; bottom: 8px; right: 8px; color: #FFFFFF; background: rgba(0,0,0,0.6); padding: 2px 8px; border-radius: var(--radius-xs); font-size: 10px; pointer-events: none; display: flex; align-items: center; gap: 4px;">
          <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="15 3 21 3 21 9"></polyline>
            <polyline points="9 21 3 21 3 15"></polyline>
          </svg>
          <span data-i18n="timeline_fullscreen">全屏</span>
        </div>
      </div>

      <!-- Tracks Area with Scrubber - scrollable -->
      <div id="timelineTracksScroll" style="flex: 1 1 auto; min-height: 0; overflow-y: auto; overflow-x: hidden; position: relative; background: var(--bg-primary);">
        <!-- Scrubber Line (Global) - white style with pill handle, always on top -->
        <!-- pointer-events: none 让事件穿透到下层的拖拽条-->
        <div id="timelineScrubber" style="position: absolute; top: 0; width: 12px; margin-left: -5px; z-index: 9999; left: 0; pointer-events: none; display: none; min-height: 100%;">
          <!-- Visible line -->
          <div style="position: absolute; top: 0; bottom: 0; left: 5px; width: 2px; background: rgba(255,255,255,0.9); box-shadow: 0 0 4px rgba(0,0,0,0.3); pointer-events: none;"></div>
          <!-- Top handle -->
          <div style="position: absolute; top: 0; left: 0; width: 12px; height: 16px; background: rgba(255,255,255,0.95); border-radius: var(--radius-s); box-shadow: 0 2px 6px rgba(0,0,0,0.4); pointer-events: auto; cursor: ew-resize;" id="timelineScrubberHandle"></div>
        </div>
        
        <div id="timelineTracks" style="padding: 12px 16px;">
          <!-- Tracks injected via JS -->
          <div style="text-align: center; color: var(--text-secondary); margin-top: 20px;" data-i18n="timeline_loading_layers">正在加载图层...</div>
        </div>
      </div>

      <div class="timeline-footer" style="flex-shrink: 0; padding: 12px 16px; border-top: 1px solid var(--divider); background: var(--bg-primary);">
        <button class="btn btn-primary" id="timelineExportBtn" style="width: 100%;" data-i18n="export_start">开始导出</button>
      </div>
    </div>
  </div>

  <!-- Timeline Fullscreen Preview -->
  <div id="timelineFullscreenOverlay" class="modal-overlay" style="background: rgba(0,0,0,0.95);">
    <div style="position: relative; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; padding-top: 30px; padding-bottom:140px;">
      <!-- Close button -->
      <button id="timelineFullscreenClose" class="close-btn" style="position: absolute; top: 16px; right: 16px; z-index: 10;">
        <div class="neu-icon-inner" style="width: 26px; height: 26px; border-radius: 50%; display: flex; align-items: center; justify-content: center;">
          <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </div>
      </button>
      
      <!-- Preview container -->
      <div id="fullscreenPreviewContainer" style="max-width: 90%; flex: 1; display: flex; align-items: center; justify-content: center;"></div>
      
      <!-- Progress bar at bottom -->
      <div style="position: absolute; bottom: 40px; left: 20px; right: 20px; display: flex; flex-direction: column; align-items: flex-end; gap: 6px;">
        <!-- Time display above progress bar, right-aligned -->
        <div id="fullscreenProgressText" style="color: rgba(255,255,255,0.9); font-size: 11px;">
          <span style="color: rgba(255,255,255,0.95);">00:00:00</span>
          <span style="color: rgba(255,255,255,0.5); margin: 0 3px;">/</span>
          <span id="fullscreenTotalTime" style="color: rgba(255,255,255,0.6);">00:00:00</span>
        </div>
        <!-- Progress bar -->
        <div id="fullscreenProgressBar" style="width: 100%; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; cursor: pointer; position: relative;">
          <div id="fullscreenProgressFill" style="width: 0%; height: 100%; background: var(--unified-green); border-radius: 2px; pointer-events: none;"></div>
          <!-- Draggable thumb -->
          <div id="fullscreenProgressThumb" style="
            position: absolute;
            top: 50%;
            left: 0%;
            transform: translate(-50%, -50%);
            width: 12px;
            height: 12px;
            background: white;
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
            transition: transform 0.1s ease;
          "></div>
        </div>
      </div>
      
      <!-- Play hint -->
      <!-- <div style="position: absolute; bottom: 16px; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.5); font-size: 11px;">
        按空格键播放/暂停
      </div> -->
    </div>
  </div>

  <!-- Export Choice Modal -->
  <div id="exportChoiceOverlay" class="modal-overlay">
    <div class="modal" style="width: 300px; padding: 20px; overflow: hidden; position: relative;">
        <!-- Close Button -->
        <button id="exportChoiceClose" class="close-btn" style="position: absolute; top: 12px; right: 12px; z-index: 10;">
          <div class="neu-icon-inner" style="width: 26px; height: 26px; border-radius: 50%; display: flex; align-items: center; justify-content: center;">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </div>
        </button>
        
        <h3 style="margin: 0 0 16px 0; font-size: 15px; font-weight: 600; color: var(--text-primary); text-align: center;" data-i18n="export_title">导出 GIF</h3>
        
        <div style="display: flex; flex-direction: column; gap: 10px;">
            <!-- 直接导出选项 -->
            <button id="choiceDirectExport" class="export-choice-btn">
                <div class="export-choice-icon">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <!-- Rounded rectangle with open top-right corner -->
                        <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                        <!-- Arrow pointing up-right -->
                        <polyline points="15 3 21 3 21 9"></polyline>
                        <line x1="12" y1="12" x2="21" y2="3"></line>
                    </svg>
                </div>
                <div style="flex: 1; text-align: left;">
                    <div style="font-size: 14px; font-weight: 500; color: var(--text-primary);" data-i18n="export_direct">直接导出</div>
                    <div style="font-size: 11px; color: var(--text-tertiary); margin-top: 2px;" data-i18n="export_direct_desc">使用默认设置快速导出</div>
                </div>
                <svg class="export-choice-arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="9 18 15 12 9 6"></polyline>
                </svg>
            </button>
            
            <!-- 时间线编辑选项 -->
            <button id="choiceTimeline" class="export-choice-btn">
                <div class="export-choice-icon">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <!-- Playhead: vertical line with small head indicator -->
                        <line x1="8" y1="4" x2="8" y2="20"></line>
                        <rect x="6" y="1" width="4" height="3" rx="1"></rect>
                        <!-- Top track: line (right segment only) -->
                        <line x1="11" y1="9" x2="22" y2="9"></line>
                        <!-- Bottom track: line (full width) -->
                        <line x1="2" y1="17" x2="22" y2="17"></line>
                    </svg>
                </div>
                <div style="flex: 1; text-align: left;">
                    <div style="font-size: 14px; font-weight: 500; color: var(--text-primary);" data-i18n="export_timeline">时间线编辑</div>
                    <div style="font-size: 11px; color: var(--text-tertiary); margin-top: 2px;" data-i18n="export_timeline_desc">调整图层显示时间区间</div>
                </div>
                <svg class="export-choice-arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="9 18 15 12 9 6"></polyline>
                </svg>
            </button>
        </div>
    </div>
  </div>

  <!-- Toast -->
  <div id="toast" class="toast">
    <div class="toast-icon"></div>
    <span class="toast-message"></span>
  </div>

  <!-- Logic Script (Preserved) -->
  <script>
    // ========================================
    // Google Drive 模式开关（默认启用）
    // ========================================
    const ENABLE_GOOGLE_DRIVE = true;
    const ENABLE_ALIYUN = false;
    
    // ========================================
    // 开发者模式（控制模式切换区域显示）
    // ========================================
    const DEVELOPER_MODE = false;
    
    // ========================================
    // i18n — Internationalization
    // ========================================
    let currentLang = 'zh'; // default, will be loaded from clientStorage
    
    const i18n = {
      zh: {
        // Tabs
        tab_plugin: '插件端',
        tab_mobile: '手机端',
        // Settings headings
        settings_screenshot_size: '截图尺寸',
        settings_layout: '画板布局',
        settings_backup: '备份到本地',
        settings_gif_quality: 'GIF 画质优化',
        settings_language: '界面语言',
        // Settings inputs
        input_width: '宽',
        input_height: '高',
        input_per_row: '每行',
        placeholder_auto: '自适应',
        placeholder_no_wrap: '一直横排',
        // Backup options
        backup_videos: '仅视频',
        backup_videos_gif: '视频 + GIF',
        backup_all: '视频 + GIF + 图片',
        // GIF algorithm
        gif_less_noise: '更少噪点',
        gif_smooth_gradient: '更丝滑渐变',
        // Tooltips
        tooltip_open_folder: '打开文件夹',
        tooltip_settings: '设置',
        tooltip_minimize: '最小化窗口',
        tooltip_restore: '恢复',
        tooltip_manual_sync: '手动同步',
        tooltip_export_gif: '导出 GIF',
        tooltip_stop_export: '停止导出 GIF',
        tooltip_syncing: '同步中...',
        // Control labels
        label_manual_sync: '手动同步',
        label_realtime_sync: '实时同步',
        label_export_gif: '导出 GIF',
        // Status pill
        status_waiting: '等待中',
        status_connecting: '正在连接',
        status_reconnect: '点击重连',
        status_connected: '已连接',
        status_sync_done: '同步完成',
        status_sync_fail: '同步失败',
        status_sync_timeout: '同步超时',
        status_syncing: '正在同步',
        status_request_fail: '请求失败',
        status_stopped: '已停止',
        status_running: '运行中',
        status_mode_selection: '已返回模式选择',
        status_disconnected: '连接断开',
        status_exported_gif: '已导出 {0} 段 GIF',
        status_saved_video: '已保存 {0} 段视频',
        status_saved_gif: '已保存 {0} 段 GIF',
        // Toasts
        toast_server_started: '服务已启动',
        toast_file_not_found: '文件未找到',
        toast_export_fail: '导出失败',
        toast_unknown_error: '未知错误',
        toast_switched_to: '已切换至{0}',
        toast_icloud_full: 'iCloud 空间不足',
        toast_switch_fail: '切换失败',
        toast_backup_fail: '备份设置失败',
        toast_import_fail_local: '导入失败，已存至本地',
        toast_server_offline: '未连接服务',
        toast_startup_fail: '启动失败',
        toast_settings_saved: '已保存',
        toast_width_invalid: '宽度须大于 0',
        toast_height_invalid: '高度须大于 0',
        toast_columns_invalid: '列数须大于 0',
        toast_update_done_restart: '更新完成，请重启',
        toast_update_fail: '更新失败',
        toast_format_unsupported: '仅支持 GIF / MOV / MP4',
        toast_file_mismatch: '文件与图层不匹配',
        toast_uploaded_progress: '已上传 {0}/{1}',
        toast_upload_fail: '上传失败',
        toast_import_fail: '导入失败',
        toast_select_frame: '请先选中 Frame',
        toast_no_video_layer: '所选 Frame 不含录屏',
        toast_some_frames_no_video: '以下 Frame 不含录屏：{0}',
        toast_assoc_fail: '关联失败',
        toast_userid_unavail: '未获取 User ID',
        toast_userid_copied: '已复制 User ID',
        toast_copy_fail: '复制失败',
        toast_syncing: '同步中…',
        toast_sync_timeout: '同步超时',
        toast_request_fail: '请求失败',
        toast_export_timeout: '导出超时',
        toast_switching: '切换中…',
        toast_export_stopped: '已停止导出',
        // Update banner
        banner_new_version: '发现新版本 v{0}',
        banner_update_now: '立即更新',
        banner_downloading: '下载中',
        banner_installing: '正在安装',
        banner_update_done: '更新完成',
        banner_updating: '更新中...',
        // Mode selection
        mode_realtime: '实时模式',
        mode_realtime_desc: '手机截图 实时导入',
        mode_manual: '手动模式',
        mode_manual_desc: '云端截图 批量导入',
        mode_select_title: '选择同步模式',
        // Cloud providers
        cloud_no_icloud: '无需 iCloud',
        cloud_aliyun_oss: '阿里云 OSS',
        cloud_object_storage: '对象存储',
        cloud_icloud_space: 'iCloud 需有空间',
        // Export modal
        export_title: '导出 GIF',
        export_direct: '直接导出',
        export_direct_desc: '使用默认设置快速导出',
        export_timeline: '时间线编辑',
        export_timeline_desc: '调整图层显示时间区间',
        export_start: '开始导出',
        // Manual upload modal
        upload_title: '检测到需手动上传的录屏',
        upload_click_or_drag: '点击上传 或 拖拽文件到此处',
        upload_formats: '支持 .gif .mov .mp4 格式',
        upload_uploading: '正在上传...',
        upload_progress: '上传中... ({0}/{1})',
        upload_done: '文件上传完成 ({0}/{1})',
        upload_all_done: '✅ 所有文件已上传',
        upload_needed: '请上传 {0} 个录屏文件',
        upload_partial: '已上传 {0}/{1}',
        upload_remaining: '，还需上传 {0} 个文件',
        // Timeline
        timeline_title: '时间线编辑',
        timeline_fullscreen: '全屏',
        timeline_loading_layers: '正在加载图层...',
        timeline_loading_preview: '加载预览中...',
        timeline_no_frame_size: '无法获取Frame尺寸',
        // Buttons
        btn_sync_now: '立即同步',
        btn_syncing: '同步中',
        btn_preparing: '准备中...',
        btn_exporting: '导出中 {0}%',
        // Realtime sync
        realtime_syncing: '正在实时同步',
        realtime_click_start: '点击开启实时同步',
        // Logs
        log_title: '系统日志',
        log_collapse: '收起',
        log_expand: '展开',
        // Mobile tab
        mobile_step1: '01 配置快捷指令',
        mobile_step1_alt: '01 扫码获取快捷指令',
        mobile_step1_scan: '扫码获取快捷指令',
        mobile_direct_capture: '直接截图',
        mobile_from_album: '相册选择',
        mobile_select_storage: '请在"电脑端"中选择储存方式',
        mobile_step2: '02 您的 User ID',
        mobile_step2_alt: '02 将 User ID 填入指令的文本框中',
        mobile_userid_hint: '请在快捷指令的文本框中填入此 ID:',
        mobile_userid_loading: '正在获取...',
        mobile_copy_userid: '复制 User ID',
        // Sync results
        sync_images: '{0} 张图片',
        sync_gifs: '{0} 段 GIF',
        sync_videos: '{0} 段视频',
        sync_zero_images: '已同步 0 张图片',
        sync_done_prefix: '已同步 ',
        // File reasons
        reason_unknown: '未知原因',
        reason_mov: 'MOV视频',
        reason_mp4: 'MP4视频',
        reason_gif_large: 'GIF过大',
        // Help/troubleshoot
        help_server_not_running: '服务器未运行',
        help_cannot_connect: '无法连接到本地服务器。',
        help_try_solutions: '请尝试以下解决方案：',
        help_retry_start: '🔄 重新尝试启动',
        help_still_cannot: '💡 如果仍无法连接：',
        help_check_prefs: '1. 检查"系统偏好设置 → 用户与群组 → 登录项"',
        help_ensure_service: '2. 确保 ScreenSync 服务已启用',
        help_restart: '3. 重启电脑后重试',
        // Error messages
        error_sync_fail: '同步失败',
        error_sync_suggestion: '💡 建议：',
        error_ensure_server: '1. 确保服务器正在运行',
        error_upload_first: '2. 先在手机端上传至少一个文件',
        error_wait_retry: '3. 等待几秒后重试',
        error_restart_server: '4. 如仍无法解决，请重启服务器',
        error_screenshot_fail: '截图处理失败',
        error_filename: '文件名',
        error_message: '错误信息',
        error_send_dev: '请将此错误信息截图发给开发者。',
        // Log messages (visible in system log)
        log_export_timeout_detail: '导出超时：GIF 尺寸过大或处理时间过长，建议减小画面尺寸或缩短视频时长',
        // Mode names
        mode_name_unknown: '未知模式',
        mode_name_aliyun: '阿里云',
        mode_name_icloud: 'iCloud',
        mode_name_google: 'Google Drive',
        // Language
        lang_zh: '中文',
        lang_en: 'English',
      },
      en: {
        // Tabs
        tab_plugin: 'Plugin',
        tab_mobile: 'Mobile',
        // Settings headings
        settings_screenshot_size: 'Screenshot Size',
        settings_layout: 'Layout',
        settings_backup: 'Auto Save',
        settings_gif_quality: 'GIF Quality',
        settings_language: 'Language',
        // Settings inputs
        input_width: 'W',
        input_height: 'H',
        input_per_row: 'Cols',
        placeholder_auto: 'Auto',
        placeholder_no_wrap: 'No wrap',
        // Backup options
        backup_videos: 'Videos only',
        backup_videos_gif: 'Videos + GIF',
        backup_all: 'All media',
        // GIF algorithm
        gif_less_noise: 'Less noise',
        gif_smooth_gradient: 'Smooth gradient',
        // Tooltips
        tooltip_open_folder: 'Open folder',
        tooltip_settings: 'Settings',
        tooltip_minimize: 'Minimize',
        tooltip_restore: 'Restore',
        tooltip_manual_sync: 'Manual sync',
        tooltip_export_gif: 'Export GIF',
        tooltip_stop_export: 'Stop GIF Export',
        tooltip_syncing: 'Syncing...',
        // Control labels
        label_manual_sync: 'Sync',
        label_realtime_sync: 'Live Sync',
        label_export_gif: 'Export GIF',
        // Status pill
        status_waiting: 'Waiting',
        status_connecting: 'Connecting',
        status_reconnect: 'Tap to reconnect',
        status_connected: 'Connected',
        status_sync_done: 'Synced',
        status_sync_fail: 'Sync failed',
        status_sync_timeout: 'Sync timeout',
        status_syncing: 'Syncing',
        status_request_fail: 'Request failed',
        status_stopped: 'Stopped',
        status_running: 'Running',
        status_mode_selection: 'Mode selection',
        status_disconnected: 'Disconnected',
        status_exported_gif: 'Exported {0} GIFs',
        status_exported_gif_one: 'Exported 1 GIF',
        status_exported_gif_other: 'Exported {0} GIFs',
        status_saved_video: 'Saved {0} videos',
        status_saved_video_one: 'Saved 1 video',
        status_saved_video_other: 'Saved {0} videos',
        status_saved_gif: 'Saved {0} GIFs',
        status_saved_gif_one: 'Saved 1 GIF',
        status_saved_gif_other: 'Saved {0} GIFs',
        // Toasts
        toast_server_started: 'Server started',
        toast_file_not_found: 'File not found',
        toast_export_fail: 'Export failed',
        toast_unknown_error: 'Unknown error',
        toast_switched_to: 'Switched to {0}',
        toast_icloud_full: 'iCloud storage full',
        toast_switch_fail: 'Switch failed',
        toast_backup_fail: 'Backup setting failed',
        toast_import_fail_local: 'Import failed, saved locally',
        toast_server_offline: 'Server not connected',
        toast_startup_fail: 'Startup failed',
        toast_settings_saved: 'Saved',
        toast_width_invalid: 'Width must be > 0',
        toast_height_invalid: 'Height must be > 0',
        toast_columns_invalid: 'Columns must be > 0',
        toast_update_done_restart: 'Updated, please restart',
        toast_update_fail: 'Update failed',
        toast_format_unsupported: 'Only GIF / MOV / MP4',
        toast_file_mismatch: 'File doesn\u2019t match layer',
        toast_uploaded_progress: 'Uploaded {0}/{1}',
        toast_upload_fail: 'Upload failed',
        toast_import_fail: 'Import failed',
        toast_select_frame: 'Select a Frame first',
        toast_no_video_layer: 'No recordings in this Frame',
        toast_some_frames_no_video: 'No recordings in: {0}',
        toast_assoc_fail: 'Association failed',
        toast_userid_unavail: 'User ID unavailable',
        toast_userid_copied: 'User ID copied',
        toast_copy_fail: 'Copy failed',
        toast_syncing: 'Syncing\u2026',
        toast_sync_timeout: 'Sync timed out',
        toast_request_fail: 'Request failed',
        toast_export_timeout: 'Export timed out',
        toast_switching: 'Switching\u2026',
        toast_export_stopped: 'Export stopped',
        // Update banner
        banner_new_version: 'New version v{0}',
        banner_update_now: 'Update',
        banner_downloading: 'Downloading',
        banner_installing: 'Installing',
        banner_update_done: 'Updated',
        banner_updating: 'Updating...',
        // Mode selection
        mode_realtime: 'Realtime',
        mode_realtime_desc: 'Live import from phone',
        mode_manual: 'Manual',
        mode_manual_desc: 'Batch import from cloud',
        mode_select_title: 'Sync Mode',
        // Cloud providers
        cloud_no_icloud: 'No iCloud needed',
        cloud_aliyun_oss: 'Aliyun OSS',
        cloud_object_storage: 'Object Storage',
        cloud_icloud_space: 'iCloud space needed',
        // Export modal
        export_title: 'Export GIF',
        export_direct: 'Quick Export',
        export_direct_desc: 'Export with default settings',
        export_timeline: 'Timeline Export',
        export_timeline_desc: 'Adjust layer display timing',
        export_start: 'Export',
        // Manual upload modal
        upload_title: 'Manual upload needed',
        upload_click_or_drag: 'Click or drag files here',
        upload_formats: 'Supports .gif .mov .mp4',
        upload_uploading: 'Uploading...',
        upload_progress: 'Uploading... ({0}/{1})',
        upload_done: 'Upload complete ({0}/{1})',
        upload_all_done: '✅ All files uploaded',
        upload_needed: 'Upload {0} recordings',
        upload_needed_one: 'Upload 1 recording',
        upload_needed_other: 'Upload {0} recordings',
        upload_partial: 'Uploaded {0}/{1}',
        upload_remaining: ', {0} more needed',
        // Timeline
        timeline_title: 'Timeline Export',
        timeline_fullscreen: 'Fullscreen',
        timeline_loading_layers: 'Loading layers...',
        timeline_loading_preview: 'Loading preview...',
        timeline_no_frame_size: 'Cannot get Frame size',
        // Buttons
        btn_sync_now: 'Sync Now',
        btn_syncing: 'Syncing',
        btn_preparing: 'Preparing...',
        btn_exporting: 'Exporting {0}%',
        // Realtime sync
        realtime_syncing: 'Live syncing',
        realtime_click_start: 'Start live sync',
        // Logs
        log_title: 'Logs',
        log_collapse: 'Hide',
        log_expand: 'Show',
        // Mobile tab
        mobile_step1: '01 Setup Shortcuts',
        mobile_step1_alt: '01 Scan for Shortcuts',
        mobile_step1_scan: 'Scan for Shortcuts',
        mobile_direct_capture: 'Direct Capture',
        mobile_from_album: 'From Photos',
        mobile_select_storage: 'Select storage in the "Plugin" tab',
        mobile_step2: '02 Your User ID',
        mobile_step2_alt: '02 Enter User ID in Shortcut',
        mobile_userid_hint: 'Enter this ID in the Shortcut text field:',
        mobile_userid_loading: 'Loading...',
        mobile_copy_userid: 'Copy ID',
        // Sync results
        sync_images: '{0} images',
        sync_images_one: '1 image',
        sync_images_other: '{0} images',
        sync_gifs: '{0} GIFs',
        sync_gifs_one: '1 GIF',
        sync_gifs_other: '{0} GIFs',
        sync_videos: '{0} videos',
        sync_videos_one: '1 video',
        sync_videos_other: '{0} videos',
        sync_zero_images: 'Synced 0 images',
        sync_done_prefix: 'Synced ',
        // File reasons
        reason_unknown: 'Unknown',
        reason_mov: 'MOV video',
        reason_mp4: 'MP4 video',
        reason_gif_large: 'GIF too large',
        // Help/troubleshoot
        help_server_not_running: 'Server not running',
        help_cannot_connect: 'Cannot connect to local server.',
        help_try_solutions: 'Try the following:',
        help_retry_start: '🔄 Retry startup',
        help_still_cannot: '💡 If still not working:',
        help_check_prefs: '1. Check System Preferences → Login Items',
        help_ensure_service: '2. Ensure ScreenSync service is enabled',
        help_restart: '3. Restart your computer',
        // Error messages
        error_sync_fail: 'Sync failed',
        error_sync_suggestion: '💡 Suggestions:',
        error_ensure_server: '1. Ensure server is running',
        error_upload_first: '2. Upload at least one file on phone first',
        error_wait_retry: '3. Wait a few seconds and retry',
        error_restart_server: '4. Restart the server if issue persists',
        error_screenshot_fail: 'Screenshot processing failed',
        error_filename: 'File',
        error_message: 'Error',
        error_send_dev: 'Please screenshot this error and send to the developer.',
        // Log messages
        log_export_timeout_detail: 'Export timeout: reduce frame size or shorten video',
        // Mode names
        mode_name_unknown: 'Unknown',
        mode_name_aliyun: 'Aliyun',
        mode_name_icloud: 'iCloud',
        mode_name_google: 'Google Drive',
        // Language
        lang_zh: '中文',
        lang_en: 'English',
      }
    };
    
    // ── Flag Icons (IMAGE_BASE_URL + zh.svg / en.svg) ─────────────────
    const FLAG_URL = {
      zh: IMAGE_BASE_URL + 'zh.svg',
      en: IMAGE_BASE_URL + 'en.svg'
    };
    const FLAG_TEXT = { zh: '中文', en: 'English' };
    
    function updateLangFlag(lang) {
      const flagEl = document.getElementById('langFlag');
      const textEl = document.getElementById('langText');
      if (flagEl) {
        const url = FLAG_URL[lang] || FLAG_URL.zh;
        flagEl.innerHTML = `<img src="${url}" alt="">`;
      }
      if (textEl) textEl.textContent = FLAG_TEXT[lang] || FLAG_TEXT.zh;
    }
    
    // Translation helper with placeholder support: t('key', arg1, arg2, ...)
    function t(key) {
      const str = (i18n[currentLang] && i18n[currentLang][key]) || (i18n.zh[key]) || key;
      if (arguments.length <= 1) return str;
      let result = str;
      for (let i = 1; i < arguments.length; i++) {
        result = result.replace('{' + (i - 1) + '}', arguments[i]);
      }
      return result;
    }
    
    // Plural-aware translation (English only): 1 recording vs 2 recordings
    function tPlural(key, count) {
      const lang = i18n[currentLang] || i18n.zh;
      if (currentLang === 'en') {
        const oneKey = key + '_one';
        const otherKey = key + '_other';
        if (count === 1 && lang[oneKey]) return lang[oneKey];
        const str = lang[otherKey] || lang[key] || i18n.zh[key] || key;
        return str.replace('{0}', count);
      }
      return t(key, count);
    }
    
    // Apply language to all data-i18n elements in the DOM
    function applyLanguage() {
      document.querySelectorAll('[data-i18n]').forEach(el => {
        el.textContent = t(el.getAttribute('data-i18n'));
      });
      document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
        el.placeholder = t(el.getAttribute('data-i18n-placeholder'));
      });
      document.querySelectorAll('[data-i18n-tooltip]').forEach(el => {
        el.setAttribute('data-tooltip', t(el.getAttribute('data-i18n-tooltip')));
      });
      document.querySelectorAll('[data-i18n-title]').forEach(el => {
        el.setAttribute('title', t(el.getAttribute('data-i18n-title')));
      });
      // Update select option texts
      document.querySelectorAll('[data-i18n-option]').forEach(el => {
        el.textContent = t(el.getAttribute('data-i18n-option'));
      });
      // Re-adjust all select widths
      if (typeof adjustSelectWidth === 'function') {
        document.querySelectorAll('.settings-select').forEach(sel => adjustSelectWidth(sel));
      }
      // Update language flag SVG display
      if (typeof updateLangFlag === 'function') {
        updateLangFlag(currentLang);
      }
      // 刷新 status pill（它由 JS 动态控制，不使用 data-i18n）
      if (typeof updateStatus === 'function' && typeof _lastStatusType !== 'undefined') {
        updateStatus(_lastStatusType, '');
      }
    }
    
    // Request language setting from clientStorage on startup
    postToPlugin('get-language');
    
    const SERVER_URL = 'ws://localhost:8888';
    const connectionId = 'sync-session-1';
    
    // ─── Communication Helpers ──────────────────────────────────────────────
    /** Send a typed JSON message via WebSocket (no-op if not connected) */
    function wsSend(type, payload) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type, ...payload }));
        return true;
      }
      return false;
    }

    /** Post a typed message to the Figma plugin (code.js) */
    function postToPlugin(type, payload) {
      parent.postMessage({ pluginMessage: { type, ...payload } }, '*');
    }

    // GIF algorithm setting (默认：更丝滑渐变)
    window.gifAlgorithmSetting = 'smooth_gradient';
    postToPlugin('get-gif-algorithm');
    
    let ws = null;
    let screenshotCount = 0;
    let manualDragCount = 0;
    let skippedFilesSet = new Set(); // 用于去重
    let heartbeatTimer = null;
    let updateCheckTimer = null; // 定期检查更新的定时器
    // isManualSyncing moved to progress variables section
    let currentMode = null;
    let currentSyncMode = null;
    let serverInstallPath = null;
    let isMinimized = false;
    let gifBackupCount = 0;
    let exportedGifCount = 0; // New counter for exported GIFs
    let justFinishedExport = false; // Flag to prioritize export status display
    
    // ✅ 新的状态管理系统：支持多状态队列
    // 每个状态可以独立存在，用户需要分别点击才能清除
    // 但导出状态会立即清除所有"已保存"状态
    let pendingStates = {
      exported: { count: 0, active: false },    // 已导出 X 段 GIF
      savedVideo: { count: 0, active: false },  // 已保存 X 段视频
      savedGif: { count: 0, active: false }     // 已保存 X 段 GIF
    };
    
    // 兼容旧代码的变量（后续会逐步移除）
    let currentButtonState = null; // 'exported', 'video', 'gif-backup', or null - locks the pill state until user clicks
    let currentPluginVersion = null; // 当前插件版本（初始为 null，等待 code.js 返回真实版本）
    let latestPluginVersion = null; // 最新版本
    let pluginUpdateUrl = null; // 更新下载地址
    let dismissedPluginVersion = null; // 用户点击"稍后"后记录的版本
    let dismissedServerVersion = null; // 用户点击"稍后"后记录的服务器版本
    let pendingPluginUpdateInfo = null; // 暂存的插件更新信息（等待版本信息到达后处理）
    
    // ✅ 新增：缓存手机同步的Video/大GIF的元数据（用于导出时自动关联）
    // 键：文件名，值：{ gifCacheId, driveFileId, ossFileId, timestamp }
    const skippedFileCache = new Map();
    const SKIPPED_FILE_CACHE_MAX = 200; // 最多保留 200 条，防止内存无限增长
    
    // 从 localStorage 读取已安装的服务器版本（防止更新后 banner 再次弹出）
    // 注意：Figma 插件环境可能不支持 localStorage，需要 try-catch 保护
    let installedServerVersion = null;
    try {
      installedServerVersion = localStorage.getItem('currentServerVersion') || null;
      if (installedServerVersion) {
      }
    } catch (error) {
    }
    
    // 配置：定期检查更新的间隔（毫秒）
    const UPDATE_CHECK_INTERVAL = 60 * 60 * 1000; // 1小时检查一次
    
    // 日志配置：设为 false 可减少 Figma 控制台日志（降低 Datadog 警告）
    const ENABLE_CONSOLE_LOG = false; // 生产环境建议设为 false

    // ========== 日志函数 ==========
    function log(msg) {
      // 🛡️ 防止初始化未完成时崩溃
      try {
        // 只在开发模式下输出到控制台，减少 Datadog 数据量
        if (ENABLE_CONSOLE_LOG) {
          console.log(msg);
        }
        const logEl = document.getElementById('log');
        if (!logEl) return;
        
        const time = new Date().toLocaleTimeString();
        logEl.innerHTML = `[${time}] ${msg}\n` + logEl.innerHTML;

        const lines = logEl.innerText.split('\n');
        if (lines.length > 200) {
          logEl.innerText = lines.slice(0, 200).join('\n');
        }
      } catch (error) {
        // 静默处理日志错误，避免递归
      }
    }

    // ========== WebSocket连接 ==========
    // 重新连接功能（包含自动修复）
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 3; // 🚀 减少重试次数，快速失败
    let isExplicitlyDisconnected = false; // 用户是否手动断开（暂未用到，但预留）
    let isFirstConnection = true; // 🚀 标记是否是首次连接
    
    function attemptReconnect() {
      reconnectAttempts++;
      log(`🔄 尝试重新连接 (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
      updateStatus('waiting', t('status_connecting'));
      
      // 清理心跳定时器
      if (heartbeatTimer) {
        clearInterval(heartbeatTimer);
        heartbeatTimer = null;
      }
      
      // 🚀 优化：缩短等待时间（从 1500ms 减少到 300ms）
      setTimeout(() => {
        connect();
        
        // 🚀 优化：缩短检查时间（从 3s 减少到 1.5s）
        setTimeout(() => {
          if (!ws || ws.readyState !== WebSocket.OPEN) {
            if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
              // 🚀 只在最后一次尝试时才启动服务器修复
              if (reconnectAttempts === MAX_RECONNECT_ATTEMPTS - 1) {
                log('⚠️ 连接失败，尝试自动启动服务器...');
                repairServerConnection();
              } else {
                // 快速重试
                attemptReconnect();
              }
            } else {
              log('❌ 多次重连失败，请手动操作');
              updateStatus('disconnected', t('status_reconnect'));
              showServerStartHelp();
            }
          } else {
            reconnectAttempts = 0;
            log('✅ 重新连接成功');
          }
        }, 1500);
      }, 300);
    }
    
    // 修复服务器连接（自动启动服务器）
    function repairServerConnection() {
      log('🔧 正在尝试自动启动服务器...');
      // showToast('正在启动服务器...', 'loading'); // 移除 loading toast，避免视觉干扰
      
      // 触发后端自动启动服务器
      parent.postMessage({
        pluginMessage: {
          type: 'repair-server',
          installPath: serverInstallPath || '/Applications/ScreenSync - SourceCode'
        }
      }, '*');
      
      // 🚀 优化：缩短等待时间（从 7s 减少到 3s）
      setTimeout(() => {
        log('🔄 服务器已启动，正在连接...');
        connect();
        
        // 🚀 优化：缩短检查时间（从 3s 减少到 2s）
        setTimeout(() => {
          if (!ws || ws.readyState !== WebSocket.OPEN) {
            if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
              log('⚠️  仍未连接，继续尝试...');
              reconnectAttempts++;
              attemptReconnect();
            } else {
              log('❌ 自动修复失败');
              updateStatus('disconnected', t('status_reconnect'));
              reconnectAttempts = 0;
            }
          } else {
            reconnectAttempts = 0;
            log('✅ 服务器已启动并连接成功');
            showToast(t('toast_server_started'), 'success');
          }
        }, 2000);
      }, 3000);
    }
    
    // 显示服务器启动帮助
    function showServerStartHelp() {
      const helpHtml = `
        <div style="padding: 20px; text-align: center;">
          <div style="font-size: 48px; margin-bottom: 16px;">⚠️</div>
          <div style="font-size: 16px; font-weight: 600; margin-bottom: 12px; color: var(--text-primary);">
            ${t('help_server_not_running')}
          </div>
          <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 20px; line-height: 1.6;">
            ${t('help_cannot_connect')}<br/>
            ${t('help_try_solutions')}
          </div>
          <button onclick="retryStartServer()" style="
            padding: 10px 24px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: var(--radius-s);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            margin-bottom: 12px;
            width: 200px;
          ">
            ${t('help_retry_start')}
          </button>
          <div style="font-size: 12px; color: var(--text-tertiary); margin-top: 16px; padding: 12px; background: var(--bg-secondary); border-radius: var(--radius-s); text-align: left;">
            <div style="font-weight: 600; margin-bottom: 8px;">${t('help_still_cannot')}</div>
            <div>${t('help_check_prefs')}</div>
            <div>${t('help_ensure_service')}</div>
            <div>${t('help_restart')}</div>
          </div>
        </div>
      `;
      
      // 替换主界面内容
      document.querySelector('.container').innerHTML = helpHtml;
      
      // 定义重试函数
      window.retryStartServer = function() {
        // 恢复原始界面
        location.reload();
      };
    }

    function connect() {
      // 不要在连接开始时立即更新status，避免重连时频繁切换
      // 只有在真正连接成功后才更新status

      // 🔧 关键修复：在创建新连接之前，彻底关闭旧连接
      if (ws) {
        try {
          log('🧹 清理旧连接...');
          // 移除所有事件监听器，防止触发 onclose 导致自动重连
          ws.onopen = null;
          ws.onmessage = null;
          ws.onerror = null;
          ws.onclose = null;
          
          // 如果连接还未完全关闭，强制关闭
          if (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) {
            ws.close();
            log('   已关闭旧 WebSocket 连接');
          }
          
          ws = null;
        } catch (error) {
          log('   ⚠️ 关闭旧连接时出错: ' + error.message);
          ws = null;
        }
      }

      // ✅ 用 try-catch 包裹 WebSocket 初始化，确保服务器未启动时不会阻止页面加载
      try {
        ws = new WebSocket(SERVER_URL + '?id=' + connectionId + '&type=figma');
        
        // 🚀 添加连接超时（2秒），避免无限等待
        const connectionTimeout = setTimeout(() => {
          if (ws && ws.readyState === WebSocket.CONNECTING) {
            ws.close();
          }
        }, 2000);
        
        // 连接成功时清除超时
        const originalOnOpen = ws.onopen;
        ws.onopen = function(event) {
          clearTimeout(connectionTimeout);
          if (originalOnOpen) originalOnOpen.call(ws, event);
        };
        
      } catch (error) {
        console.error('❌ WebSocket 初始化失败:', error);
        log('❌ 无法连接到服务器');
        
        // 🚀 优化：缩短重试延迟（从 2s 减少到 500ms）
        if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
           updateStatus('disconnected', t('status_reconnect'));
        } else {
           updateStatus('waiting', t('status_connecting'));
           setTimeout(() => {
             reconnectAttempts++;
             connect();
           }, 500);
        }
        return;
      }

      ws.onopen = function () {
        log('✅ 已连接');
        reconnectAttempts = 0; // 重置重试计数
        
        // 所有模式统一显示"已连接"
        updateStatus('connected', t('status_connected'));

        if (ws.readyState === 1) {
          // 注册插件实例（用于单实例限制）
          wsSend('register-instance', { connectionId: connectionId, timestamp: Date.now() });
          
          wsSend('get-sync-mode');
          wsSend('get-server-info');
          wsSend('get-backup-screenshot-setting');
          // 自动检测更新（不需要打开设置）
          wsSend('check-update');
        }
        
        if (heartbeatTimer) clearInterval(heartbeatTimer);
        heartbeatTimer = setInterval(function () {
          wsSend('ping');
        }, 5000);
        
        // 启动定期检查更新（每小时检查一次）
        if (updateCheckTimer) clearInterval(updateCheckTimer);
        updateCheckTimer = setInterval(function () {
          wsSend('check-update');
        }, UPDATE_CHECK_INTERVAL);
        
        // 自动进入实时模式（如果尚未选择模式）
        if (!currentMode) {
          showWorkArea('realtime');
        }
        
        // 🚀 如果实时模式已激活，重连后自动恢复实时同步
        if (currentMode === 'realtime' && isRealtimeActive) {
          setTimeout(() => {
            if (wsSend('start-realtime')) {
              log('⚡ 实时同步已恢复');
            }
          }, 500);
        }
      };

      ws.onmessage = function (event) {
        // 🛡️ 安全解析 JSON，防止解析失败导致错误
        var data;
        try {
          data = JSON.parse(event.data);
        } catch (parseError) {
          console.error('❌ WebSocket 消息解析失败:', parseError);
          return;
        }
        
        if (!data || !data.type) return;
        if (data.type === 'pong') { return; }

        // 🛡️ 包裹所有消息处理逻辑，防止错误导致插件崩溃
        try {
        // 处理强制关闭（单实例限制）
        if (data.type === 'force-close') {
          log('⚠️  检测到您在其他文件中打开了插件，当前插件将自动关闭');
          // 延迟 2 秒关闭，让用户看到提示
          setTimeout(() => {
            parent.postMessage({
              pluginMessage: { type: 'close-plugin' }
            }, '*');
          }, 2000);
          return;
        }

        // Handle preview frames result for timeline editor
        if (data.type === 'preview-frames-result') {
          handlePreviewFramesResult(data);
          return;
        }

        if (data.type === 'server-info') {
          if (data.path) {
            serverInstallPath = data.path;
            
            // 保存路径到本地存储
            parent.postMessage({
              pluginMessage: {
                type: 'save-server-path',
                path: data.path
              }
            }, '*');

            const pathEl = document.getElementById('server-path-placeholder');
            if (pathEl) {
              pathEl.textContent = serverInstallPath;
              // 移除占位符的特殊样式，使用普通文本样式
              pathEl.style.color = 'inherit';
            }
          }
        } else if (data.type === 'screenshot') {
          // ✅ 标记同步已开始（收到了服务器响应）
          if (isManualSyncing) {
            syncStarted = true;
          }
          if (data.backedUpLocally || data.keptInIcloud) {
             // ✅ 根据文件类型分别计数
             // 只有 GIF 才增加 gifBackupCount，图片不计入（iCloud 模式下图片保留是正常行为）
             if (data.isGif) {
               gifBackupCount++;
             }
             // Don't reset state - let currentButtonState handle locking
             updateStatus('connected', '');
          }
          handleScreenshot(data);
        } else if (data.type === 'file-skipped') {
          // ✅ 标记同步已开始（收到了服务器响应）
          if (isManualSyncing) {
            syncStarted = true;
          }
          // 确定原因文本
          let reasonText = t('reason_unknown');
          if (data.reason === 'mp4' || data.reason === 'video') {
            const ext = (data.filename || '').toLowerCase();
            if (ext.endsWith('.mov')) {
              reasonText = t('reason_mov');
            } else {
              reasonText = t('reason_mp4');
            }
          } else if (data.reason === 'gif-too-large') {
            reasonText = t('reason_gif_large');
          }

          // ✅ 缓存文件的元数据（用于导出时自动关联）
          if (data.filename && (data.gifCacheId || data.driveFileId || data.ossFileId)) {
            skippedFileCache.set(data.filename, {
              gifCacheId: data.gifCacheId || null,
              driveFileId: data.driveFileId || null,
              ossFileId: data.ossFileId || null,
              timestamp: Date.now()
            });
            // 超出容量上限时，淘汰最旧的条目（Map 迭代顺序 = 插入顺序）
            if (skippedFileCache.size > SKIPPED_FILE_CACHE_MAX) {
              const firstKey = skippedFileCache.keys().next().value;
              skippedFileCache.delete(firstKey);
            }
          }

          // 去重检查：如果文件名已存在，则不增加计数，也不显示重复的日志
          if (!skippedFilesSet.has(data.filename)) {
            skippedFilesSet.add(data.filename);
            manualDragCount++;
            log(`⚠️  ${data.filename} 需手动导入（${reasonText}）`);
            
            // ✅ 立即更新状态pill，确保显示"已保存 X 段视频"
            // 只有在当前没有更高优先级的状态锁定时才设置
            if (!justFinishedExport && currentButtonState !== 'exported') {
              currentButtonState = 'video'; // 锁定为video状态
            }
          }
          
          // 即使重复，也尝试发送确认消息以确保后台状态同步（可选，但为了保险起见）
          try {
            wsSend('screenshot-failed', { filename: data.filename, error: reasonText, keepFile: true });
          } catch (error) {
            console.error('发送失败消息失败:', error);
          }
          
          // ✅ 触发状态更新，显示video状态pill
          updateStatus('connected', '');
        } else if (data.type === 'manual-sync-complete') {
          // Complete manual sync with animation
          
          // ✅ 清除超时定时器
          if (manualSyncTimeoutId) {
            clearTimeout(manualSyncTimeoutId);
            manualSyncTimeoutId = null;
          }
          syncStarted = false; // 重置同步开始标记

          const manualSyncBtn = document.getElementById('manualSyncBtn');
          
          // ✅ 立即停止旋转动画和进度环
          if (progressRingManual) {
            progressRingManual.style.animation = '';
            progressRingManual.style.opacity = 0;
          }
          
          // ✅ 触发 icon 闪烁动画
          if (manualSyncBtn) {
            const syncIcon = manualSyncBtn.querySelector('.icon-manual-sync');
            if (syncIcon) {
              syncIcon.classList.add('icon-completion-glow');
              setTimeout(() => {
                syncIcon.classList.remove('icon-completion-glow');
              }, 1400);
            }
            
            // Remove syncing state
            manualSyncBtn.classList.remove('exporting');
            manualSyncBtn.setAttribute('data-tooltip', t('tooltip_manual_sync'));
          }
          
          // ✅ 构建 toast 消息
          // imageCount = 成功导入 Figma 的纯图片数量
          // gifCount = 所有 GIF 数量（用于 toast 显示）
          // videoCount = 所有视频数量（用于 toast 显示）
          // savedGifCount = 实际保存到本地的 GIF 数量（用于 status pill）
          // savedVideoCount = 实际保存到本地的视频数量（用于 status pill）
          const imageCount = data.imageCount || 0;
          const gifCount = data.gifCount || 0;
          const videoCount = data.videoCount || 0;
          const savedGifCount = data.savedGifCount || 0;
          const savedVideoCount = data.savedVideoCount || 0;
          
          let toastMessage;

          // ✅ 更新 status pill 状态：只显示实际保存到本地的文件
          // 注意：使用 savedGifCount 和 savedVideoCount，而不是 gifCount 和 videoCount
          // 因为当备份模式为"无"时，GIF 不会被保存到本地
          if (savedVideoCount > 0) {
            manualDragCount = savedVideoCount;
            pendingStates.savedVideo.active = true;
            pendingStates.savedVideo.count = savedVideoCount;
            currentButtonState = 'video';
          }
          if (savedGifCount > 0) {
            gifBackupCount = savedGifCount;
            pendingStates.savedGif.active = true;
            pendingStates.savedGif.count = savedGifCount;
            if (!pendingStates.savedVideo.active) {
              currentButtonState = 'gif-backup';
            }
          }

          // ✅ 构建 toast 消息：显示所有同步的文件类型（不管是否保存到本地）
          const parts = [];
          if (imageCount > 0) parts.push(tPlural('sync_images', imageCount));
          if (gifCount > 0) parts.push(tPlural('sync_gifs', gifCount));
          if (videoCount > 0) parts.push(tPlural('sync_videos', videoCount));
          
          if (parts.length === 0) {
            toastMessage = t('sync_zero_images');
          } else {
            toastMessage = t('sync_done_prefix') + parts.join(currentLang === 'zh' ? '，' : ', ');
          }
          
          // ✅ 显示 toast（延迟一点等 icon 开始闪烁）
          setTimeout(() => {
            showToast(toastMessage, 'success');
            log(toastMessage);
          }, 200);
          
          // Reset state
          isManualSyncing = false;
          
          // 恢复同步按钮状态（保持旧的 syncBtn 逻辑以防万一）
          const syncBtn = document.getElementById('syncBtn');
          if (syncBtn) {
            // 清除超时定时器
            if (syncBtn.dataset.syncTimeout) {
              clearTimeout(parseInt(syncBtn.dataset.syncTimeout));
              delete syncBtn.dataset.syncTimeout;
            }
            
            // 重置标志和按钮状态
            syncBtn.disabled = false;
            syncBtn.textContent = t('btn_sync_now');
          }
          
          // 检查连接状态，只有在连接时才更新status
          if (!ws || ws.readyState !== 1) {
            updateStatus('disconnected', t('status_reconnect'));
            return;
          }
          
          // 检查是否有真正的错误消息（如用户文件夹未初始化、网络错误等）
          // 注意：如果 total === 0 且没有 message，说明是文件夹为空，这是正常情况，不是错误
          if (data.message && data.total === 0 && data.count === 0) {
            log(`❌ ${data.message}`);
            // 根据不同的错误消息给出友好提示
            if (data.message.includes('未初始化') || data.message.includes('未连接')) {
              alert(t('error_sync_fail') + '：' + data.message + '\n\n' + t('error_sync_suggestion') + '\n' + t('error_ensure_server') + '\n' + t('error_upload_first') + '\n' + t('error_wait_retry') + '\n' + t('error_restart_server'));
            } else {
              alert(t('error_sync_fail') + '：' + data.message);
            }
            updateStatus('connected', t('status_sync_fail'));
            return;
          }
          
          if (manualDragCount > 0) {
            log(`⚠️  有 ${manualDragCount} 个文件需手动导入`);
            updateStatus('connected', '');
             return;
          }
          
          // 优化后的逻辑：支持显示部分失败和具体错误详情
          if (data.total === 0) {
            // 没有文件，但不是错误（message 为空）
            log('✅ 同步完成：0 张截图（文件夹为空）');
            updateStatus('connected', t('status_sync_done'));
          } else if (data.count === data.total) {
            // 全部成功
            log(`✅ 同步完成：全部 ${data.count} 张截图`);
            if (gifBackupCount > 0) {
              updateStatus('connected', '');
            } else {
            updateStatus('connected', t('status_sync_done'));
            }
          } else {
            // 部分或全部失败
            const failed = data.total - data.count;
            if (data.count > 0) {
               log(`⚠️  同步完成，但有 ${failed} 张失败 (成功 ${data.count}/${data.total})`);
            } else {
               log(`⚠️  同步失败，${data.total} 张全部处理失败`);
            }
            
            // 显示详细错误信息
            if (data.errors && data.errors.length > 0) {
              log(`🔍 错误详情:`);
              data.errors.slice(0, 5).forEach(err => {
                log(`   ❌ ${err.filename}: ${err.error}`);
              });
              if (data.errors.length > 5) {
                log(`   ... 以及其他 ${data.errors.length - 5} 个错误`);
              }
              
              // 延迟弹窗显示第一个错误，帮助调试
              setTimeout(() => {
                const firstErr = data.errors[0];
                alert('❌ ' + t('error_screenshot_fail') + '\n\n' + t('error_filename') + ': ' + firstErr.filename + '\n' + t('error_message') + ': ' + firstErr.error + '\n\n' + t('error_send_dev'));
              }, 200);
            } else {
              log(`   ❌ 未知错误 (无详细信息)`);
            }
            updateStatus('connected', t('status_sync_done'));
          }
        } else if (data.type === 'error') {
          // 处理服务器通用错误消息
          console.error('❌ Server Error:', data.message);
          showToast(data.message || t('toast_unknown_error'), 'error');
          
          // 如果手动同步正在进行中，重置状态
          if (isManualSyncing) {
            isManualSyncing = false;
            const manualSyncBtn = document.getElementById('manualSyncBtn');
            if (manualSyncBtn) {
              manualSyncBtn.classList.remove('exporting');
              manualSyncBtn.setAttribute('data-tooltip', t('tooltip_manual_sync'));
            }
            if (progressRingManual) {
              progressRingManual.style.opacity = 0;
              progressRingManual.style.animation = '';
            }
            updateStatus('connected', t('status_sync_fail'));
          }
        } else if (data.type === 'sync-mode-changed') {
          currentSyncMode = data.mode;
          updateSyncModeDisplay();
          if (checkQRCodeVisibility()) {
          updateQRCodeDisplay();
          }
          log('✅ 储存方式已切换');
        } else if (data.type === 'gif-compose-progress') {
          // 处理服务器推送的真实进度
          if (data.progress) {
             updateRealProgress(data.progress, data.message);
          }
        } else if (data.type === 'gif-compose-success') {
          // ⏱️ 在 console 中显示导出耗时
          if (data.exportDurationSeconds) {
            console.log(`✅ 导出成功，耗时 ${data.exportDurationSeconds} 秒`);
          }
          
          handleExportSuccess();
          
          // 只有在真正导出新文件时才增加计数（跳过的不计数）
          if (!data.skipped) {
            exportedGifCount++;
          }
          
          // 标记刚完成导出，这样即使计数没增加，也会优先显示导出状态
          justFinishedExport = true;
          updateStatus('connected', '');
        } else if (data.type === 'gif-compose-error') {
          // Update Progress (count as done but failed)
          console.error('❌ 收到服务器错误响应');
          console.error('   错误消息:', data.message || data.error || '未知错误');
          console.error('   完整错误详情:', data.details || '无');
          
          // ✅ 如果是因为取消导出导致的错误，忽略错误 toast
          if (isCancellingExport) {
            handleExportError();
            isCancellingExport = false; // 重置标志
            return;
          }
          
          // 检查是否是"未找到文件"的错误
          const errorMsg = data.message || data.error || '';
          if (errorMsg.includes('未找到 GIF/视频文件')) {
            handleExportError();
            showToast(t('toast_file_not_found'), 'error');
            
            // 通知 code.js 清除相关 GIF 的 pluginData
            parent.postMessage({
              pluginMessage: { 
                type: 'clear-gif-data-and-retry'
              }
            }, '*');
          } else {
            handleExportError();
            // 只在 toast 显示简短错误提示，详细信息在 console
            showToast(t('toast_export_fail'), 'error');
          }
        } else if (data.type === 'gif-compose-cancelled') {
          // 处理取消确认消息 - UI 已经在 cancelGifExport 中处理了重置，这里不需要额外操作
        } else if (data.type === 'sync-mode-info') {
          currentSyncMode = data.mode;
          updateSyncModeDisplay();
          // 如果设置界面是打开的，确保立即更新显示
          if (settingsOverlay && settingsOverlay.classList.contains('show')) {
            // updateSyncModeDisplay() 已经在上面的调用中更新了，这里不需要再次调用
            // 但可以确保显示是最新的
          }
          if (checkQRCodeVisibility()) {
            updateQRCodeDisplay();
          }
        } else if (data.type === 'cache-existence-result') {
          // ✅ 处理服务器返回的缓存检查结果
          
          // 转发给 code.js 处理（转换消息类型以匹配 code.js 期望的格式）
          // ✅ 只有在导出流程中的缓存检查才需要继续触发导出
          parent.postMessage({
            pluginMessage: {
              type: 'server-cache-check-result',
              results: data.results || [],
              fromExport: pendingExportCacheCheck // 标记是否来自导出流程
            }
          }, '*');
          // 重置标志
          pendingExportCacheCheck = false;
        } else if (data.type === 'auto-cache-video-result') {
          // 🔄 Server 自动查找并缓存视频文件的结果
          console.log('🔄 [自动缓存] 收到结果:', data.filename, data.success ? '✅' : '❌');
          parent.postMessage({
            pluginMessage: {
              type: 'auto-cache-result',
              filename: data.filename,
              timestamp: data.timestamp,
              success: data.success,
              gifCacheId: data.cacheId || null,
              error: data.error || null
            }
          }, '*');
        } else if (data.type === 'switch-sync-mode-result') {
          if (data.success) {
            // 简化消息：从"储存方式已切换为 XXX"改为"已切换为 XXX方式"
            let modeName = t('mode_name_unknown');
            if (data.mode === 'drive' || data.mode === 'google') {
              modeName = t('mode_name_google');
            } else if (data.mode === 'aliyun' || data.mode === 'oss') {
              modeName = t('mode_name_aliyun');
            } else if (data.mode === 'icloud') {
              modeName = t('mode_name_icloud');
            }
            showToast(t('toast_switched_to', modeName), 'success');
            currentSyncMode = data.mode;
            updateSyncModeDisplay();
            if (useCaseOverlay && useCaseOverlay.classList.contains('show')) {
              updateQRCodeDisplay();
            }
            
            // 重新启动实时同步（而不是显示模式选择）
            stopRealtimeSync();
            setTimeout(() => {
              showWorkArea('realtime');
              closeSettings();
            }, 1000);
          } else {
            // 如果是空间不足错误，显示特定的错误消息
            if (data.isSpaceError) {
              showToast(t('toast_icloud_full'), 'error');
            } else {
              showToast(data.message || t('toast_switch_fail'), 'error');
            }
          }
        } else if (data.type === 'user-id-info') {
            const el = document.getElementById('displayUserId');
            if (el) {
              el.textContent = data.userId || t('toast_unknown_error');
              // Remove i18n attr so applyLanguage() won't overwrite the actual userId
              if (data.userId) el.removeAttribute('data-i18n');
            }
        } else if (data.type === 'plugin-update-info') {
          // 处理插件更新信息
          handlePluginUpdateInfo(data);
        } else if (data.type === 'server-update-info') {
          // 处理服务器更新信息
          handleServerUpdateInfo(data);
        } else if (data.type === 'plugin-version-info') {
          // 处理插件版本信息
          handlePluginVersionInfo(data);
        } else if (data.type === 'plugin-update-progress') {
          // 处理插件更新进度（已废弃，兼容旧版）
          handleUpdateProgress(data);
        } else if (data.type === 'server-update-progress') {
          // 处理服务器更新进度（已废弃，兼容旧版）
          handleUpdateProgress(data);
        } else if (data.type === 'update-progress') {
          // 处理统一更新进度
          handleUpdateProgress(data);
        } else if (data.type === 'backup-screenshot-setting-info') {
          // 接收备份截图设置信息
          if (typeof backupModeSelect !== 'undefined' && backupModeSelect) {
            const mode = data.mode || (data.enabled ? 'all' : 'none');
            backupModeSelect.value = mode;
            originalSettings.backupMode = mode;
            // 调整宽度以适应当前选项
            if (typeof adjustSelectWidth === 'function') {
              adjustSelectWidth(backupModeSelect);
            }
          }
        } else if (data.type === 'backup-screenshot-setting-updated') {
          // 备份截图设置已更新
          if (data.success) {
            if (typeof backupModeSelect !== 'undefined' && backupModeSelect) {
              const mode = data.mode || (data.enabled ? 'all' : 'none');
              originalSettings.backupMode = mode;
            }
          } else {
            showToast(t('toast_backup_fail'), 'error');
          }
        }
        } catch (msgError) {
          // 🛡️ 捕获消息处理错误，防止插件崩溃
          console.error('❌ WebSocket 消息处理错误:', msgError);
          console.error('   消息类型:', (data && data.type) ? data.type : '未知');
        }
      };

      ws.onerror = function (error) {
        console.error('❌ WebSocket 连接错误:', error);
        log('❌ 连接失败');
        
        // ✅ 清除所有状态锁定，确保显示断开状态
        currentButtonState = null;
        justFinishedExport = false;
        exportedGifCount = 0;
        manualDragCount = 0;
        gifBackupCount = 0;
        // ✅ 重置新的状态系统
        pendingStates.exported = { count: 0, active: false };
        pendingStates.savedVideo = { count: 0, active: false };
        pendingStates.savedGif = { count: 0, active: false };
        
        // 重置同步标志，防止按钮永久禁用
        isManualSyncing = false;
        syncStarted = false;
        if (manualSyncTimeoutId) {
          clearTimeout(manualSyncTimeoutId);
          manualSyncTimeoutId = null;
        }
      };

      ws.onclose = function () {
        log('⚠️ 连接断开');
        
        // ✅ 清除所有状态锁定，确保显示断开状态
        currentButtonState = null;
        justFinishedExport = false;
        exportedGifCount = 0;
        manualDragCount = 0;
        gifBackupCount = 0;
        // ✅ 重置新的状态系统
        pendingStates.exported = { count: 0, active: false };
        pendingStates.savedVideo = { count: 0, active: false };
        pendingStates.savedGif = { count: 0, active: false };
        
        if (heartbeatTimer) clearInterval(heartbeatTimer);
        if (updateCheckTimer) clearInterval(updateCheckTimer); // 清除更新检查定时器
        // 重置同步标志，防止按钮永久禁用
        isManualSyncing = false;
        syncStarted = false;
        if (manualSyncTimeoutId) {
          clearTimeout(manualSyncTimeoutId);
          manualSyncTimeoutId = null;
        }
        
        // ✅ 智能重连逻辑 - 🚀 优化：更短的延迟
        if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
          reconnectAttempts++;
          // 🚀 优化：固定 500ms 延迟，不再递增（原来是 1s, 2s, 3s...）
          const delay = 500;
          log(`⏳ 正在重试 (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
          
          updateStatus('waiting', t('status_connecting'));
          
          setTimeout(() => {
            connect();
          }, delay);
        } else {
          // ❌ 重试次数耗尽，显示手动重连按钮
          log('❌ 自动重连失败，请手动点击重连');
          updateStatus('disconnected', t('status_reconnect'));
        }
      };
    }

    let currentFileId = null;
    let currentFileIdType = null;
    let currentFileBackedUp = false;

    function handleScreenshot(data) {
      log(`📸 ${data.filename || '截图'}`);
      
      currentFileId = data.ossFileId || data.driveFileId || null;
      currentFileIdType = data.ossFileId ? 'oss' : (data.driveFileId ? 'drive' : null);
      // 检查文件是否已备份（Google Drive）或保留（iCloud）
      currentFileBackedUp = data.backedUpLocally || data.keptInIcloud || false;

      try {
      parent.postMessage({
        pluginMessage: {
          type: 'add-screenshot',
          bytes: data.bytes,
          timestamp: data.timestamp,
          filename: data.filename,
          driveFileId: data.driveFileId,
          ossFileId: data.ossFileId,
          gifCacheId: data.gifCacheId  // ✅ 传递 gifCacheId（用于 GIF 导出）
        }
      }, '*');
      } catch (error) {
        log('❌ 处理失败: ' + error.message);
        console.error('发送失败:', error);
        
        // 如果发送到 Figma 失败（例如消息过大），但已经备份到本地
        // 那么我们也应该通知服务器可以删除云端文件，因为本地已经有了
        if (currentFileBackedUp) {
          log('⚠️  发送到 Figma 失败，但文件已备份到本地，确认删除云端文件');
          showToast(t('toast_import_fail_local'), 'warning');
          
          if (ws && ws.readyState === WebSocket.OPEN) {
            if (currentFileId) {
              try {
                const confirmMessage = {
                  type: 'screenshot-received',
                  filename: data.filename || '未命名文件',
                  timestamp: Date.now()
                };
                if (currentFileIdType === 'oss') confirmMessage.ossFileId = currentFileId;
                else if (currentFileIdType === 'drive') confirmMessage.driveFileId = currentFileId;
                ws.send(JSON.stringify(confirmMessage));
                
                // Reset
                currentFileId = null;
                currentFileIdType = null;
                currentFileBackedUp = false;
              } catch (sendError) {
                console.error('❌ 发送确认失败:', sendError);
              }
            }
          }
        }
      }
    }

    // Helper to animate width changes for smooth morphing
    let _pillAnimTimer = null; // 追踪 setTimeout，防止快速连续调用时旧定时器干扰新动画
    let _pillHasAnimatedOnce = false; // 首次淡入动画是否已完成
    function animateWidthChange(element, updateContentFn) {
        // 🚀 修复：先测量旧宽度，更新内容后测量新宽度，用像素值做动画
        
        // 取消上一次未完成的定时器（防止连续调用时旧清除操作覆盖新状态）
        if (_pillAnimTimer) {
            clearTimeout(_pillAnimTimer);
            _pillAnimTimer = null;
        }
        
        // 1. 保存当前宽度
        const oldWidth = element.offsetWidth;
        
        // 防止文本换行
        element.style.whiteSpace = 'nowrap';
        
        // 2. 执行内容更新（会重置 className，可能重新触发 CSS animation）
        updateContentFn();
        
        // 🔑 关键修复：阻止 fadeInGlass CSS animation 每次都重新触发
        // 首次显示需要淡入，之后的更新不应该闪烁
        if (_pillHasAnimatedOnce) {
            element.style.animation = 'none';
            element.style.opacity = '1';
        } else {
            // 首次：让 CSS animation 正常运行，但标记已完成
            _pillHasAnimatedOnce = true;
        }
        
        // 3. 临时清除所有过渡和宽度限制，测量内容真实宽度
        element.style.transition = 'none';
        element.style.width = 'fit-content';
        element.style.minWidth = 'fit-content';
        
        // 强制回流以获取新宽度
        void element.offsetWidth;
        const newWidth = element.offsetWidth;
        
        // 如果宽度没变化，直接保持 fit-content，无需动画
        if (Math.abs(newWidth - oldWidth) < 2) {
            element.style.transition = '';
            return;
        }
        
        // 4. 设回旧宽度作为动画起点
        element.style.width = oldWidth + 'px';
        
        // 5. 强制回流（确保浏览器记录起点）
        void element.offsetWidth;
        
        // 6. 启用过渡并动画到新宽度（不含 opacity — 避免和 CSS animation 冲突）
        element.style.transition = 'width 0.3s cubic-bezier(0.25, 0.8, 0.25, 1), background 0.3s ease, color 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease';
        element.style.width = newWidth + 'px';
        
        // 7. 动画完成后，恢复 fit-content 自适应宽度
        _pillAnimTimer = setTimeout(() => {
            _pillAnimTimer = null;
            // ⚠️ 关键：先关闭 transition，防止浏览器尝试从 px 过渡到 fit-content（关键字无法插值）
            element.style.transition = 'none';
            element.style.width = 'fit-content';
            element.style.minWidth = 'fit-content';
            element.style.whiteSpace = 'nowrap';
            element.style.overflow = '';
            // 强制回流确认 fit-content 已应用
            void element.offsetWidth;
            // 下一帧恢复 CSS class 定义的过渡（不含 width）
            requestAnimationFrame(() => {
                element.style.transition = '';
            });
        }, 400); // 略长于动画时长(300ms)，留足余量
    }

    // 生成 status pill 右箭头的 HTML
    function getPillChevronHTML() {
      return `
        <span class="pill-chevron" style="position: relative; z-index: 2; display: flex; align-items: center; margin-left: -4px;">
          <svg width="12" height="12" viewBox="0 0 12 24" fill="none" stroke="currentColor" stroke-width="3.0" stroke-linecap="round" stroke-linejoin="round" style="margin-left: -4px;">
            <polyline points="9 18 15 12 9 6"></polyline>
          </svg>
        </span>
      `;
    }
    
    // 生成 status pill 关闭按钮的 HTML
    function getPillCloseButtonHTML() {
      return `
        <span class="pill-close-btn" onclick="event.stopPropagation();">
          <svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round">
            <path d="M2 2L10 10M10 2L2 10"/>
          </svg>
        </span>
      `;
    }

    // 为 status pill 绑定关闭按钮事件
    function bindPillCloseButton(statusEl, clearStateFn) {
      const closeBtn = statusEl.querySelector('.pill-close-btn');
      if (closeBtn) {
        closeBtn.onclick = function(e) {
          e.stopPropagation();
          clearStateFn();
        };
      }
    }

    // 记录最后一次 updateStatus 的 type，供 applyLanguage 后刷新
    let _lastStatusType = 'waiting';
    
    function updateStatus(type, text) {
      // 🛡️ 防止初始化未完成时崩溃
      try {
        _lastStatusType = type;
        const statusEl = document.getElementById('status');
        if (!statusEl) return; // 元素不存在时直接返回

        // ✅ 强制检查：如果 WebSocket 断开，清除所有锁定状态并强制显示断开
        if (!ws || ws.readyState !== WebSocket.OPEN) {
        if (type !== 'disconnected' && type !== 'waiting') {
          currentButtonState = null;
          justFinishedExport = false;
          // ✅ 重置新的状态系统
          pendingStates.exported = { count: 0, active: false };
          pendingStates.savedVideo = { count: 0, active: false };
          pendingStates.savedGif = { count: 0, active: false };
        }
        if (type === 'connected') {
        type = 'disconnected';
        if (!text || text === '') {
          text = t('status_disconnected');
        }
      }
      }

      // Wrap the content update in our animation helper
      animateWidthChange(statusEl, () => {
          // Reset Base State
          statusEl.className = 'connection-pill';
          statusEl.style.cursor = 'default';
          statusEl.onclick = null;
          statusEl.style.display = '';
          statusEl.innerHTML = '';

          // 1. Disconnected / Waiting - Always highest priority when not connected
          if (type === 'disconnected' || (type === 'waiting' && (!ws || ws.readyState !== WebSocket.OPEN))) {
            const isDisconnected = type === 'disconnected';
            const displayText = text || (isDisconnected ? t('status_reconnect') : t('status_connecting'));
            
            let pillClass = 'connection-pill interactive';
            if (type === 'waiting') {
                pillClass += ' waiting';
            } else if (displayText === t('status_disconnected')) {
                pillClass += ' offline'; // Gray, no glow
            } else {
                pillClass += ' reconnect'; // Red, glow
            }

        // Waiting state: recessed (no bezel/face), other states: button style (with bezel/face)
        if (type === 'waiting') {
        statusEl.innerHTML = `
              <span class="status-dot"></span>
              <span>${displayText}</span>
            `;
        } else {
            statusEl.innerHTML = `
              <div class="bezel"></div>
              <div class="face"></div>
              <span class="status-dot" style="position: relative; z-index: 2;"></span>
              <span style="position: relative; z-index: 2;">${displayText}</span>
        `;
        }
        
            statusEl.className = pillClass;
        statusEl.style.cursor = 'pointer';
        statusEl.style.display = 'flex';
        statusEl.style.alignItems = 'center';
        statusEl.onclick = function() {
          attemptReconnect();
        };
        return;
      }

          // ========================================
          // ✅ 新的状态管理逻辑
          // ========================================
          // 规则：
          // 1. 导出完成时，立即清除所有"已保存"状态，只显示"已导出"
          // 2. 点击"已导出"后，恢复"已连接"
          // 3. 同步完成时，"已保存视频"和"已保存GIF"可同时存在
          // 4. 点击"已保存视频"后，只清除视频状态，继续显示GIF状态（如果有）
          // 5. 点击"已保存GIF"后，只清除GIF状态，继续显示视频状态（如果有）
          // 6. 所有状态都点击完后，恢复"已连接"
          // ========================================

          // 2. 导出完成 - 最高优先级，立即清除所有"已保存"状态
          if (justFinishedExport) {
            // ✅ 关键：导出完成时，清除所有"已保存"状态
            pendingStates.savedVideo.active = false;
            pendingStates.savedVideo.count = 0;
            pendingStates.savedGif.active = false;
            pendingStates.savedGif.count = 0;
            manualDragCount = 0;
            gifBackupCount = 0;
            skippedFilesSet.clear();
            
            // 设置导出状态
            pendingStates.exported.active = true;
            pendingStates.exported.count = exportedGifCount > 0 ? exportedGifCount : 1;
            currentButtonState = 'exported';
            
            const displayCount = pendingStates.exported.count;
            const exportText = tPlural('status_exported_gif', displayCount);
            statusEl.innerHTML = `
              <div class="bezel"></div>
              <div class="face"></div>
              <span class="status-dot" style="position: relative; z-index: 2;"></span>
              <span style="position: relative; z-index: 2;">${exportText}</span>
              ${getPillChevronHTML()}${getPillCloseButtonHTML()}
            `;
            statusEl.className = 'connection-pill connected interactive';
            statusEl.style.cursor = 'pointer';
            statusEl.onclick = function() {
              wsSend('open-folder', { targetFolder: 'GIF-导出' });
              // ✅ 点击后清除导出状态，恢复"已连接"
              pendingStates.exported.active = false;
              pendingStates.exported.count = 0;
              exportedGifCount = 0;
              justFinishedExport = false;
              currentButtonState = null;
              updateStatus('connected', t('status_connected'));
            };
            // 绑定关闭按钮（不打开文件夹，直接清除状态）
            bindPillCloseButton(statusEl, function() {
              pendingStates.exported.active = false;
              pendingStates.exported.count = 0;
              exportedGifCount = 0;
              justFinishedExport = false;
              currentButtonState = null;
              updateStatus('connected', t('status_connected'));
            });
            return;
          }

          // 3. 检查是否有导出状态（已锁定）
          if (pendingStates.exported.active || currentButtonState === 'exported') {
            const displayCount = pendingStates.exported.count > 0 ? pendingStates.exported.count : (exportedGifCount > 0 ? exportedGifCount : 1);
            const exportText = tPlural('status_exported_gif', displayCount);
            statusEl.innerHTML = `
              <div class="bezel"></div>
              <div class="face"></div>
              <span class="status-dot" style="position: relative; z-index: 2;"></span>
              <span style="position: relative; z-index: 2;">${exportText}</span>
              ${getPillChevronHTML()}${getPillCloseButtonHTML()}
            `;
            statusEl.className = 'connection-pill connected interactive';
            statusEl.style.cursor = 'pointer';
            statusEl.onclick = function() {
              wsSend('open-folder', { targetFolder: 'GIF-导出' });
              pendingStates.exported.active = false;
              pendingStates.exported.count = 0;
              exportedGifCount = 0;
              justFinishedExport = false;
              currentButtonState = null;
              updateStatus('connected', t('status_connected'));
            };
            // 绑定关闭按钮
            bindPillCloseButton(statusEl, function() {
              pendingStates.exported.active = false;
              pendingStates.exported.count = 0;
              exportedGifCount = 0;
              justFinishedExport = false;
              currentButtonState = null;
              updateStatus('connected', t('status_connected'));
            });
            return;
          }
          
          // 4. 检查"已保存视频"状态
          // 同步计数到 pendingStates
          if (manualDragCount > 0) {
            pendingStates.savedVideo.active = true;
            pendingStates.savedVideo.count = manualDragCount;
          }
          
          if (pendingStates.savedVideo.active && pendingStates.savedVideo.count > 0) {
            currentButtonState = 'video';
            const warningText = tPlural('status_saved_video', pendingStates.savedVideo.count);
            statusEl.innerHTML = `
              <div class="bezel"></div>
              <div class="face"></div>
              <span class="status-dot" style="position: relative; z-index: 2;"></span>
              <span style="position: relative; z-index: 2;">${warningText}</span>
              ${getPillChevronHTML()}${getPillCloseButtonHTML()}
            `;
            statusEl.className = 'connection-pill connected interactive';
            statusEl.style.cursor = 'pointer';
            statusEl.onclick = function() {
              wsSend('open-local-folder', { targetFolder: '视频' });
              // ✅ 只清除视频状态
              pendingStates.savedVideo.active = false;
              pendingStates.savedVideo.count = 0;
              manualDragCount = 0;
              skippedFilesSet.clear();
              
              // ✅ 检查是否还有 GIF 状态，如果有则继续显示
              if (pendingStates.savedGif.active && pendingStates.savedGif.count > 0) {
                currentButtonState = 'gif-backup';
              } else {
                currentButtonState = null;
              }
              justFinishedExport = false;
              updateStatus('connected', '');
            };
            // 绑定关闭按钮（不打开文件夹，直接清除状态）
            bindPillCloseButton(statusEl, function() {
              pendingStates.savedVideo.active = false;
              pendingStates.savedVideo.count = 0;
              manualDragCount = 0;
              skippedFilesSet.clear();
              if (pendingStates.savedGif.active && pendingStates.savedGif.count > 0) {
                currentButtonState = 'gif-backup';
              } else {
                currentButtonState = null;
              }
              justFinishedExport = false;
              updateStatus('connected', '');
            });
            return;
          }
          
          // 5. 检查"已保存GIF"状态
          // 同步计数到 pendingStates
          if (gifBackupCount > 0) {
            pendingStates.savedGif.active = true;
            pendingStates.savedGif.count = gifBackupCount;
          }
          
          if (pendingStates.savedGif.active && pendingStates.savedGif.count > 0) {
            currentButtonState = 'gif-backup';
            const backupText = tPlural('status_saved_gif', pendingStates.savedGif.count);
            statusEl.innerHTML = `
              <div class="bezel"></div>
              <div class="face"></div>
              <span class="status-dot" style="position: relative; z-index: 2;"></span>
              <span style="position: relative; z-index: 2;">${backupText}</span>
              ${getPillChevronHTML()}${getPillCloseButtonHTML()}
            `;
            statusEl.className = 'connection-pill connected interactive';
            statusEl.style.cursor = 'pointer';
            statusEl.onclick = function() {
              wsSend('open-local-folder', { targetFolder: 'GIF' });
              // ✅ 只清除 GIF 状态
              pendingStates.savedGif.active = false;
              pendingStates.savedGif.count = 0;
              gifBackupCount = 0;
              
              // ✅ 检查是否还有视频状态，如果有则继续显示
              if (pendingStates.savedVideo.active && pendingStates.savedVideo.count > 0) {
                currentButtonState = 'video';
              } else {
                currentButtonState = null;
              }
              justFinishedExport = false;
              updateStatus('connected', '');
            };
            // 绑定关闭按钮
            bindPillCloseButton(statusEl, function() {
              pendingStates.savedGif.active = false;
              pendingStates.savedGif.count = 0;
              gifBackupCount = 0;
              if (pendingStates.savedVideo.active && pendingStates.savedVideo.count > 0) {
                currentButtonState = 'video';
              } else {
                currentButtonState = null;
              }
              justFinishedExport = false;
              updateStatus('connected', '');
            });
            return;
          }

          // 6. 兼容旧逻辑：检查 exportedGifCount（如果新状态系统没捕获到）
          if (exportedGifCount > 0) {
            pendingStates.exported.active = true;
            pendingStates.exported.count = exportedGifCount;
            currentButtonState = 'exported';
            const exportText = tPlural('status_exported_gif', exportedGifCount);
            statusEl.innerHTML = `
              <div class="bezel"></div>
              <div class="face"></div>
              <span class="status-dot" style="position: relative; z-index: 2;"></span>
              <span style="position: relative; z-index: 2;">${exportText}</span>
              ${getPillChevronHTML()}${getPillCloseButtonHTML()}
            `;
            statusEl.className = 'connection-pill connected interactive';
            statusEl.style.cursor = 'pointer';
            statusEl.onclick = function() {
              wsSend('open-folder', { targetFolder: 'GIF-导出' });
              // ✅ 使用新的状态管理系统
              pendingStates.exported.active = false;
              pendingStates.exported.count = 0;
              exportedGifCount = 0;
              justFinishedExport = false;
              currentButtonState = null;
              updateStatus('connected', t('status_connected'));
            };
            // 绑定关闭按钮
            bindPillCloseButton(statusEl, function() {
              pendingStates.exported.active = false;
              pendingStates.exported.count = 0;
              exportedGifCount = 0;
              justFinishedExport = false;
              currentButtonState = null;
              updateStatus('connected', t('status_connected'));
            });
            return;
          }

          // 7. Default: Connected (Screen Style)
          // No counts, show connected state
          currentButtonState = null; // Ensure state is unlocked
          statusEl.innerHTML = `
            <span class="status-dot" style="position: relative; z-index: 2;"></span>
            <span style="position: relative; z-index: 2;">${t('status_connected')}</span>
          `;
          statusEl.className = 'connection-pill connected';
      });
      } catch (error) {
        console.error('❌ updateStatus 错误:', error);
      }
    }

    let isRealtimeActive = false;

    function showWorkArea(mode) {
      // 🛡️ 防止初始化未完成时崩溃
      try {
        currentMode = mode;
        document.getElementById('modeSelection').classList.add('hidden');
        document.getElementById('workArea').classList.add('active');
        
        collapseLog();
        
        // Legacy UI update (safeguard if elements exist)
        const activeModeIcon = document.getElementById('activeModeIcon');
        const activeModeTitle = document.getElementById('activeModeTitle');
        if (activeModeIcon) activeModeIcon.style.display = 'none'; // Hide legacy icon
        if (activeModeTitle) activeModeTitle.style.display = 'none'; // Hide legacy title

        if (mode === 'realtime') {
          // Realtime Mode Setup - Start in Idle State
          updateStartScreenUI('idle');
          
          // Update Status
          if (ws && ws.readyState === 1) {
            updateStatus('connected', t('status_connected'));
          } else {
            updateStatus('disconnected', t('status_reconnect'));
          }
        } else {
          // Legacy Manual Mode (should not be reached in new flow, but keep for safety)
          if (ws && ws.readyState === 1) {
            updateStatus('connected', t('status_connected'));
          }
        }
      } catch (error) {
        console.error('❌ showWorkArea 错误:', error);
      }
    }

    function updateStartScreenUI(state) {
        // 🛡️ 防止初始化未完成时崩溃
        try {
            const btn = document.getElementById('mainStartBtn');
            const label = document.getElementById('realtimeLabel');
            
            // Legacy support checks
            const oldTitle = document.getElementById('mainStatusTitle');
            const oldSubtitle = document.getElementById('mainStatusSubtitle');
            
            if (!btn) return;
            
            if (state === 'listening') {
                btn.classList.add('active');
                isRealtimeActive = true;
                
                // Label text and color remain unchanged
                
                if (oldTitle) oldTitle.textContent = t('realtime_syncing');
            } else {
                btn.classList.remove('active');
                isRealtimeActive = false;
                
                // Label text and color remain unchanged
                
                if (oldTitle) {
                    oldTitle.textContent = t('realtime_click_start');
                    oldTitle.style.color = 'var(--text-primary)';
                }
            }
        } catch (error) {
            console.error('❌ updateStartScreenUI 错误:', error);
        }
    }

    function toggleRealtimeSync() {
        // 🛡️ 防止初始化未完成时崩溃
        try {
            if (isRealtimeActive) {
                stopRealtimeSync();
            } else {
                startRealtimeSync();
            }
        } catch (error) {
            console.error('❌ toggleRealtimeSync 错误:', error);
        }
    }

    function startRealtimeSync() {
        // 🛡️ 防止初始化未完成时崩溃
        try {
            if (wsSend('start-realtime')) {
                log('⚡ 实时同步已启动');
                updateStartScreenUI('listening');
                updateStatus('connected', t('status_running'));
            } else {
                showToast(t('toast_server_offline'), 'error');
                updateStatus('disconnected', t('status_reconnect'));
            }
        } catch (error) {
            console.error('❌ startRealtimeSync 错误:', error);
            showToast(t('toast_startup_fail'), 'error');
        }
    }


    function showModeSelection() {
      if (currentMode === 'realtime') {
        wsSend('stop-realtime');
        log('⏸️  实时同步已停止');
      }

      screenshotCount = 0;
      manualDragCount = 0;
      skippedFilesSet.clear();
      gifBackupCount = 0;
      isManualSyncing = false; // 重置手动同步标志
      document.getElementById('count').textContent = '0';
      
      currentMode = null;
      document.getElementById('workArea').classList.remove('active');
      document.getElementById('modeSelection').classList.remove('hidden');
      updateStatus('connected', t('status_mode_selection'));
    }

    /* 
    document.getElementById('realtimeBtn').onclick = function () { showWorkArea('realtime'); };
    document.getElementById('manualBtn').onclick = function () { showWorkArea('manual'); };
    */

    document.getElementById('syncBtn').onclick = function () {
      // 第一道防线：使用 JavaScript 标志变量（更快更可靠）
      if (isManualSyncing) {
        return;
      }
      
      const syncBtn = document.getElementById('syncBtn');
      
      // 第二道防线：检查按钮状态
      if (syncBtn.disabled) {
        return;
      }
      
      // 检查连接状态
      if (!ws || ws.readyState !== 1) {
        log('❌ 未连接');
        updateStatus('disconnected', t('status_reconnect'));
        return;
      }
      
      // ✅ 立即设置标志和禁用按钮（双重保护），不等待任何异步操作
      isManualSyncing = true;
      syncBtn.disabled = true;
      syncBtn.textContent = t('btn_syncing');
      
      // 设置超时保护：如果 60 秒内没有收到响应，自动恢复按钮
      const syncTimeout = setTimeout(() => {
        if (isManualSyncing || syncBtn.disabled) {
          console.warn('⚠️  同步超时，自动恢复按钮状态');
          isManualSyncing = false;
          syncBtn.disabled = false;
          syncBtn.textContent = t('btn_sync_now');
          updateStatus('connected', t('status_sync_timeout'));
        }
      }, 60000);
      
      // 保存超时 ID，以便在收到响应时清除
      syncBtn.dataset.syncTimeout = syncTimeout;
      
      log('🫳🏻 开始同步...');
      updateStatus('connected', t('status_syncing'));
      manualDragCount = 0;
      skippedFilesSet.clear();
      gifBackupCount = 0;
      
      // 立即发送同步请求
      try {
        wsSend('manual-sync');
      } catch (error) {
        console.error('❌ 发送同步请求失败:', error);
        clearTimeout(syncTimeout);
        isManualSyncing = false; // 重置标志
        syncBtn.disabled = false;
        syncBtn.textContent = t('btn_sync_now');
        updateStatus('connected', t('status_request_fail'));
      }
    };

    document.getElementById('stopBtn').onclick = function() {
      stopRealtimeSync();
      // 不再显示模式选择，直接停留在当前界面
      log('⏸️  实时同步已停止');
      updateStatus('connected', t('status_stopped')); 
    }

    function stopRealtimeSync() {
      // 🛡️ 防止初始化未完成时崩溃
      try {
        // 无论当前模式是什么，只要 WebSocket 连接存在，就发送停止命令
        // 这样可以确保在关闭插件时，所有正在运行的监听都会被停止
        wsSend('stop-realtime');
        log('⏸️  已停止同步监听');
        
        // Update UI to Idle
        updateStartScreenUI('idle');
        updateStatus('connected', t('status_connected'));
      } catch (error) {
        console.error('❌ stopRealtimeSync 错误:', error);
      }
    }

    document.getElementById('locateFrameBtn').onclick = function () {
      postToPlugin('locate-frame');
    };

    document.getElementById('backBtn').onclick = function () { 
      // 不再返回模式选择，而是重新开始实时同步
      if (currentMode === 'realtime') {
      stopRealtimeSync();
        log('⏸️  实时同步已停止');
        updateStatus('connected', t('status_stopped'));
      } else {
        // 如果是手动模式，则重新开始实时模式
        showWorkArea('realtime');
      }
    };

    function setQRCodeImages() {
      const qrGoogleScreenshot = document.getElementById('qrGoogleScreenshot');
      const qrGoogleAlbum = document.getElementById('qrGoogleAlbum');
      const qrIcloudScreenshot = document.getElementById('qrIcloudScreenshot');
      const qrIcloudAlbum = document.getElementById('qrIcloudAlbum');
      
      const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const uris = getQRCodeURI(isDark);
      
      if (qrGoogleScreenshot) qrGoogleScreenshot.src = uris.googleScreenshot || uris.google;
      if (qrGoogleAlbum) qrGoogleAlbum.src = uris.googleAlbum || uris.google;
      if (qrIcloudScreenshot) qrIcloudScreenshot.src = uris.icloudScreenshot || uris.icloud;
      if (qrIcloudAlbum) qrIcloudAlbum.src = uris.icloudAlbum || uris.icloud;
    }

    // QR Code Zoom Functions
    function setupQRCodeZoom() {
      const qrImages = [
        { id: 'qrGoogleScreenshot', labelKey: 'mobile_direct_capture' },
        { id: 'qrGoogleAlbum', labelKey: 'mobile_from_album' },
        { id: 'qrIcloudScreenshot', labelKey: 'mobile_direct_capture' },
        { id: 'qrIcloudAlbum', labelKey: 'mobile_from_album' }
      ];

      qrImages.forEach(({ id, labelKey }) => {
        const img = document.getElementById(id);
        if (img) {
          img.classList.add('qr-clickable');
          img.onclick = () => openQRZoom(img.src, t(labelKey));
        }
      });

      // Click overlay to close
      const overlay = document.getElementById('qrZoomOverlay');
      if (overlay) {
        overlay.onclick = closeQRZoom;
      }
    }

    function openQRZoom(src, label) {
      const overlay = document.getElementById('qrZoomOverlay');
      const zoomImage = document.getElementById('qrZoomImage');
      const zoomLabel = document.getElementById('qrZoomLabel');

      if (overlay && zoomImage && zoomLabel) {
        zoomImage.src = src;
        zoomLabel.textContent = label;
        overlay.classList.add('show');
      }
    }

    function closeQRZoom() {
      const overlay = document.getElementById('qrZoomOverlay');
      if (overlay) {
        overlay.classList.remove('show');
      }
    }

    function setIdStepImages() {
      const idStep1Image = document.getElementById('idStep1Image');
      const idStep2Image = document.getElementById('idStep2Image');
      const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      
      if (idStep1Image) {
        idStep1Image.src = IMAGE_BASE_URL + (isDark ? 'id-step1-black.png' : 'id-step1-white.png');
      }
      if (idStep2Image) {
        idStep2Image.src = IMAGE_BASE_URL + (isDark ? 'id-step2-black.png' : 'id-step2-white.png');
      }
    }

    function updateIconColors() {
       const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
       // logo.svg is now inline SVG, no need to update src
       // kept for potential future use or other icons
    }

    function handleThemeChange() {
      setQRCodeImages();
      setIdStepImages();
      updateIconColors();
    }
    
    if (document.readyState === 'loading') {
      window.addEventListener('DOMContentLoaded', function() {
        handleThemeChange();
        setupQRCodeZoom();
      });
    } else {
      handleThemeChange();
      setupQRCodeZoom();
    }
    
    const themeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    themeMediaQuery.addEventListener('change', handleThemeChange);

    const viewUseCases = document.getElementById('viewUseCases'); // Legacy, may be null

    function updateQRCodeDisplay() {
      const qrGoogleScreenshotContainer = document.getElementById('qrGoogleScreenshotContainer');
      const qrGoogleAlbumContainer = document.getElementById('qrGoogleAlbumContainer');
      const qrIcloudScreenshotContainer = document.getElementById('qrIcloudScreenshotContainer');
      const qrIcloudAlbumContainer = document.getElementById('qrIcloudAlbumContainer');
      const googleDriveHint = document.getElementById('googleDriveHint');
      const qrCodesContainer = document.getElementById('qrCodesContainer');
      const userIdDisplaySection = document.getElementById('userIdDisplaySection');
      const noModeMessage = document.getElementById('noModeMessage');
      const qrSubtitle = document.getElementById('qrSubtitle');
      const shortcutGuideTitle = document.getElementById('shortcutGuideTitle');
      const userIdTitle = document.getElementById('userIdTitle');
      const userIdSubtitle = document.getElementById('userIdSubtitle');
      
      if (qrGoogleScreenshotContainer) qrGoogleScreenshotContainer.style.display = 'none';
      if (qrGoogleAlbumContainer) qrGoogleAlbumContainer.style.display = 'none';
      if (qrIcloudScreenshotContainer) qrIcloudScreenshotContainer.style.display = 'none';
      if (qrIcloudAlbumContainer) qrIcloudAlbumContainer.style.display = 'none';
      // if (googleDriveHint) googleDriveHint.style.display = 'none';
      if (userIdDisplaySection) userIdDisplaySection.style.display = 'none';
      if (noModeMessage) noModeMessage.style.display = 'none';
      if (qrSubtitle) qrSubtitle.style.display = 'none';
      if (qrCodesContainer) qrCodesContainer.style.display = 'none';
      if (userIdSubtitle) userIdSubtitle.style.display = 'none'; // Always hide original subtitles
      
      if (currentSyncMode === 'drive' && typeof ENABLE_GOOGLE_DRIVE !== 'undefined' && ENABLE_GOOGLE_DRIVE) {
        if (qrCodesContainer) qrCodesContainer.style.display = 'grid';
        if (qrGoogleScreenshotContainer) qrGoogleScreenshotContainer.style.display = 'flex';
        if (qrGoogleAlbumContainer) qrGoogleAlbumContainer.style.display = 'flex';
        
        if (userIdDisplaySection) userIdDisplaySection.style.display = 'block';
        
        // Google Mode Titles
        if (shortcutGuideTitle) shortcutGuideTitle.textContent = t('mobile_step1_alt');
        if (userIdTitle) userIdTitle.textContent = t('mobile_step2_alt');
        
      } else if (currentSyncMode === 'icloud') {
        if (qrCodesContainer) qrCodesContainer.style.display = 'grid';
        if (qrIcloudScreenshotContainer) qrIcloudScreenshotContainer.style.display = 'flex';
        if (qrIcloudAlbumContainer) qrIcloudAlbumContainer.style.display = 'flex';
        
        // iCloud Mode Titles
        if (shortcutGuideTitle) shortcutGuideTitle.textContent = t('mobile_step1_scan');
      } else {
        // No mode selected or unknown mode
        if (noModeMessage) noModeMessage.style.display = 'block';
      }
    }

    // Tab Switching Logic
    const tabDesktop = document.getElementById('tabDesktop');
    const tabMobile = document.getElementById('tabMobile');
    const contentDesktop = document.getElementById('contentDesktop');
    const contentMobile = document.getElementById('contentMobile');

    let currentTab = 'desktop';
    
    function switchTab(tab) {
        if (tab === currentTab) return; // 如果已经是当前tab，不执行切换
        
        const isGoingRight = (currentTab === 'desktop' && tab === 'mobile');
        const oldContent = currentTab === 'desktop' ? contentDesktop : contentMobile;
        const newContent = tab === 'desktop' ? contentDesktop : contentMobile;
        
        // 更新tab按钮状态
        if (tab === 'desktop') {
            tabDesktop.classList.add('active');
            tabMobile.classList.remove('active');
        } else {
            tabDesktop.classList.remove('active');
            tabMobile.classList.add('active');
        }
        
        // 旧内容滑出
        oldContent.classList.add(isGoingRight ? 'slide-out-left' : 'slide-out-right');
        oldContent.classList.remove('active');
        
        // 等待旧内容滑出后，显示新内容
        setTimeout(() => {
            oldContent.style.display = 'none';
            oldContent.classList.remove('slide-out-left', 'slide-out-right');
            
            // 显示新内容
            newContent.style.display = 'block';
            newContent.classList.add(isGoingRight ? 'slide-in-right' : 'slide-in-left');
            
            // 在动画结束后清理动画类
            setTimeout(() => {
                newContent.classList.remove('slide-in-left', 'slide-in-right');
                newContent.classList.add('active');
            }, 300);
        }, 150); // 滑出动画的一半时间，实现交叉淡入淡出
        
        currentTab = tab;
        
        // Trigger QR updates when mobile tab is active
        if (tab === 'mobile') {
      updateQRCodeDisplay();
      if (!currentSyncMode) {
          wsSend('get-sync-mode');
      }
      wsSend('get-user-id');
        }
    }

    if (tabDesktop) tabDesktop.onclick = function() { switchTab('desktop'); };
    if (tabMobile) tabMobile.onclick = function() { switchTab('mobile'); };

    function openSettings(defaultTab = 'desktop') {
      if (isMinimized) toggleMinimize();
      
      // Request info
      wsSend('get-sync-mode');
      wsSend('get-user-id');
      // 请求 GIF 备份设置
      wsSend('get-gif-backup-setting');
      // 请求备份截图设置 (新)
      wsSend('get-backup-screenshot-setting');
      wsSend('get-keep-gif-in-icloud-setting');
      postToPlugin('get-plugin-version');
      
      updateSyncModeDisplay();
      loadSizeSettings();
      loadLayoutSettings();
      
      // 初始化tab状态（无动画）
      currentTab = defaultTab;
      if (defaultTab === 'desktop') {
          tabDesktop.classList.add('active');
          tabMobile.classList.remove('active');
          contentDesktop.style.display = 'block';
          contentDesktop.classList.add('active');
          contentMobile.style.display = 'none';
          contentMobile.classList.remove('active');
      } else {
          tabDesktop.classList.remove('active');
          tabMobile.classList.add('active');
          contentDesktop.style.display = 'none';
          contentDesktop.classList.remove('active');
          contentMobile.style.display = 'block';
          contentMobile.classList.add('active');
          updateQRCodeDisplay();
      }
      
      settingsOverlay.classList.add('show');
    }

    if (viewUseCases) {
        viewUseCases.onclick = function() { openSettings('mobile'); };
    }

    // Update QRCode display check to look for mobile tab
    function checkQRCodeVisibility() {
        return settingsOverlay.classList.contains('show') && tabMobile.classList.contains('active');
      }

    const settingsOverlay = document.getElementById('settingsOverlay');
    const openSettingsBtn = document.getElementById('openSettings');
    const settingsClose = document.getElementById('settingsClose');
    const switchToDrive = document.getElementById('switchToDrive');
    const switchToAliyun = document.getElementById('switchToAliyun');
    const switchToIcloud = document.getElementById('switchToIcloud');
    
    if (typeof ENABLE_GOOGLE_DRIVE !== 'undefined' && !ENABLE_GOOGLE_DRIVE) {
      if (switchToDrive) switchToDrive.style.display = 'none';
      // Hide others handled in updateQRCodeDisplay
    }
    
    if (typeof ENABLE_ALIYUN !== 'undefined' && !ENABLE_ALIYUN) {
      if (switchToAliyun) switchToAliyun.style.display = 'none';
    }
    
    const imageWidthInput = document.getElementById('imageWidthInput');
    const imageHeightInput = document.getElementById('imageHeightInput');
    const saveSizeSettingsBtn = document.getElementById('saveSizeSettings');
    const clearSizeSettingsBtn = document.getElementById('clearSizeSettings');
    const frameColumnsInput = document.getElementById('frameColumnsInput');
    const saveLayoutSettingsBtn = document.getElementById('saveLayoutSettings');
    const clearLayoutSettingsBtn = document.getElementById('clearLayoutSettings');
    const backupModeSelect = document.getElementById('backupModeSelect');
    const backupSection = document.getElementById('backupSection');
    const gifAlgorithmSelect = document.getElementById('gifAlgorithmSelect');
    const toggleMinimizeBtn = document.getElementById('toggleMinimize');
    
    // 禁用输入框的鼠标滚轮调整数值功能
    [imageWidthInput, imageHeightInput, frameColumnsInput].forEach(input => {
      if (input) {
        input.addEventListener('wheel', function(e) {
          e.preventDefault();
        }, { passive: false });
      }
    });
    const minimizeIcon = document.getElementById('minimizeIcon');
    const appRoot = document.querySelector('.app');
    
    // Track saved values (for closeSettings reset)
    let originalSettings = {
      imageWidth: '',
      imageHeight: '',
      frameColumns: '',
      backupMode: 'none',
      gifAlgorithm: 'smooth_gradient'
    };
    
    // Auto-save debounce timers
    let _sizeSettingsTimer = null;
    let _layoutSettingsTimer = null;
    
    // Auto-save: size settings (debounced 600ms for text inputs)
    function autoSaveSizeSettings() {
      clearTimeout(_sizeSettingsTimer);
      _sizeSettingsTimer = setTimeout(() => {
        const width = imageWidthInput ? imageWidthInput.value.trim() : '';
        const height = imageHeightInput ? imageHeightInput.value.trim() : '';
        if (width && (isNaN(width) || parseInt(width) <= 0)) return;
        if (height && (isNaN(height) || parseInt(height) <= 0)) return;
        parent.postMessage({
          pluginMessage: {
            type: 'update-size-settings',
            width: width ? parseInt(width) : null,
            height: height ? parseInt(height) : null
          }
        }, '*');
        originalSettings.imageWidth = width;
        originalSettings.imageHeight = height;
      }, 600);
    }
    
    // Auto-save: layout settings (debounced 600ms for text inputs)
    function autoSaveLayoutSettings() {
      clearTimeout(_layoutSettingsTimer);
      _layoutSettingsTimer = setTimeout(() => {
        const columns = frameColumnsInput ? frameColumnsInput.value.trim() : '';
        if (columns && (isNaN(columns) || parseInt(columns) <= 0)) return;
        parent.postMessage({
          pluginMessage: {
            type: 'update-layout-settings',
            columns: columns ? parseInt(columns) : null
          }
        }, '*');
        originalSettings.frameColumns = columns;
      }, 600);
    }
    
    // Auto-save: backup mode (immediate on select change)
    function autoSaveBackupMode() {
      const backupMode = backupModeSelect ? backupModeSelect.value : 'none';
      wsSend('update-backup-screenshot-setting', { mode: backupMode });
      originalSettings.backupMode = backupMode;
    }
    
    // Auto-save: GIF algorithm (immediate on select change)
    function autoSaveGifAlgorithm() {
      const gifAlgorithm = gifAlgorithmSelect ? gifAlgorithmSelect.value : 'smooth_gradient';
      window.gifAlgorithmSetting = gifAlgorithm;
      postToPlugin('set-gif-algorithm', { algorithm: gifAlgorithm });
      originalSettings.gifAlgorithm = gifAlgorithm;
    }
    
    // Add event listeners to inputs (auto-save on change)
    if (imageWidthInput) imageWidthInput.addEventListener('input', autoSaveSizeSettings);
    if (imageHeightInput) imageHeightInput.addEventListener('input', autoSaveSizeSettings);
    if (frameColumnsInput) frameColumnsInput.addEventListener('input', autoSaveLayoutSettings);
    // 动态调整 select 宽度以适应当前选项文字
    function adjustSelectWidth(selectEl) {
      if (!selectEl) return;
      
      // 创建临时 span 测量文字宽度
      const tempSpan = document.createElement('span');
      tempSpan.style.visibility = 'hidden';
      tempSpan.style.position = 'absolute';
      tempSpan.style.whiteSpace = 'nowrap';
      tempSpan.style.fontSize = getComputedStyle(selectEl).fontSize;
      tempSpan.style.fontFamily = getComputedStyle(selectEl).fontFamily;
      tempSpan.textContent = selectEl.options[selectEl.selectedIndex].text;
      document.body.appendChild(tempSpan);
      
      // 设置宽度：文字宽度 + padding (10px 左 + 28px 右给箭头) + 边框
      const textWidth = tempSpan.offsetWidth;
      selectEl.style.width = (textWidth + 42) + 'px';
      
      document.body.removeChild(tempSpan);
    }

    if (backupModeSelect) {
      backupModeSelect.addEventListener('change', function() {
        autoSaveBackupMode();
        adjustSelectWidth(this);
        this.blur();
      });
      adjustSelectWidth(backupModeSelect);
    }
    
    if (gifAlgorithmSelect) {
      // 请求从 Figma clientStorage 加载保存的设置
      postToPlugin('get-gif-algorithm');
      
      gifAlgorithmSelect.addEventListener('change', function() {
        autoSaveGifAlgorithm();
        adjustSelectWidth(this);
        this.blur();
      });
      adjustSelectWidth(gifAlgorithmSelect);
    }
    
    // Language select handler
    const languageSelect = document.getElementById('languageSelect');
    if (languageSelect) {
      languageSelect.value = currentLang;
      updateLangFlag(currentLang);
      languageSelect.addEventListener('change', function() {
        currentLang = this.value;
        updateLangFlag(currentLang);
        postToPlugin('set-language', { language: currentLang });
        applyLanguage();
        this.blur();
      });
    }
    
    function loadSizeSettings() {
      postToPlugin('get-size-settings');
    }
    
    // (Save button removed — all settings auto-save on change)
    
    function loadLayoutSettings() {
      postToPlugin('get-layout-settings');
    }
    
    function loadServerPath() {
      postToPlugin('get-server-path');
    }
    
    openSettingsBtn.onclick = function() {
      openSettings('desktop');
    };
    
    const openFolderBtn = document.getElementById('openFolder');
    if (openFolderBtn) {
      openFolderBtn.onclick = function() {
        if (wsSend('open-local-folder')) {
          // 打开 ScreenSyncImg 根文件夹（不指定子文件夹）
          log('📂 已请求打开文件夹');
        } else {
          log('⚠️ 未连接到服务器');
        }
      };
    }
    
    // 全局变量：跟踪待更新的类型
    let pendingUpdateType = null; // 'plugin' or 'server'
    let pendingUpdateData = {};
    
    // 处理插件更新信息
    function handlePluginUpdateInfo(data) {
      latestPluginVersion = data.latestVersion;
      pluginUpdateUrl = data.updateUrl;
      
      // 如果还没有收到真实的插件版本信息，暂存更新信息，等待版本信息到达后再处理
      if (currentPluginVersion === null) {
        pendingPluginUpdateInfo = data;
        return;
      }
      
      // 比较版本号
      if (data.hasUpdate && compareVersions(latestPluginVersion, currentPluginVersion) > 0) {
        // 检查是否是用户已经点击"稍后"忽略的版本
        const shouldShow = !dismissedPluginVersion || compareVersions(latestPluginVersion, dismissedPluginVersion) > 0;
        
        if (shouldShow) {
          // 有新版本，且不是用户已忽略的版本，显示顶部通知条
          pendingUpdateType = 'plugin';
          pendingUpdateData = data;
          showUpdateBanner('plugin', currentPluginVersion, latestPluginVersion);
        }
      }
    }
    
    // 处理服务器更新信息
    function handleServerUpdateInfo(data) {
      if (data.hasUpdate) {
        // 首先检查是否已经安装了这个版本（从 localStorage）
        if (installedServerVersion && compareVersions(data.latestVersion, installedServerVersion) <= 0) {
          return;
        }
        
        // 检查是否是用户已经点击"稍后"忽略的版本
        const shouldShow = !dismissedServerVersion || compareVersions(data.latestVersion, dismissedServerVersion) > 0;
        
        if (shouldShow) {
          // 如果已经有插件更新待处理，服务器更新优先
            pendingUpdateType = 'server';
          pendingUpdateData = data;
          showUpdateBanner('server', data.currentVersion, data.latestVersion);
        }
      }
    }
    
    // 显示顶部更新通知条（统一显示，不区分插件/服务器）
    function showUpdateBanner(componentName, currentVer, latestVer) {
      const banner = document.getElementById('updateBanner');
      const text = document.getElementById('updateBannerText');
      
      if (banner && text) {
        // 统一显示为"发现新版本 v版本号"
        text.textContent = t('banner_new_version', latestVer);
        banner.classList.add('show');
        
        // 如果当前未最小化，调整窗口高度以适应 Banner
        if (typeof isMinimized !== 'undefined' && !isMinimized) {
          parent.postMessage({
            pluginMessage: { type: 'resize', width: 360, height: 460 }
          }, '*');
        }
      }
    }
    
    // 隐藏顶部更新通知条
    function hideUpdateBanner() {
      const banner = document.getElementById('updateBanner');
      if (banner) {
        banner.classList.remove('show');
        // 确保样式被重置（配合最小化逻辑）
        banner.style.display = '';
        
        // 如果当前未最小化，恢复窗口高度
        if (typeof isMinimized !== 'undefined' && !isMinimized) {
          parent.postMessage({
            pluginMessage: { type: 'resize', width: 360, height: 400 }
          }, '*');
        }
      }
    }
    
    // 处理插件版本信息
    function handlePluginVersionInfo(data) {
      currentPluginVersion = data.version || '1.0.0';
      
      // 如果有暂存的更新信息，现在可以处理了
      if (pendingPluginUpdateInfo) {
        const tempData = pendingPluginUpdateInfo;
        pendingPluginUpdateInfo = null;
        handlePluginUpdateInfo(tempData);
      }
    }
    
    // 比较版本号（简单版本，支持 x.y.z 格式）
    function compareVersions(v1, v2) {
      const parts1 = v1.split('.').map(Number);
      const parts2 = v2.split('.').map(Number);
      const maxLength = Math.max(parts1.length, parts2.length);
      
      for (let i = 0; i < maxLength; i++) {
        const part1 = parts1[i] || 0;
        const part2 = parts2[i] || 0;
        if (part1 > part2) return 1;
        if (part1 < part2) return -1;
      }
      return 0;
    }
    
    // 处理统一更新进度（插件 + 服务器）
    function handleUpdateProgress(data) {
      const bannerBtn = document.getElementById('updateBannerNow');
      
      if (data.status === 'downloading') {
        // 只更新按钮文字，不显示 toast
        if (bannerBtn) {
          bannerBtn.disabled = true;
          // 保持按钮样式，不添加 transparent 类
          // bannerBtn.classList.add('transparent'); // 已移除
          bannerBtn.textContent = data.progress ? t('banner_downloading') + ' ' + data.progress + '%' : t('banner_downloading') + '...';
      }
      } else if (data.status === 'extracting' || data.status === 'checking' || data.status === 'installing') {
        // 合并中间状态为“正在安装”
        if (bannerBtn) {
          // bannerBtn.classList.add('transparent'); // 已移除
          bannerBtn.textContent = t('banner_installing');
        }
      } else if (data.status === 'completed') {
        const successMsg = data.message || t('banner_update_done');
        showToast(successMsg, 'success');
        
        // 更新按钮状态为“更新完成”
        if (bannerBtn) {
          bannerBtn.textContent = t('banner_update_done');
          bannerBtn.classList.add('success');
          
          // 成功状态：绿色描边风格
          bannerBtn.style.background = 'transparent';
          bannerBtn.style.color = 'var(--success)'; 
          bannerBtn.style.borderColor = 'var(--success)';
          bannerBtn.style.opacity = '1';
        }
        
        // 保存当前版本号到 localStorage，防止 banner 再次弹出
        if (data.latestVersion) {
          installedServerVersion = data.latestVersion.replace(/^v/, '');
          try {
            localStorage.setItem('currentServerVersion', installedServerVersion);
          } catch (error) {
          }
        }
        
        // 隐藏更新通知条 (延迟一点以便用户看到“更新完成”)
        setTimeout(() => {
          hideUpdateBanner();
        }, 1500);
        
        // 更新版本（如果提供）
        if (data.version) {
          currentPluginVersion = data.version.replace(/^v/, '');
          }
        
        // 清除待更新标记和忽略记录
        pendingUpdateType = null;
        pendingUpdateData = {};
        dismissedPluginVersion = null;
        dismissedServerVersion = null;
        
        // 3秒后提示用户重启插件
        setTimeout(() => {
          showToast(t('toast_update_done_restart'), 'success');
        }, 3000);
        
      } else if (data.status === 'error') {
        showToast(data.message || t('toast_update_fail'), 'error');
        // 重置按钮状态，但保持 banner 主文字不变
        if (bannerBtn) {
          bannerBtn.disabled = false;
          // bannerBtn.classList.remove('transparent'); // 已移除添加逻辑
          bannerBtn.textContent = t('banner_update_now');
          // 恢复样式
          bannerBtn.classList.remove('success');
          bannerBtn.style.background = '';
          bannerBtn.style.color = '';
          bannerBtn.style.borderColor = '';
          bannerBtn.style.opacity = '';
        }
      }
    }
    
    // 保留旧函数名作为别名（兼容性）
    function handlePluginUpdateProgress(data) {
      handleUpdateProgress(data);
    }
    
    function handleServerUpdateProgress(data) {
      handleUpdateProgress(data);
    }

    // SVG Icons for Toast
    function getToastIcon(type) {
      if (type === 'success') {
        return '<svg viewBox="0 0 24 24" fill="none"><circle cx="12" cy="12" r="10" fill="currentColor"/><path d="M16.5 9.5l-5.5 5.5-3-3" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
      } else if (type === 'error') {
        return '<svg viewBox="0 0 24 24" fill="none"><circle cx="12" cy="12" r="10" fill="currentColor"/><path d="M12 8v5M12 16.5v.5" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
      } else if (type === 'loading') {
        return '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" style="animation: spin 1s linear infinite;"><circle cx="12" cy="12" r="10" stroke-dasharray="31.416" stroke-dashoffset="7.854" opacity="0.3"></circle><circle cx="12" cy="12" r="10" stroke-dasharray="31.416" stroke-dashoffset="23.562"></circle></svg>';
      } else if (type === 'info') {
        return '<svg viewBox="0 0 24 24" fill="none"><circle cx="12" cy="12" r="10" fill="currentColor"/><circle cx="12" cy="7.5" r="1.5" fill="white"/><path d="M12 11.5v5.5" stroke="white" stroke-width="2.5" stroke-linecap="round"/></svg>';
      } else if (type === 'warning') {
        return '<svg viewBox="0 0 24 24" fill="none"><circle cx="12" cy="12" r="10" fill="currentColor"/><path d="M12 8v5M12 16.5v.5" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
      }
      return '';
    }
    
    // Add spin animation for loading icon
    const style = document.createElement('style');
    style.textContent = '@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }';
    document.head.appendChild(style);
    
    // ✅ Toast 管理：防止高频弹出和重复显示
    let toastTimer = null; // 当前 toast 的隐藏定时器
    let lastToastMessage = ''; // 上一次显示的 toast 内容
    let lastToastTime = 0; // 上一次显示 toast 的时间
    const TOAST_DEBOUNCE_TIME = 500; // 去重时间窗口（毫秒）
    
    function showToast(message, type = 'info') {
      // 🛡️ 防止初始化未完成时崩溃
      try {
        // 最小化状态下不显示 toast
        if (isMinimized) return;
        
        const toast = document.getElementById('toast');
        if (!toast) return;
      
      const iconEl = toast.querySelector('.toast-icon');
      const messageEl = toast.querySelector('.toast-message');
      
      if (!iconEl || !messageEl) return;
      
      // Remove emoji and trailing ellipsis from message
      let cleanMessage = message
        .replace(/✅|❌|⏳|⚠️|📸|📍/g, '')
        .replace(/\.\.\./g, '')
        .trim();
      
      // ✅ 去重：如果在短时间内显示相同内容的 toast，则忽略
      const now = Date.now();
      if (cleanMessage === lastToastMessage && (now - lastToastTime) < TOAST_DEBOUNCE_TIME) {
        return;
      }
      
      // ✅ 清除旧的定时器，避免冲突
      if (toastTimer) {
        clearTimeout(toastTimer);
        toastTimer = null;
      }
      
      // 更新记录
      lastToastMessage = cleanMessage;
      lastToastTime = now;
      
      // ✅ 如果当前有显示的 toast，先立即隐藏
      if (toast.classList.contains('show')) {
        toast.classList.remove('show');
        // 等待淡出动画完成后再显示新的
        setTimeout(() => {
          displayToast(toast, iconEl, messageEl, cleanMessage, type);
        }, 300);
      } else {
        displayToast(toast, iconEl, messageEl, cleanMessage, type);
      }
      } catch (error) {
        console.error('❌ showToast 错误:', error);
      }
    }
    
    // ✅ 实际显示 toast 的函数（内部使用）
    function displayToast(toast, iconEl, messageEl, cleanMessage, type) {
      // Set icon
      if (type === 'success' || type === 'error' || type === 'loading' || type === 'info' || type === 'warning') {
        iconEl.innerHTML = getToastIcon(type);
        iconEl.style.display = 'flex';
      } else {
        iconEl.innerHTML = '';
        iconEl.style.display = 'none';
      }
      
      // Set message
      messageEl.textContent = cleanMessage;
      messageEl.innerHTML = cleanMessage; // Allow HTML content
      
      // Set toast class
      toast.className = 'toast';
      if (type === 'success') {
        toast.classList.add('success');
      } else if (type === 'error') {
        toast.classList.add('error');
      } else if (type === 'loading') {
        toast.classList.add('loading');
      } else if (type === 'info') {
        toast.classList.add('info');
      } else if (type === 'warning') {
        toast.classList.add('warning');
      }
      
      // Show toast
      setTimeout(() => {
        toast.classList.add('show');
      }, 10);
      
      // Hide toast after 2 seconds
      toastTimer = setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
          iconEl.innerHTML = '';
          messageEl.textContent = '';
          toastTimer = null;
        }, 300);
      }, 2000);
    }

    function showToastWithAction(message, actionText, actionCallback) {
      // 最小化状态下不显示 toast
      if (isMinimized) return;
      
      const toast = document.getElementById('toast');
      if (!toast) return;
      
      const iconEl = toast.querySelector('.toast-icon');
      const messageEl = toast.querySelector('.toast-message');
      
      if (!iconEl || !messageEl) return;
      
      // Validate parameters
      if (!message || !actionText) {
        console.error('showToastWithAction: message or actionText is missing');
        return;
      }
      
      // ✅ 清除旧的定时器，避免冲突
      if (toastTimer) {
        clearTimeout(toastTimer);
        toastTimer = null;
      }
      
      // ✅ 如果当前有显示的 toast，先立即隐藏
      if (toast.classList.contains('show')) {
        toast.classList.remove('show');
        setTimeout(() => {
          displayToastWithAction(toast, iconEl, messageEl, message, actionText, actionCallback);
        }, 300);
      } else {
        displayToastWithAction(toast, iconEl, messageEl, message, actionText, actionCallback);
      }
    }
    
    // ✅ 实际显示带操作的 toast 的函数（内部使用）
    function displayToastWithAction(toast, iconEl, messageEl, message, actionText, actionCallback) {
      // Set success icon
      iconEl.innerHTML = getToastIcon('success');
      iconEl.style.display = 'flex';
      
      // Create message with action link
      messageEl.innerHTML = `${message} <span class="toast-action">${actionText}</span>`;
      
      // Add click handler to action link
      const actionLink = messageEl.querySelector('.toast-action');
      if (actionLink && actionCallback) {
        actionLink.onclick = (e) => {
          e.stopPropagation();
          actionCallback();
        };
      }
      
      // Set toast class
      toast.className = 'toast success';
      
      // Show toast
      setTimeout(() => {
        toast.classList.add('show');
      }, 10);
      
      // Hide toast after 3 seconds (longer for action)
      toastTimer = setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
          iconEl.innerHTML = '';
          messageEl.innerHTML = '';
          toastTimer = null;
        }, 300);
      }, 3000);
    }

    function closeSettings() {
      // All settings are auto-saved, just close the overlay
      settingsOverlay.classList.remove('show');
    }

    function updateSyncModeDisplay() {
      const driveBtn = document.getElementById('switchToDrive');
      const aliyunBtn = document.getElementById('switchToAliyun');
      const icloudBtn = document.getElementById('switchToIcloud');
      
      if (driveBtn) driveBtn.style.display = (typeof ENABLE_GOOGLE_DRIVE !== 'undefined' && ENABLE_GOOGLE_DRIVE) ? 'flex' : 'none';
      
      const showGoogleDrive = (currentSyncMode === 'drive' && typeof ENABLE_GOOGLE_DRIVE !== 'undefined' && ENABLE_GOOGLE_DRIVE);
      const qrGoogleScreenshotContainer = document.getElementById('qrGoogleScreenshotContainer');
      const qrGoogleAlbumContainer = document.getElementById('qrGoogleAlbumContainer');
      const googleDriveHint = document.getElementById('googleDriveHint');

      if (qrGoogleScreenshotContainer) qrGoogleScreenshotContainer.style.display = showGoogleDrive ? 'flex' : 'none';
      if (qrGoogleAlbumContainer) qrGoogleAlbumContainer.style.display = showGoogleDrive ? 'flex' : 'none';
      // if (googleDriveHint) googleDriveHint.style.display = showGoogleDrive ? 'block' : 'none';
      
      if (aliyunBtn) aliyunBtn.style.display = (typeof ENABLE_ALIYUN !== 'undefined' && ENABLE_ALIYUN) ? 'flex' : 'none';
      
      // Use box-shadow for selected state instead of border color for better visibility on cards
      if (driveBtn) {
          driveBtn.style.borderColor = (currentSyncMode === 'drive') ? 'var(--accent)' : 'var(--border)';
          driveBtn.style.background = (currentSyncMode === 'drive') ? 'var(--bg-card-hover)' : 'var(--bg-card)';
          if (currentSyncMode === 'drive') driveBtn.classList.add('selected');
          else driveBtn.classList.remove('selected');
      }
      if (aliyunBtn) {
          aliyunBtn.style.borderColor = (currentSyncMode === 'aliyun' || currentSyncMode === 'oss') ? 'var(--accent)' : 'var(--border)';
          aliyunBtn.style.background = (currentSyncMode === 'aliyun' || currentSyncMode === 'oss') ? 'var(--bg-card-hover)' : 'var(--bg-card)';
          if (currentSyncMode === 'aliyun' || currentSyncMode === 'oss') aliyunBtn.classList.add('selected');
          else aliyunBtn.classList.remove('selected');
      }
      if (icloudBtn) {
          icloudBtn.style.borderColor = (currentSyncMode === 'icloud') ? 'var(--accent)' : 'var(--border)';
          icloudBtn.style.background = (currentSyncMode === 'icloud') ? 'var(--bg-card-hover)' : 'var(--bg-card)';
          if (currentSyncMode === 'icloud') icloudBtn.classList.add('selected');
          else icloudBtn.classList.remove('selected');
      }
    }

    settingsClose.onclick = closeSettings;
    settingsOverlay.addEventListener('click', function (e) {
      if (e.target === settingsOverlay) closeSettings();
    });
    document.addEventListener('keydown', function (e) {
      if (e.key === 'Escape' && settingsOverlay.classList.contains('show')) {
        closeSettings();
      }
    });

    if (switchToDrive) {
      switchToDrive.onclick = function () {
        if (!ENABLE_GOOGLE_DRIVE) return;
        if (currentSyncMode === 'drive') return;
        
        showToast(t('toast_switching'), 'loading');
        wsSend('switch-sync-mode', { mode: 'drive' });
      };
    }

    if (switchToAliyun) {
      switchToAliyun.onclick = function () {
        if (typeof ENABLE_ALIYUN !== 'undefined' && !ENABLE_ALIYUN) return;
        if (currentSyncMode === 'aliyun') return;

        showToast(t('toast_switching'), 'loading');
        wsSend('switch-sync-mode', { mode: 'aliyun' });
      };
    }

    switchToIcloud.onclick = function () {
      if (currentSyncMode === 'icloud') return;
      showToast(t('toast_switching'), 'loading');
      wsSend('switch-sync-mode', { mode: 'icloud' });
    };

    function toggleMinimize() {
      isMinimized = !isMinimized;
      const currentIcon = document.getElementById('minimizeIcon');
      const updateBanner = document.getElementById('updateBanner');
      
      if (!currentIcon) return;
      
      if (isMinimized) {
        appRoot.classList.add('minimized');
        closeSettings(); // Use closeSettings to discard unsaved changes
        
        // 最小化时隐藏更新横幅
        // 检查 classList.contains('show') 因为这是主要的显示状态
        if (updateBanner && (updateBanner.classList.contains('show') || updateBanner.style.display === 'flex' || updateBanner.style.display === 'block')) {
          updateBanner.dataset.wasVisible = 'true';
          updateBanner.style.display = 'none';
        }
        
        // 最小化时隐藏所有 toast 提示
        const toast = document.getElementById('toast');
        if (toast) {
          toast.classList.remove('show');
          // 清除 toast 定时器
          if (toastTimer) {
            clearTimeout(toastTimer);
            toastTimer = null;
          }
          // 清空内容
          const iconEl = toast.querySelector('.toast-icon');
          const messageEl = toast.querySelector('.toast-message');
          if (iconEl) iconEl.innerHTML = '';
          if (messageEl) messageEl.innerHTML = '';
        }
        
        // Toggle icon path to Maximize (No slash)
        toggleMinimizeBtn.setAttribute('title', t('tooltip_restore'));
        toggleMinimizeBtn.classList.add('no-tooltip'); // 禁用最大化按钮的 tooltip
        currentIcon.innerHTML = '<polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline>';
        
        parent.postMessage({
          pluginMessage: { type: 'resize', width: 130, height: 44 }
        }, '*');
      } else {
        appRoot.classList.remove('minimized');
        
        let isBannerVisible = false;
        // 恢复时显示更新横幅
        if (updateBanner && updateBanner.dataset.wasVisible === 'true') {
          updateBanner.style.display = ''; // 清除内联样式，让 CSS .show 生效
          delete updateBanner.dataset.wasVisible;
          isBannerVisible = true;
        } else if (updateBanner && updateBanner.classList.contains('show')) {
          // 如果没有 wasVisible 标记但有 .show 类（可能是逻辑边缘情况），也认为是显示的
          isBannerVisible = true;
        }
        
        // Toggle icon path to Minimize
        toggleMinimizeBtn.setAttribute('title', t('tooltip_minimize'));
        toggleMinimizeBtn.classList.remove('no-tooltip'); // 恢复最小化按钮的 tooltip
        currentIcon.innerHTML = '<polyline points="4 14 10 14 10 20"></polyline><polyline points="20 10 14 10 14 4"></polyline>';
        
        // 根据是否有 Banner 调整窗口高度
        const height = isBannerVisible ? 460 : 400;
        parent.postMessage({
          pluginMessage: { type: 'resize', width: 360, height: height }
        }, '*');
      }
    }

    toggleMinimizeBtn.onclick = toggleMinimize;
    
    // 更新通知条按钮事件
    const updateBannerCloseBtn = document.getElementById('updateBannerClose');
    const updateBannerNowBtn = document.getElementById('updateBannerNow');
    
    if (updateBannerCloseBtn) {
      updateBannerCloseBtn.onclick = function() {
        // 记录用户忽略的版本，避免重复提示同一版本
        if (pendingUpdateType === 'plugin' && latestPluginVersion) {
          dismissedPluginVersion = latestPluginVersion;
        } else if (pendingUpdateType === 'server' && pendingUpdateData.latestVersion) {
          dismissedServerVersion = pendingUpdateData.latestVersion;
        }
        
        hideUpdateBanner();
      };
    }
    
    if (updateBannerNowBtn) {
      updateBannerNowBtn.onclick = function() {
        // 禁用按钮防止重复点击
        updateBannerNowBtn.disabled = true;
        updateBannerNowBtn.textContent = t('banner_updating');
        
        // 发送更新请求到服务器
        if (!wsSend('update-full')) {
          // WebSocket 未连接，显示错误
          showToast(t('toast_server_offline'), 'error');
          updateBannerNowBtn.disabled = false;
          updateBannerNowBtn.textContent = t('banner_update_now');
        }
      };
    }

    // ========================================
    // Upload GIF Modal Logic
    // ========================================
    let pendingUnsyncedGifs = []; // 待上传的 GIF 列表
    let selectedFiles = {}; // 用户选择的文件 { layerId: File }
    let uploadedGifs = new Set(); // 已上传成功的 layerId
    let pendingAssociations = new Set(); // 等待 Figma 确认关联的 layerId
    let associationResolvers = {}; // { layerId: resolve } 用于 Promise 回调
    
    function showUploadGifModal(unsyncedGifs) {
      pendingUnsyncedGifs = unsyncedGifs;
      selectedFiles = {};
      uploadedGifs = new Set(); // 重置已上传列表
      
      const overlay = document.getElementById('uploadGifOverlay');
      const subtitleContainer = document.getElementById('unsynced-gifs-subtitle');
      const multiFileInput = document.getElementById('multi-file-input');
      const dropzone = document.getElementById('upload-dropzone');
      const dropzoneText = document.getElementById('dropzone-text');
      const progressContainer = document.getElementById('upload-progress-container');
      const progressBar = document.getElementById('upload-progress-bar');
      
      // 重置进度条和拖拽区域
      if (progressContainer) progressContainer.style.display = 'none';
      if (progressBar) progressBar.style.width = '0%';
      if (dropzone) dropzone.style.display = 'flex'; // 确保拖拽区域可见
      
      // 填充副标题：显示需要上传的文件数量
      const totalRequired = unsyncedGifs.length;
      subtitleContainer.innerHTML = tPlural('upload_needed', totalRequired);
      
      // 重置拖拽区域状态
      resetDropzoneStyle();
      
      // 点击拖拽区域 -> 打开文件选择器
      dropzone.onclick = () => {
        multiFileInput.click();
      };
      
      // 拖拽进入
      dropzone.ondragenter = (e) => {
        e.preventDefault();
        e.stopPropagation();
        dropzone.style.border = '2px dashed var(--primary)';
        dropzone.style.background = 'rgba(33, 150, 243, 0.08)';
        dropzone.style.boxShadow = 'none';
      };
      
      // 拖拽悬停
      dropzone.ondragover = (e) => {
        e.preventDefault();
        e.stopPropagation();
        // 保持悬停状态样式
        dropzone.style.border = '2px dashed var(--primary)';
        dropzone.style.background = 'rgba(33, 150, 243, 0.08)';
      };
      
      // 拖拽离开
      dropzone.ondragleave = (e) => {
        e.preventDefault();
        e.stopPropagation();
        resetDropzoneStyle();
      };
      
      // 拖拽放下
      dropzone.ondrop = async (e) => {
        e.preventDefault();
        e.stopPropagation();
        resetDropzoneStyle();
        
        const files = Array.from(e.dataTransfer.files).filter(file => {
          const ext = file.name.toLowerCase().split('.').pop();
          return ['gif', 'mov', 'mp4'].includes(ext);
        });
        
        if (files.length === 0) {
          showToast(t('toast_format_unsupported'), 'warning');
          return;
        }
        
        await matchAndUploadFiles(files, unsyncedGifs);
      };
      
      // 重置拖拽区域样式（Liquid Glass 虚线边框）
      function resetDropzoneStyle() {
        dropzone.style.border = '2px dashed var(--glass-border)';
        dropzone.style.background = 'transparent';
        dropzone.style.boxShadow = 'none';
      }
      
      // 选择文件后立即开始上传
      multiFileInput.onchange = async (e) => {
        const files = Array.from(e.target.files);
        if (files.length === 0) return;
        
        
        // 自动匹配并立即上传
        await matchAndUploadFiles(files, unsyncedGifs);
      };
      
      // 绑定关闭按钮
      const closeBtn = document.getElementById('uploadGifClose');
      if (closeBtn) {
        closeBtn.onclick = () => {
          overlay.classList.remove('show');
          overlay.classList.add('hidden');
          setTimeout(() => {
            overlay.style.display = 'none';
          }, 250);
          pendingUnsyncedGifs = [];
          selectedFiles = {};
          uploadedGifs = new Set();
        };
      }
      
      // 显示模态框
      overlay.style.display = 'flex';
      overlay.classList.add('show');
      overlay.classList.remove('hidden');
    }
    
    // 匹配并自动上传文件（支持分批上传）
    async function matchAndUploadFiles(files, unsyncedGifs) {
      const progressContainer = document.getElementById('upload-progress-container');
      const progressText = document.getElementById('upload-progress-text');
      const progressBar = document.getElementById('upload-progress-bar');
      const dropzone = document.getElementById('upload-dropzone');
      const subtitleContainer = document.getElementById('unsynced-gifs-subtitle');
      
      // 总需要上传的 GIF 数量
      const totalRequired = unsyncedGifs.length;
      
      // 过滤出还未上传的 GIF
      const remainingGifs = unsyncedGifs.filter(gif => !uploadedGifs.has(gif.layerId));
      
      // 显示进度，隐藏拖拽区域
      if (dropzone) dropzone.style.display = 'none';
      if (progressContainer) progressContainer.style.display = 'block';
      
      // 计算当前已上传的进度
      const alreadyUploaded = uploadedGifs.size;
      const initialPercent = Math.round((alreadyUploaded / totalRequired) * 100);
      
      if (progressBar) {
        progressBar.style.width = '0%';
        progressBar.offsetHeight;
        progressBar.style.width = `${Math.max(5, initialPercent)}%`;
      }
      if (progressText) progressText.textContent = t('upload_progress', alreadyUploaded, totalRequired);
      
      try {
        // 匹配文件到图层（只匹配还未上传的）
        const currentSelectedFiles = {};
        
        // 过滤出有效的视频/GIF 文件
        const validFiles = files.filter(f => /\.(gif|mov|mp4)$/i.test(f.name));
        
        // 统一使用文件名匹配逻辑（单个 GIF 和多个 GIF 均需匹配）
        remainingGifs.forEach(gif => {
          const layerName = gif.layerName;
          const originalFilename = gif.filename || gif.layerName;
          
          const matchedFile = validFiles.find(file => {
            const fileName = file.name.replace(/\.(gif|mov|mp4)$/i, '');
            
            const layerNameClean = layerName.replace(/\.(gif|mov|mp4)$/i, '').replace(/\s+/g, '-').toLowerCase();
            const originalFilenameClean = originalFilename.replace(/\.(gif|mov|mp4)$/i, '').replace(/\s+/g, '-').toLowerCase();
            const fileNameClean = fileName.replace(/\s+/g, '-').toLowerCase();
            
            // 1. 精确匹配
            if (fileNameClean === originalFilenameClean || fileNameClean === layerNameClean) return true;
            
            // 2. 包含匹配
            if (fileNameClean.includes(originalFilenameClean) || originalFilenameClean.includes(fileNameClean)) return true;
            if (fileNameClean.includes(layerNameClean) || layerNameClean.includes(fileNameClean)) return true;
            
            // 3. 宽松匹配
            const originalSimple = originalFilenameClean.replace(/[^a-z0-9]/g, '');
            const layerSimple = layerNameClean.replace(/[^a-z0-9]/g, '');
            const fileSimple = fileNameClean.replace(/[^a-z0-9]/g, '');
            
            if (originalSimple && fileSimple && originalSimple.length > 2 && 
                (originalSimple === fileSimple || fileSimple.includes(originalSimple) || originalSimple.includes(fileSimple))) {
              return true;
            }
            
            if (layerSimple && fileSimple && layerSimple.length > 2 && 
                (layerSimple === fileSimple || fileSimple.includes(layerSimple) || layerSimple.includes(fileSimple))) {
              return true;
            }
            
            return false;
          });
          
          if (matchedFile) {
            currentSelectedFiles[gif.layerId] = matchedFile;
          }
        });
        
        const matchedGifs = remainingGifs.filter(gif => currentSelectedFiles[gif.layerId]);
        const totalToUploadNow = matchedGifs.length;
        
        if (totalToUploadNow === 0) {
          // 没有匹配到任何文件
          showToast(t('toast_file_mismatch'), 'warning');
          // 恢复拖拽区域，让用户继续上传
          if (dropzone) dropzone.style.display = 'flex';
          if (progressContainer) progressContainer.style.display = 'none';
          // 更新副标题显示进度
          updateUploadSubtitle(subtitleContainer, unsyncedGifs);
          return;
        }
        
        
        // 开始上传本次匹配的文件
        for (let i = 0; i < totalToUploadNow; i++) {
          const gif = matchedGifs[i];
          const file = currentSelectedFiles[gif.layerId];
          
          // 计算总进度：已上传 + 本次正在上传
          const currentUploaded = uploadedGifs.size + i + 1;
          const percent = Math.round((currentUploaded / totalRequired) * 100);
          if (progressBar) progressBar.style.width = `${percent}%`;
          if (progressText) progressText.textContent = t('upload_progress', currentUploaded, totalRequired);
          
          // 读取文件内容为 Base64
          const base64Data = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result.split(',')[1]);
            reader.onerror = reject;
            reader.readAsDataURL(file);
          });
          
          // 发送上传请求
          const uploadResult = await uploadGifToCloud(file.name, base64Data, gif.layerId);
          
          if (uploadResult.success) {
            uploadedGifs.add(gif.layerId);
            
            // 创建 Promise 等待 Figma 确认关联
            const associationPromise = new Promise((resolve) => {
              pendingAssociations.add(gif.layerId);
              associationResolvers[gif.layerId] = resolve;
              // 超时保护：5秒后自动解析
              setTimeout(() => {
                if (associationResolvers[gif.layerId]) {
                  console.warn(`   ⚠️  关联确认超时: ${gif.layerId}`);
                  pendingAssociations.delete(gif.layerId);
                  resolve(false);
                  delete associationResolvers[gif.layerId];
                }
              }, 5000);
            });
            
            parent.postMessage({
              pluginMessage: {
                type: 'associate-uploaded-gif',
                layerId: gif.layerId,
                driveFileId: uploadResult.driveFileId,
                ossFileId: uploadResult.ossFileId,
                originalFilename: uploadResult.originalFilename || file.name,
                imageHash: uploadResult.imageHash,
                gifCacheId: uploadResult.gifCacheId
              }
            }, '*');
            
            // 等待关联确认
            await associationPromise;
          } else {
            throw new Error(`上传失败: ${uploadResult.error}`);
          }
        }
        
        // 检查是否全部上传完成
        const allUploaded = uploadedGifs.size >= totalRequired;
        
        if (allUploaded) {
          // 全部上传完成，关闭弹窗并开始导出
          if (progressBar) progressBar.style.width = '100%';
          if (progressText) progressText.textContent = t('upload_done', totalRequired, totalRequired);
          
          // showToast('开始导出', 'info');
          
          // 短暂延迟让用户看到完成状态
          await new Promise(resolve => setTimeout(resolve, 300));
          
          try {
            const overlay = document.getElementById('uploadGifOverlay');
            if (overlay) {
              overlay.classList.remove('show');
              overlay.classList.add('hidden');
              setTimeout(() => {
                overlay.style.display = 'none';
              }, 300);
            }
            
            parent.postMessage({
              pluginMessage: { type: 'export-annotated-gif' }
            }, '*');
          } catch (e) {
            const overlay = document.getElementById('uploadGifOverlay');
            if (overlay) overlay.style.display = 'none';
            
            parent.postMessage({
              pluginMessage: { type: 'export-annotated-gif' }
            }, '*');
          }
        } else {
          // 还有文件未上传，提示用户继续
          const remaining = totalRequired - uploadedGifs.size;
          const uploaded = uploadedGifs.size;
          
          if (progressBar) progressBar.style.width = `${Math.round((uploaded / totalRequired) * 100)}%`;
          if (progressText) progressText.textContent = t('upload_partial', uploaded, totalRequired);
          
          showToast(t('toast_uploaded_progress', uploaded, totalRequired), 'info');
          
          // 恢复拖拽区域，让用户继续上传
          if (dropzone) dropzone.style.display = 'flex';
          if (progressContainer) progressContainer.style.display = 'none';
          
          // 更新副标题显示待上传的图层
          updateUploadSubtitle(subtitleContainer, unsyncedGifs);
          
        }
        
      } catch (error) {
        console.error('❌ 上传失败:', error);
        showToast(t('toast_upload_fail') + ': ' + error.message, 'error');
        
        // 恢复拖拽区域
        if (dropzone) dropzone.style.display = 'flex';
        if (progressContainer) progressContainer.style.display = 'none';
        // 更新副标题
        updateUploadSubtitle(subtitleContainer, unsyncedGifs);
      }
    }
    
    // 更新上传弹窗副标题，显示待上传的图层信息
    function updateUploadSubtitle(subtitleContainer, unsyncedGifs) {
      if (!subtitleContainer) return;
      
      const totalRequired = unsyncedGifs.length;
      const uploaded = uploadedGifs.size;
      const remaining = totalRequired - uploaded;
      
      if (remaining === 0) {
        subtitleContainer.innerHTML = `<span style="color: var(--primary)">${t('upload_all_done')}</span>`;
      } else if (remaining === totalRequired) {
        // 还没开始上传
        subtitleContainer.innerHTML = tPlural('upload_needed', totalRequired);
      } else {
        // 部分已上传
        subtitleContainer.innerHTML = `<span style="color: var(--primary)">${t('upload_partial', uploaded, totalRequired)}</span>${t('upload_remaining', remaining)}`;
      }
    }
    
    // 上传 GIF 到云端的辅助函数
    function uploadGifToCloud(filename, base64Data, layerId, progressCallback) {
      return new Promise((resolve, reject) => {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          reject(new Error('WebSocket 未连接'));
          return;
        }
        
        const messageId = `upload-${layerId}-${Date.now()}`;
        
        // 监听上传结果
        const uploadListener = function(event) {
          const data = JSON.parse(event.data);
          if (data.type === 'upload-gif-result' && data.messageId === messageId) {
            ws.removeEventListener('message', uploadListener);
            if (data.success) {
              resolve({
                success: true,
                driveFileId: data.driveFileId,
                ossFileId: data.ossFileId,
                imageHash: data.imageHash,
                gifCacheId: data.gifCacheId,
                originalFilename: data.originalFilename
              });
            } else {
              reject(new Error(data.error || '上传失败'));
            }
          }
        };
        
        ws.addEventListener('message', uploadListener);
        
        // 通知正在发送
        if (progressCallback) progressCallback('sending');
        
        // 发送上传请求（使用 Base64 编码）
        wsSend('upload-local-gif', { messageId: messageId, filename: filename, base64: base64Data, layerId: layerId });
        
        if (progressCallback) progressCallback('processing');
        
        // 120 秒超时（给大文件更多时间）
        setTimeout(() => {
          ws.removeEventListener('message', uploadListener);
          reject(new Error('上传超时（120秒）'));
        }, 120000);
      });
    }
    window.onmessage = function (event) {
      // 🛡️ 安全处理消息，防止错误导致插件崩溃
      try {
        var msg = event.data && event.data.pluginMessage;
        if (!msg) return;

        if (msg.type === 'plugin-closing') {
          stopRealtimeSync();
        } else if (msg.type === 'request-skipped-file-cache' || msg.type === 'request-skipped-file-cache-for-node') {
        // ✅ code.js 请求获取跳过文件的缓存信息（用于自动关联手动拖入的Video/GIF）
        const isForNode = msg.type === 'request-skipped-file-cache-for-node';
        
        if (!msg.filename) {
          return;
        }
        
        // 直接匹配
        let cacheData = skippedFileCache.get(msg.filename);
        
        // 如果直接匹配失败，尝试模糊匹配
        if (!cacheData) {
          let nameClean = msg.filename.replace(/\.[^/.]+$/, '').replace(/\s\d+$/, '');
          
          const normalize = (str) => str.toLowerCase().replace(/\.[^/.]+$/, '').replace(/\s+/g, '');
          const targetName = normalize(nameClean);
          
          for (const [key, value] of skippedFileCache.entries()) {
            const cacheName = normalize(key);
            if (cacheName === targetName) {
              cacheData = value;
              break;
            }
            if (targetName.includes(cacheName) || cacheName.includes(targetName)) {
               if (Math.abs(targetName.length - cacheName.length) < 5) {
                 cacheData = value;
                 break;
               }
            }
          }
        }
        
        if (cacheData) {
          const response = {
            type: 'skipped-file-cache-response',
            filename: msg.filename,
            cacheData: cacheData
          };
          
          if (isForNode && msg.nodeId) {
            response.nodeId = msg.nodeId;
          }
          
          parent.postMessage({
            pluginMessage: response
          }, '*');
        } else {
          // 如果 UI 缓存没找到，且是自动关联请求，尝试向 Server 请求检查
          if (isForNode && msg.nodeId) {
             wsSend('check-cache-existence', { files: [{ filename: msg.filename, layerId: msg.nodeId }] });
          }
        }
      } else if (msg.type === 'export-batch-start') {
        // Start export flow
        totalExports = msg.total || 0;
        completedExports = 0;
        isExporting = true;
        isCancellingExport = false; // ✅ 重置取消标志
        
        // Add exporting class to button
        if (exportGifBtn) {
          exportGifBtn.classList.add("exporting");
          exportGifBtn.classList.remove("success");
          // 修改 tooltip 为停止导出
          exportGifBtn.setAttribute('data-tooltip', t('tooltip_stop_export'));
        }
        
        if (totalExports > 0) {
          startSmoothProgress(); // Start smooth progress animation
        }
        
        // Reset button state
        const exportBtn = document.getElementById('exportGifBtn');
        if (exportBtn) {
            exportBtn.classList.remove('success');
        }
      } else if (msg.type === 'export-gif-error') {
        showToast(msg.error, 'error');
        // Reset button state
        stopSmoothProgress();
        const exportBtn = document.getElementById('exportGifBtn');
        if (exportBtn) {
            exportBtn.classList.remove('success');
            const ring = exportBtn.querySelector('.progress-ring');
            if (ring) ring.style.opacity = 0;
        }
        isExporting = false;
      } else if (msg.type === 'export-gif-cancelled') {
        // ✅ 处理 code.js 发来的取消确认消息
        stopSmoothProgress();
        const exportBtn = document.getElementById('exportGifBtn');
        if (exportBtn) {
            exportBtn.classList.remove('exporting');
            exportBtn.classList.remove('success');
            exportBtn.setAttribute('data-tooltip', t('tooltip_export_gif'));
            const ring = exportBtn.querySelector('.progress-ring');
            if (ring) ring.style.opacity = 0;
        }
        isExporting = false;
      } else if (msg.type === 'frame-selection-result') {
        // Handle frame selection check result
        if (!msg.hasValidFrame) {
            showToast(t('toast_select_frame'), 'warning');
        } else if (!msg.hasVideoLayer) {
            showToast(t('toast_no_video_layer'), 'warning');
        } else if (msg.invalidFrameNames && msg.invalidFrameNames.length > 0) {
            // 部分 Frame 不含录屏
            showToast(t('toast_some_frames_no_video', msg.invalidFrameNames.join(', ')), 'warning');
        } else {
            showExportChoiceModal(msg.frameCount > 1);
        }
      } else if (msg.type === 'auto-cache-dropped-video') {
        // 🔄 自动缓存：用户拖入视频/GIF 时，将文件数据发送给 Server 缓存
        if (ws && ws.readyState === WebSocket.OPEN) {
          if (msg.base64) {
            // ✅ 主路径：有文件字节数据（来自 getBytesAsync），直接发给 Server 缓存
            const sizeMB = (msg.base64.length * 0.75 / 1024 / 1024).toFixed(2);
            console.log('🔄 [自动缓存] 发送文件数据:', msg.filename, sizeMB + ' MB');
            wsSend('auto-cache-video-by-search', { filename: msg.filename, timestamp: msg.timestamp, base64: msg.base64 });
          } else {
            // ⚠️ 回退路径：只有文件名（getBytesAsync 失败），让 Server 在磁盘搜索
            console.log('🔄 [自动缓存] 回退到磁盘搜索:', msg.filename);
            wsSend('auto-cache-video-by-search', { filename: msg.filename, timestamp: msg.timestamp });
          }
        } else {
          console.warn('🔄 [自动缓存] WebSocket 未连接，跳过自动缓存:', msg.filename);
          parent.postMessage({
            pluginMessage: {
              type: 'auto-cache-result',
              filename: msg.filename,
              timestamp: msg.timestamp,
              success: false,
              error: 'WebSocket 未连接'
            }
          }, '*');
        }
      } else if (msg.type === 'request-upload-gifs') {
        // 请求用户上传未同步的 GIF
        showUploadGifModal(msg.unsyncedGifs);
      } else if (msg.type === 'associate-gif-success') {
        // 从待确认列表移除，并解析 Promise
        pendingAssociations.delete(msg.layerId);
        if (associationResolvers[msg.layerId]) {
          associationResolvers[msg.layerId](true);
          delete associationResolvers[msg.layerId];
        }
      } else if (msg.type === 'associate-gif-error') {
        console.error('❌ GIF 数据关联失败:', msg.layerId, msg.error);
        // 从待确认列表移除，并解析 Promise（即使失败也要解析）
        pendingAssociations.delete(msg.layerId);
        if (associationResolvers[msg.layerId]) {
          associationResolvers[msg.layerId](false);
          delete associationResolvers[msg.layerId];
        }
        showToast(t('toast_assoc_fail') + ': ' + msg.error, 'error');
      } else if (msg.type === 'trigger-export-from-code') {
        // code.js 请求重新触发导出（清除数据后）
        parent.postMessage({
          pluginMessage: { 
            type: 'export-annotated-gif',
            skipServerCheck: msg.skipServerCheck || false
          }
        }, '*');
      } else if (msg.type === 'check-server-cache-for-unsynced') {
        // ✅ 转发检查请求给 Server
        if (wsSend('check-cache-existence', { files: msg.unsyncedGifs.map(g => ({ filename: g.filename, layerId: g.layerId })) })) {
          pendingExportCacheCheck = true; // ✅ 标记这是导出流程的缓存检查
        } else {
          console.warn('⚠️ WebSocket 未连接，无法检查缓存，直接请求上传');
          // 回退到请求上传
          parent.postMessage({
            pluginMessage: { 
              type: 'request-upload-gifs',
              unsyncedGifs: msg.unsyncedGifs
            }
          }, '*');
        }
      } else if (msg.type === 'compose-annotated-gif') {
        // Forward message to server with GIF algorithm setting
        if (ws && ws.readyState === WebSocket.OPEN) {
          // 添加 GIF 算法设置（使用 window 全局变量）
          const algorithmToUse = window.gifAlgorithmSetting || 'smooth_gradient';
          msg.gifAlgorithm = algorithmToUse;
          console.log(`🎨 [导出] 使用算法: ${algorithmToUse} (${algorithmToUse === 'smooth_gradient' ? '更丝滑渐变 - floyd_steinberg' : '更少噪点 - 无抖动'})`);
          ws.send(JSON.stringify(msg));
        } else {
          console.error('   ❌ WebSocket未连接，无法发送消息');
          showToast(t('toast_server_offline'), 'error');
          // Reset button state
          const exportBtn = document.getElementById('exportGifBtn');
          if (exportBtn) {
              exportBtn.classList.remove('success');
              const ring = exportBtn.querySelector('.progress-ring');
              if (ring) ring.style.opacity = 0;
          }
          isExporting = false;
          stopSmoothProgress();
        }
      } else if (msg.type === 'frame-created') {
        log('✅ 画板已创建');
      } else if (msg.type === 'frame-located') {
        if (msg.success) log('📍 ' + msg.message);
        else log('❌ ' + msg.message);
      } else if (msg.type === 'screenshot-added') {
        if (msg.success) {
          screenshotCount++;
          document.getElementById('count').textContent = screenshotCount;
          
          if (ws && ws.readyState === WebSocket.OPEN) {
            // 优先使用 plugin 返回的 ID
            const driveFileId = msg.driveFileId || (currentFileIdType === 'drive' ? currentFileId : null);
            const ossFileId = msg.ossFileId || (currentFileIdType === 'oss' ? currentFileId : null);
            
            if (driveFileId || ossFileId) {
              try {
                const confirmMessage = {
                  type: 'screenshot-received',
                  filename: msg.filename || '未命名文件',
                  timestamp: Date.now()
                };
                if (ossFileId) confirmMessage.ossFileId = ossFileId;
                if (driveFileId) confirmMessage.driveFileId = driveFileId;
                
                ws.send(JSON.stringify(confirmMessage));
                
                if (!msg.driveFileId && !msg.ossFileId) {
                currentFileId = null;
                currentFileIdType = null;
                }
              } catch (error) {
                console.error('❌ 发送确认失败:', error);
              }
            }
          }
        } else {
          log('❌ 添加失败: ' + (msg.error || '未知错误'));
          
          // 如果添加失败，但已经备份到本地，也发送确认以删除云端文件
          if (currentFileBackedUp) {
            log('⚠️  导入 Figma 失败，但文件已备份到本地，确认删除云端文件');
            showToast(t('toast_import_fail_local'), 'warning');
            
            if (ws && ws.readyState === WebSocket.OPEN) {
              // 优先使用 plugin 返回的 ID
              const driveFileId = msg.driveFileId || (currentFileIdType === 'drive' ? currentFileId : null);
              const ossFileId = msg.ossFileId || (currentFileIdType === 'oss' ? currentFileId : null);
              
              if (driveFileId || ossFileId) {
                try {
                  const confirmMessage = {
                    type: 'screenshot-received',
                    filename: msg.filename || '未命名文件',
                    timestamp: Date.now()
                  };
                  if (ossFileId) confirmMessage.ossFileId = ossFileId;
                  if (driveFileId) confirmMessage.driveFileId = driveFileId;
                  
                  ws.send(JSON.stringify(confirmMessage));
                  
                  // Reset
                  if (!msg.driveFileId && !msg.ossFileId) {
                  currentFileId = null;
                  currentFileIdType = null;
                  }
                  currentFileBackedUp = false;
                } catch (error) {
                  console.error('❌ 发送确认失败:', error);
                }
              }
            }
          }
        }
      } else if (msg.type === 'file-needs-manual-drag') {
        manualDragCount++;
        // Don't reset state - let currentButtonState handle locking
        const reasonText = msg.reason === 'undefined-error' ? t('toast_import_fail') : t('reason_unknown');
        log(`⚠️  ${msg.filename} 需手动导入`);
        
        if (ws && ws.readyState === WebSocket.OPEN) {
          try {
            const failMessage = {
              type: 'screenshot-failed',
              filename: msg.filename,
              error: msg.error || 'undefined',
               keepFile: true
            };
            
            const driveFileId = msg.driveFileId || (currentFileIdType === 'drive' ? currentFileId : null);
            const ossFileId = msg.ossFileId || (currentFileIdType === 'oss' ? currentFileId : null);
            
            if (ossFileId) failMessage.ossFileId = ossFileId;
            if (driveFileId) failMessage.driveFileId = driveFileId;
            
            ws.send(JSON.stringify(failMessage));
            
            if (!msg.driveFileId && !msg.ossFileId) {
            currentFileId = null;
            currentFileIdType = null;
            }
          } catch (error) {
            console.error('发送失败消息失败:', error);
          }
        }
        updateStatus('connected', '');
      } else if (msg.type === 'size-settings-loaded') {
        if (msg.width) imageWidthInput.value = msg.width;
        if (msg.height) imageHeightInput.value = msg.height;
      } else if (msg.type === 'size-settings-updated') {
        // Toast now handled by unified saveAllSettings function
        // No individual toast needed to avoid duplicates
      } else if (msg.type === 'layout-settings-loaded') {
        if (msg.columns) frameColumnsInput.value = msg.columns;
      } else if (msg.type === 'layout-settings-updated') {
        // Toast now handled by unified saveAllSettings function
        // No individual toast needed to avoid duplicates
      } else if (msg.type === 'gif-algorithm-response') {
        // 接收 GIF 算法设置（来自 code.js 的 clientStorage）
        const algorithm = msg.algorithm || 'smooth_gradient';
        window.gifAlgorithmSetting = algorithm;
        console.log(`🎨 [Settings] 从存储加载 GIF 算法: ${algorithm}`);
        const gifAlgSelect = document.getElementById('gifAlgorithmSelect');
        if (gifAlgSelect) {
          gifAlgSelect.value = algorithm;
          if (typeof originalSettings !== 'undefined') {
            originalSettings.gifAlgorithm = algorithm;
          }
          // currentSettings removed (auto-save replaces change tracking)
          if (typeof adjustSelectWidth === 'function') {
            adjustSelectWidth(gifAlgSelect);
          }
        }
      } else if (msg.type === 'language-response') {
        // Load saved language from clientStorage
        const lang = msg.language || 'zh';
        currentLang = lang;
        const langSelect = document.getElementById('languageSelect');
        if (langSelect) {
          langSelect.value = lang;
        }
        updateLangFlag(lang);
        applyLanguage();
      } else if (msg.type === 'server-path-loaded') {
        if (msg.path) {
          serverInstallPath = msg.path;
          const pathEl = document.getElementById('server-path-placeholder');
          if (pathEl) {
            pathEl.textContent = serverInstallPath;
            pathEl.style.color = 'inherit';
          }
        }
      } else if (msg.type === 'plugin-version-info') {
        // 获取插件版本信息
        handlePluginVersionInfo(msg);
      }
      } catch (error) {
        // 🛡️ 捕获所有错误，防止插件崩溃
        console.error('❌ window.onmessage 处理错误:', error);
      }
    };

    const logContainer = document.getElementById('logContainer');
    const logHeader = document.getElementById('logHeader');
    const logToggleText = document.getElementById('logToggleText');

    function collapseLog() {
      logContainer.classList.add('collapsed');
      logToggleText.textContent = t('log_expand');
    }

    function expandLog() {
      logContainer.classList.remove('collapsed');
      logToggleText.textContent = t('log_collapse');
    }

    logHeader.addEventListener('click', function () {
      const isCollapsed = logContainer.classList.contains('collapsed');
      if (isCollapsed) expandLog();
      else collapseLog();
    });

    // ✅ 初始状态：显示"正在连接"，确保服务器未启动时界面正常加载
    updateStatus('waiting', t('status_connecting'));

    // 使用 setTimeout 确保 connect() 异步执行，不阻塞界面渲染
    setTimeout(() => {
    connect();
    }, 0);
    
    loadServerPath(); // 加载保存的服务器路径
    // 请求当前插件版本
    postToPlugin('get-plugin-version');

    // // 临时显示 Update Banner 用于调整样式（开发调试用）
    // setTimeout(() => {
    //   const banner = document.getElementById('updateBanner');
    //   const text = document.getElementById('updateBannerText');
    //   if (banner && text) {
    //     text.textContent = '发现新版本 v1.0.2';
    //     banner.classList.add('show');
    //     console.log('🎨 临时显示 Update Banner 用于样式调整');
    //   }
    // }, 500);

    window.addEventListener('beforeunload', function () {
      stopRealtimeSync();
    });
    
    
    // Copy User ID Logic
    const copyUserIdBtn = document.getElementById('copyUserIdBtn');
    if (copyUserIdBtn) {
      copyUserIdBtn.onclick = function() {
        const userIdEl = document.getElementById('displayUserId');
        if (!userIdEl) return;
        
        const userId = userIdEl.textContent.trim();
        if (!userId || userId === t('mobile_userid_loading')) {
          showToast(t('toast_userid_unavail'), 'error');
          return;
        }
        
        const textArea = document.createElement("textarea");
        textArea.value = userId;
        document.body.appendChild(textArea);
        textArea.select();
        try {
          document.execCommand('copy');
          showToast(t('toast_userid_copied'), 'success');
        } catch (err) {
          showToast(t('toast_copy_fail'), 'error');
        }
        document.body.removeChild(textArea);
      };
    }
      // ==========================================
    // Export GIF Logic
    // ==========================================
    
    let totalExports = 0;
    let completedExports = 0;
    let isExporting = false;
    let isCancellingExport = false; // 标记是否正在取消导出（用于忽略取消后的错误消息）
    let pendingExportCacheCheck = false; // 标记是否有待处理的导出流程缓存检查
    let successTimer = null;
    let circumference = 0;
    let progressCircle = null;
    
    // Manual Sync Progress
    let totalManualSyncFiles = 0;
    let completedManualSyncFiles = 0;
    let isManualSyncing = false;
    let syncStarted = false; // ✅ 标记同步是否已经开始（收到了第一个响应）
    let manualSyncTimeoutId = null; // ✅ 保存超时 ID，以便清除
    
    // ✅ 导出超时检测
    let exportTimeoutId = null; // 导出超时计时器
    let lastProgressUpdate = 0; // 上次进度更新时间
    const EXPORT_STALL_TIMEOUT = 600000; // 10分钟无进度更新视为卡住
    let circumferenceManual = 0;
    let progressCircleManual = null;
    let progressRingManual = null;
    let progressRing = null;
    let exportGifBtn = null;
    let smoothProgressInterval = null;
    let currentSmoothProgress = 0;
    
    // 跟踪窗口焦点状态（用于判断是否显示 toast）
    let windowHasFocus = !document.hidden;
    
    // 监听窗口焦点和可见性变化
    window.addEventListener('focus', () => {
      windowHasFocus = true;
    });
    
    window.addEventListener('blur', () => {
      windowHasFocus = false;
    });
    
    document.addEventListener('visibilitychange', () => {
      windowHasFocus = !document.hidden;
    });

    // Initialize after DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
        // Check for Update Banner and adjust height immediately
        const updateBanner = document.getElementById('updateBanner');
        if (updateBanner && (updateBanner.classList.contains('show') || updateBanner.style.display === 'block' || updateBanner.style.display === 'flex')) {
            parent.postMessage({
                pluginMessage: { type: 'resize', width: 360, height: 460 }
            }, '*');
        } else {
            parent.postMessage({
                pluginMessage: { type: 'resize', width: 360, height: 400 }
            }, '*');
        }

        // 开发者模式：显示模式切换区域
        if (DEVELOPER_MODE) {
          const modeSwitchSection = document.getElementById('modeSwitchSection');
          if (modeSwitchSection) {
            modeSwitchSection.style.display = '';
          }
        }
        
        exportGifBtn = document.getElementById("exportGifBtn");
        progressRing = exportGifBtn ? exportGifBtn.querySelector(".progress-ring") : null;
        progressCircle = exportGifBtn ? exportGifBtn.querySelector(".progress-ring__circle") : null;
        
        // Initialize Export GIF Progress Ring
        if (progressCircle) {
            const radius = progressCircle.r.baseVal.value;
            circumference = radius * 2 * Math.PI;
            progressCircle.style.strokeDasharray = `${circumference} ${circumference}`;
            progressCircle.style.strokeDashoffset = circumference;
        }
        
        // Initialize Manual Sync Progress Ring
        let manualSyncBtn = document.getElementById("manualSyncBtn");
        progressRingManual = manualSyncBtn ? manualSyncBtn.querySelector(".progress-ring-manual") : null;
        progressCircleManual = manualSyncBtn ? manualSyncBtn.querySelector(".progress-ring-manual .progress-ring__circle") : null;
        
        if (progressCircleManual) {
            const radius = progressCircleManual.r.baseVal.value;
            circumferenceManual = radius * 2 * Math.PI;
            progressCircleManual.style.strokeDasharray = `${circumferenceManual} ${circumferenceManual}`;
            progressCircleManual.style.strokeDashoffset = circumferenceManual;
        }

        // 手动同步按钮逻辑绑定
        if (manualSyncBtn) {
            manualSyncBtn.onclick = function() {
                // Check if already syncing
                if (isManualSyncing) {
                    showToast(t('toast_syncing'), 'loading');
                    return;
                }
                
                // Check connection
                if (!ws || ws.readyState !== WebSocket.OPEN) {
                    log('❌ 未连接');
                    updateStatus('disconnected', t('status_reconnect'));
                    return;
                }
                
                // ✅ 立即开始视觉反馈（无需等待）
                isManualSyncing = true;
                manualDragCount = 0;
                skippedFilesSet.clear();
                gifBackupCount = 0;
                
                // ✅ 显示旋转的进度条（无限循环动画）
                if (progressRingManual) {
                    const circle = progressCircleManual;
                    // 设置为无限旋转动画
                    circle.style.strokeDasharray = `${circumferenceManual * 0.25} ${circumferenceManual}`;
                    circle.style.strokeDashoffset = '0';
                    progressRingManual.style.opacity = 1;
                    progressRingManual.style.animation = 'rotate 1s linear infinite';
                }
                
                // ✅ Add syncing visual state
                manualSyncBtn.classList.add('exporting');
                manualSyncBtn.setAttribute('data-tooltip', t('tooltip_syncing'));
                
                // ✅ 重置同步开始标记
                syncStarted = false;
                
                log('🫳🏻 开始手动同步...');
                updateStatus('connected', t('status_syncing'));
                
                // ✅ 清除之前的超时（如果有）
                if (manualSyncTimeoutId) {
                    clearTimeout(manualSyncTimeoutId);
                    manualSyncTimeoutId = null;
                }
                
                // ✅ 超时保护 (30秒内完全没反应才算超时)
                manualSyncTimeoutId = setTimeout(() => {
                    // 只有当同步尚未开始时才判断为超时
                    if (isManualSyncing && !syncStarted) {
                        console.warn('⚠️ 手动同步超时 (30s内无响应)');
                        isManualSyncing = false;
                        manualSyncBtn.classList.remove('exporting');
                        manualSyncBtn.setAttribute('data-tooltip', t('tooltip_manual_sync'));
                        if (progressRingManual) {
                            progressRingManual.style.opacity = 0;
                            progressRingManual.style.animation = '';
                        }
                        updateStatus('connected', t('status_sync_timeout'));
                        showToast(t('toast_sync_timeout'), 'error');
                        manualSyncTimeoutId = null;
                    } else if (isManualSyncing && syncStarted) {
                        // 已经开始同步但还没完成，不算超时，清除超时 ID
                        manualSyncTimeoutId = null;
                    }
                }, 30000);
                
                // ✅ 直接发送同步请求（立即响应）
                try {
                    wsSend('manual-sync');
                } catch (error) {
                    console.error('❌ 发送同步请求失败:', error);
                    isManualSyncing = false;
                    manualSyncBtn.classList.remove('exporting');
                    manualSyncBtn.setAttribute('data-tooltip', t('tooltip_manual_sync'));
                    if (progressRingManual) {
                        progressRingManual.style.opacity = 0;
                        progressRingManual.style.animation = '';
                    }
                    updateStatus('connected', t('status_request_fail'));
                    showToast(t('toast_request_fail'), 'error');
                }
            };
        }

        // ✅ 长按检测变量
        let longPressTimer = null;
        let isLongPress = false;
        const LONG_PRESS_DURATION = 800; // 长按持续时间（毫秒）
        
        // Legacy listeners removed, handled by setupExportButtonLongPress at the bottom of the file
        // This prevents duplicate event handling and conflicts with the new timeline editor feature
        if (exportGifBtn) {
             // Clear any inline handlers just in case
             exportGifBtn.onclick = null;
        }
        
        // 主界面开始按钮
        const mainStartBtn = document.getElementById('mainStartBtn');
        if (mainStartBtn) {
            mainStartBtn.onclick = function() {
                // 防抖保护：防止用户狂点
                if (mainStartBtn.classList.contains('processing')) return;
                
                // 标记处理中
                mainStartBtn.classList.add('processing');
                setTimeout(() => mainStartBtn.classList.remove('processing'), 500); // 0.5s 防抖
                
                toggleRealtimeSync();
            };
        }
        
        // 自动进入实时模式
        setTimeout(() => {
            if (ws && ws.readyState === 1) {
                showWorkArea('realtime');
            } else {
            }
        }, 500);
    });

    function setExportProgress(percent) {
        // Re-check elements if null (just in case)
        if (!progressCircle || !progressRing) {
             exportGifBtn = document.getElementById("exportGifBtn");
             progressRing = exportGifBtn ? exportGifBtn.querySelector(".progress-ring") : null;
             progressCircle = exportGifBtn ? exportGifBtn.querySelector(".progress-ring__circle") : null;
             if (progressCircle && circumference === 0) {
                 const radius = progressCircle.r.baseVal.value;
                 circumference = radius * 2 * Math.PI;
                 progressCircle.style.strokeDasharray = `${circumference} ${circumference}`;
             }
        }
        
        if (!progressCircle || !progressRing) {
            console.warn('⚠️ setExportProgress: 元素未找到', { progressCircle, progressRing });
            return;
        }
        
        const offset = circumference - (percent / 100) * circumference;
        progressCircle.style.strokeDashoffset = offset;
        progressRing.style.opacity = 1;
    }
    
    function setManualSyncProgress(percent) {
        // Re-check elements if null (just in case)
        if (!progressCircleManual || !progressRingManual) {
             const manualSyncBtn = document.getElementById("manualSyncBtn");
             progressRingManual = manualSyncBtn ? manualSyncBtn.querySelector(".progress-ring-manual") : null;
             progressCircleManual = manualSyncBtn ? manualSyncBtn.querySelector(".progress-ring-manual .progress-ring__circle") : null;
             if (progressCircleManual && circumferenceManual === 0) {
                 const radius = progressCircleManual.r.baseVal.value;
                 circumferenceManual = radius * 2 * Math.PI;
                 progressCircleManual.style.strokeDasharray = `${circumferenceManual} ${circumferenceManual}`;
             }
        }
        
        if (!progressCircleManual || !progressRingManual) {
            console.warn('⚠️ setManualSyncProgress: 元素未找到', { progressCircleManual, progressRingManual });
            return;
        }
        
        const offset = circumferenceManual - (percent / 100) * circumferenceManual;
        progressCircleManual.style.strokeDashoffset = offset;
        progressRingManual.style.opacity = 1;
    }

    // 更新真实进度
    function updateRealProgress(percent, message) {
        // ✅ 收到进度更新，重置卡住检测计时器
        resetExportStallDetection();
        
        // 如果有消息，可以更新状态文本（如果有状态显示区域的话）
        if (message) {
            // 可选：更新按钮文字显示当前状态
            if (exportGifBtn && !exportGifBtn.classList.contains('success')) {
               const btnText = exportGifBtn.querySelector('span');
               if (btnText) btnText.textContent = t('btn_exporting', percent);
            }
        }

        // 基于当前批次进度的计算
        // 假设每个 GIF 的处理进度是独立的，这里我们主要关注当前的 percent
        // 但为了防止进度条倒退（当处理下一个 GIF 时），我们需要综合考虑
        
        // 简单策略：直接使用服务器返回的百分比作为当前目标
        // 但为了平滑，我们不直接 set，而是更新 target，让 smooth interval 去追赶
        
        // 实际上，服务器现在的进度是针对单个请求的。
        // 如果是批量导出，我们需要结合 completedExports 和 totalExports 来计算总进度
        // 总进度 = (已完成数量 * 100 + 当前正在处理的百分比) / 总数量
        
        let batchProgress = percent;
        if (totalExports > 1) {
            batchProgress = ((completedExports * 100) + percent) / totalExports;
        }
        
        // 确保进度不倒退
        if (batchProgress > currentSmoothProgress) {
             currentSmoothProgress = batchProgress;
             setExportProgress(currentSmoothProgress);
        }
    }

    // Smooth progress simulation for better UX
    // 现在主要作为"心跳"动画，防止用户以为卡死
    function startSmoothProgress() {
        
        if (smoothProgressInterval) clearInterval(smoothProgressInterval);
        
        // 初始进度
        currentSmoothProgress = 2;
        lastProgressUpdate = Date.now(); // 记录开始时间
        setExportProgress(currentSmoothProgress);
        
        if (exportGifBtn) {
           const btnText = exportGifBtn.querySelector('span');
           if (btnText) btnText.textContent = t('btn_preparing');
        }
        
        // ✅ 启动导出超时检测
        startExportStallDetection();
        
        smoothProgressInterval = setInterval(() => {
            // 仅仅做极缓慢的增加，作为"我还在运行"的信号
            // 如果真实进度来了，currentSmoothProgress 会被 updateRealProgress 大幅更新
            
            // 如果卡在某个进度太久，最多自动爬升 5%
            // 比如当前是 30%，最多自动爬到 35%，然后等待服务器消息
            
            // 这里我们只做非常微小的蠕动，每 100ms 增加 0.05%
            // 这样 1秒增加 0.5%，1分钟增加 30%
            // 并在 95% 处封顶
            
            if (currentSmoothProgress < 95) {
                currentSmoothProgress += 0.05;
                setExportProgress(currentSmoothProgress);
            }
            
        }, 100); 
    }
    
    // ✅ 导出卡住检测
    function startExportStallDetection() {
        // 清除之前的超时（如果有）
        if (exportTimeoutId) {
            clearTimeout(exportTimeoutId);
            exportTimeoutId = null;
        }
        
        // 设置新的超时检测
        exportTimeoutId = setTimeout(() => {
            // 检查是否还在导出中
            if (isExporting) {
                console.warn('⚠️  检测到导出超时（进度停滞超过 10 分钟）');
                
                // ✅ 设置取消标志，忽略后续的错误消息
                isCancellingExport = true;
                
                // ✅ 发送取消消息给 code.js
                postToPlugin('cancel-gif-export');
                
                // ✅ 发送取消消息给 server
                wsSend('cancel-gif-export');
                
                // 停止导出并提示用户
                stopSmoothProgress();
                clearExportStallDetection();
                
                isExporting = false;
                totalExports = 0;
                completedExports = 0;
                currentSmoothProgress = 0;
                
                // 重置 UI
                if (exportGifBtn) {
                    exportGifBtn.classList.remove("exporting");
                    exportGifBtn.classList.remove("success");
                    exportGifBtn.setAttribute('data-tooltip', t('tooltip_export_gif'));
                }
                if (progressRing) progressRing.style.opacity = 0;
                
                // 提示用户
                showToast(t('toast_export_timeout'), 'error');
                log('❌ ' + t('log_export_timeout_detail'));
                updateStatus('connected', '');
            }
        }, EXPORT_STALL_TIMEOUT);
    }
    
    // ✅ 清除导出卡住检测
    function clearExportStallDetection() {
        if (exportTimeoutId) {
            clearTimeout(exportTimeoutId);
            exportTimeoutId = null;
        }
    }
    
    // ✅ 重置导出卡住检测（收到进度更新时调用）
    function resetExportStallDetection() {
        lastProgressUpdate = Date.now();
        if (isExporting) {
            startExportStallDetection();
        }
    }

    function stopSmoothProgress() {
        if (smoothProgressInterval) {
            clearInterval(smoothProgressInterval);
            smoothProgressInterval = null;
        }
    }

    function createSplashParticles(rect) {
        const particleCount = 12;
        const colors = ["#34C759", "#32D74B", "#248A3D"]; // Shades of green
        
        for (let i = 0; i < particleCount; i++) {
            const particle = document.createElement("div");
            particle.classList.add("splash-particle");
            document.body.appendChild(particle);
            
            // Random position around center
            const angle = (i / particleCount) * 360 + (Math.random() * 30 - 15);
            const distance = 20 + Math.random() * 15;
            
            // Start at button center
            const startX = rect.left + rect.width / 2;
            const startY = rect.top + rect.height / 2;
            
            particle.style.left = `${startX}px`;
            particle.style.top = `${startY}px`;
            particle.style.background = colors[Math.floor(Math.random() * colors.length)];
            
            // Calculate destination
            const rad = angle * Math.PI / 180;
            const tx = Math.cos(rad) * distance;
            const ty = Math.sin(rad) * distance;
            
            particle.style.setProperty("--tx", `${tx}px`);
            particle.style.setProperty("--ty", `${ty}px`);
            
            particle.style.animation = `splash-anim 0.6s cubic-bezier(0.165, 0.84, 0.44, 1) forwards`;
            
            // Cleanup
            setTimeout(() => {
                if (particle.parentNode) document.body.removeChild(particle);
            }, 600);
        }
    }

    function cancelExport() {
        // ✅ 设置取消标志，忽略后续的错误消息
        isCancellingExport = true;

        // 发送取消消息给后端
        postToPlugin('cancel-gif-export');
        
        // 立即停止平滑进度动画
        stopSmoothProgress();
        clearExportStallDetection(); // ✅ 清除超时检测
        
        // 完全重置所有状态
        isExporting = false;
        totalExports = 0;
        completedExports = 0;
        currentSmoothProgress = 0;
        
        // 重置 UI 到初始状态
        if (exportGifBtn) {
            exportGifBtn.classList.remove("exporting");
            exportGifBtn.classList.remove("success");
            // 恢复原始 tooltip
            exportGifBtn.setAttribute('data-tooltip', t('tooltip_export_gif'));
        }
        
        // 立即隐藏进度环
        setExportProgress(0);
        
        showToast(t('toast_export_stopped'), 'info');

        if (progressRing) {
            progressRing.style.transition = 'none';
            progressRing.style.opacity = '0';
            // 短暂延迟后恢复过渡效果，用于下次导出
            setTimeout(() => {
                if (progressRing) progressRing.style.transition = 'opacity 0.3s ease';
            }, 50);
        }
        
        // 重置进度到 0
        if (progressCircle) {
            progressCircle.style.transition = 'none';
            progressCircle.style.strokeDashoffset = circumference;
            setTimeout(() => {
                if (progressCircle) progressCircle.style.transition = 'stroke-dashoffset 0.2s linear';
            }, 50);
        }
        
        // 通知服务器取消所有进行中的处理
        wsSend('cancel-gif-export');
        
    }

    function handleExportSuccess() {
        completedExports++;

        // On final completion, stop smooth progress and update status pill
        if (completedExports >= totalExports && totalExports > 0) {

            stopSmoothProgress();
            clearExportStallDetection(); // ✅ 清除超时检测
            setExportProgress(100);
            
            setTimeout(() => {
                isExporting = false;
                
                // Remove exporting class
                if (exportGifBtn) {
                    exportGifBtn.classList.remove("exporting");
                    // 恢复原始 tooltip
                    exportGifBtn.setAttribute('data-tooltip', t('tooltip_export_gif'));
                }
                
                // Trigger icon completion glow animation (blink twice)
                const gifIcon = exportGifBtn.querySelector('.icon-export');
                if (gifIcon) {
                    gifIcon.classList.add('icon-completion-glow');
                    setTimeout(() => {
                        gifIcon.classList.remove('icon-completion-glow');
                    }, 1400); // Match animation duration
                }
                
                // Directly fade out the progress ring at 100% (no backward animation)
                if (progressRing) {
                    progressRing.style.opacity = 0;
                }
                
                // Reset stroke offset AFTER fade out completes (invisible to user)
                setTimeout(() => {
                    if (progressCircle) progressCircle.style.strokeDashoffset = circumference;
                }, 400); // Match fade-out duration
                
                // No toast - success feedback is through status pill only
            }, 300);
        }
    }

    function handleExportError() {
        completedExports++;

        // On final completion (even with errors), stop smooth progress
        if (totalExports > 0 && completedExports >= totalExports) {
            stopSmoothProgress();
            clearExportStallDetection(); // ✅ 清除超时检测
            setExportProgress(100);
            
            setTimeout(() => {
                isExporting = false;
                
                // Remove exporting class
                if (exportGifBtn) {
                    exportGifBtn.classList.remove("exporting");
                    // 恢复原始 tooltip
                    exportGifBtn.setAttribute('data-tooltip', t('tooltip_export_gif'));
                }
                
                // Directly fade out the progress ring at 100% (no backward animation)
                if (progressRing) {
                    progressRing.style.opacity = 0;
                }
                
                // Reset stroke offset AFTER fade out completes (invisible to user)
                setTimeout(() => {
                    if (progressCircle) progressCircle.style.strokeDashoffset = circumference;
                }, 300);
                
                // Error toast is already shown by individual error handlers
            }, 300);
        }
    }
  </script>
  <script>
    // ==========================================
    // Timeline Editor Logic (Added)
    // ==========================================

    let timelineData = {}; // { layerId: { start: 0, end: 100 } }
    let layersForTimeline = [];
    let layerFrames = {}; // { layerId: [{ percent: 0, data: base64 }, ...] }
    let timelineFrameId = null; // 存储时间线编辑的 Frame ID
    let timelineLongPressTimer;
    const TIMELINE_LONG_PRESS_MS = 500;
    let isTimelineLongPress = false;

    // 1. Export GIF Action Sheet / Modal Logic (Using Event Delegation)
    function setupExportButtonInteraction() {
      // Use event delegation on the document body to handle clicks on the export button
      document.body.addEventListener('click', (e) => {
          const btn = e.target.closest('#exportGifBtn');
          if (!btn) return;
          
          // Stop propagation to prevent conflicting handlers if any
          e.stopPropagation();
          
          if (isExporting) {
             cancelExport();
             return;
          }
          
          // First check if a valid frame is selected before showing modal
          checkFrameSelectionAndShowModal();
      }, true); // Use capture phase to ensure we intercept it first
      
      // Remove any inline onclick attribute
      const btn = document.getElementById('exportGifBtn');
      if (btn) btn.onclick = null;
    }
    
    // Check if a valid frame is selected before showing export modal
    function checkFrameSelectionAndShowModal() {
        // Request frame selection check from code.js
        parent.postMessage({ 
            pluginMessage: { type: "check-frame-selection" } 
        }, "*");
    }

    function showExportChoiceModal(isMultiSelect) {
        const modal = document.getElementById('exportChoiceOverlay');
        if (modal) {
            // 多选 Frame 时跳过弹窗，直接导出
            if (isMultiSelect) {
                startExportGif(null);
                return;
            }
            
            modal.classList.add('show');
            
            // Re-bind events (simple way, overwriting onclick is fine here since it's specific to this modal)
            document.getElementById('choiceDirectExport').onclick = (e) => {
                e.stopPropagation();
                modal.classList.remove('show');
                startExportGif(null);
            };
            
            document.getElementById('choiceTimeline').onclick = (e) => {
                e.stopPropagation();
                modal.classList.remove('show');
                openTimelineEditor();
            };
            
            // Close button in top-right corner
            document.getElementById('exportChoiceClose').onclick = (e) => {
                e.stopPropagation();
                modal.classList.remove('show');
            };

            // Click outside to close
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.classList.remove('show');
                }
            };
        }
    }

    // Call setup immediately
    setupExportButtonInteraction();
    // And also verify onclick is cleared after a delay
    setTimeout(() => {
        const btn = document.getElementById('exportGifBtn');
        if (btn) btn.onclick = null;
    }, 1000);


    // 2. Export Logic Wrapper
    function startExportGif(timelineSettings) {
        // Show preparing status
        if (exportGifBtn) {
            exportGifBtn.classList.add("exporting"); // Add exporting class immediately
            const btnText = exportGifBtn.querySelector('span');
            if (btnText) btnText.textContent = t('btn_preparing');
        }
        
        // Send message to code.js
        parent.postMessage({ 
            pluginMessage: { 
                type: "export-annotated-gif",
                timelineData: timelineSettings, // Pass timeline data if available
                frameId: timelineFrameId // 传递 Frame ID（来自时间线编辑）
            } 
        }, "*");
    }

    // 3. Timeline Editor UI Functions
    function openTimelineEditor() {
        // 🔄 彻底清除所有时间线缓存（UI 端 + Server 端），确保从零加载
        timelineData = {};
        layersForTimeline = [];
        layerFrames = {};
        timelineTotalDuration = 0;
        currentScrubTime = 0;
        invalidatePreviewCache();
        wsSend('clear-preview-cache');
        
        const overlay = document.getElementById('timelineEditorOverlay');
        overlay.classList.add('show');
        document.getElementById('timelineTracks').innerHTML = '<div style="text-align: center; color: var(--text-secondary); margin-top: 20px;">' + t('timeline_loading_layers') + '</div>';
        document.getElementById('timelinePreviewContainer').innerHTML = '<div style="color: var(--preview-text); font-size: 13px;">' + t('timeline_loading_preview') + '</div>';
        const scrubber = document.getElementById('timelineScrubber');
        if (scrubber) {
            scrubber.style.display = 'none';
            scrubber.style.left = '0';
        }
        
        // Request layers from code.js
        postToPlugin('request-timeline-layers');
    }
    
    // 窗口大小变化时清除布局缓存
    window.addEventListener('resize', () => {
        cachedScrubberLayout = null;
    });

    function closeTimelineEditor() {
        stopTimelinePlayback();
        document.getElementById('timelineEditorOverlay').classList.remove('show');
        
        // 清除所有时间线缓存，确保下次打开加载全新数据
        timelineData = {};
        layersForTimeline = [];
        layerFrames = {};
        timelineTotalDuration = 0;
        currentScrubTime = 0;
        invalidatePreviewCache();
        
        // 通知 code.js 时间线编辑器已关闭
        postToPlugin('timeline-editor-closed');
    }

    document.getElementById('timelineClose').onclick = closeTimelineEditor;

    document.getElementById('timelineExportBtn').onclick = () => {
        // ⚠️ 先保存 timelineData，因为 closeTimelineEditor 会清空它
        const exportTimelineData = JSON.parse(JSON.stringify(timelineData));
        closeTimelineEditor();
        // Debug: Log timeline data being sent
        console.log('🕐 [时间线] 导出时的timelineData:', JSON.stringify(exportTimelineData, null, 2));
        startExportGif(exportTimelineData);
    };

    function renderTimeline(layers, frameWidth, frameHeight, preservedData = null) {
        // 清除预览缓存，因为图层列表可能已变化
        invalidatePreviewCache();
        
        const container = document.getElementById('timelineTracks');
        const previewContainer = document.getElementById('timelinePreviewContainer');
        const previewArea = document.getElementById('timelinePreviewArea');
        container.innerHTML = '';
        previewContainer.innerHTML = ''; // Clear loading text
        
        // 如果是刷新，恢复保存的时间线数据
        if (preservedData) {
            // 清空当前数据，只保留仍然存在的图层数据
            const newTimelineData = {};
            layers.forEach(layer => {
                if (preservedData[layer.id]) {
                    newTimelineData[layer.id] = preservedData[layer.id];
                }
            });
            timelineData = newTimelineData;
        }
        
        layersForTimeline = layers;
        // Debug: Log received layers
        console.log('🕐 [时间线] 收到图层列表:', layers.map(l => ({ id: l.id, name: l.name, hasThumbnail: !!l.thumbnail, thumbLen: l.thumbnail ? l.thumbnail.length : 0 })));
        console.log('🕐 [时间线] Frame尺寸:', frameWidth, 'x', frameHeight);
        
        // Validate frame dimensions
        if (!frameWidth || !frameHeight || frameWidth <= 0 || frameHeight <= 0) {
            console.error('🕐 [时间线] 无效的Frame尺寸');
            previewContainer.innerHTML = '<div style="color: var(--preview-error); font-size: 13px;">' + t('timeline_no_frame_size') + '</div>';
            // Still render tracks
        }
        
        // Calculate preview scale to fit the container
        const previewAreaRect = previewArea.getBoundingClientRect();
        const availableWidth = Math.max(previewAreaRect.width - 40, 100); // padding, min 100
        const availableHeight = Math.max(previewAreaRect.height - 20, 100); // padding, min 100
        
        console.log('🕐 [时间线] 预览区可用尺寸:', availableWidth, 'x', availableHeight);
        
        // Calculate scale to fit frame within available space
        const scaleX = availableWidth / (frameWidth || 1);
        const scaleY = availableHeight / (frameHeight || 1);
        const scale = Math.min(scaleX, scaleY, 1); // Don't scale up, only down
        
        console.log('🕐 [时间线] 缩放比例:', scale);
        
        const scaledWidth = Math.max((frameWidth || 100) * scale, 50);
        const scaledHeight = Math.max((frameHeight || 100) * scale, 50);
        
        // Create a wrapper for the preview that represents the frame bounds
        const previewWrapper = document.createElement('div');
        previewWrapper.id = 'previewWrapper';
        previewWrapper.style.cssText = `
            position: relative;
            width: ${scaledWidth}px;
            height: ${scaledHeight}px;
            background: var(--track-bar-bg);
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        `;
        previewContainer.appendChild(previewWrapper);
        
        console.log('🕐 [时间线] 预览容器尺寸:', scaledWidth, 'x', scaledHeight);
        
        // Store scale for later use
        previewWrapper.dataset.scale = scale;
        previewWrapper.dataset.frameWidth = frameWidth;
        previewWrapper.dataset.frameHeight = frameHeight;
        
        // Initialize timelineData for new layers if not exists
        // Reverse layers so bottom layer is rendered first (painter's algorithm)
        const layersReversed = [...layers].reverse();
        
        layersReversed.forEach((layer, index) => {
            if (!timelineData[layer.id]) {
                timelineData[layer.id] = { start: 0, end: 100 }; // Percent
            }
            
            // Position layer correctly based on its x, y relative to frame
            const layerScale = scale;
            const scaledLayerWidth = Math.max((layer.width || 50) * layerScale, 1); // Min 1px to allow compression
            const scaledLayerHeight = Math.max((layer.height || 50) * layerScale, 1); // Min 1px to allow compression
            const scaledX = (layer.x || 0) * layerScale;
            const scaledY = (layer.y || 0) * layerScale;
            
            // Check if layer is within frame bounds
            const inBounds = scaledX >= -scaledLayerWidth && scaledX <= scaledWidth &&
                            scaledY >= -scaledLayerHeight && scaledY <= scaledHeight;
            
            console.log(`🕐 [时间线] 图层[${index}] "${layer.name}" (${layer.type}): pos(${scaledX.toFixed(1)}, ${scaledY.toFixed(1)}) size(${scaledLayerWidth.toFixed(1)}x${scaledLayerHeight.toFixed(1)}) hasThumb:${!!layer.thumbnail} inBounds:${inBounds}`);
            
            // z-index: In Figma, children[0] is BACK-most, children[last] is FRONT-most
            // After reversal: layersReversed[0] = FRONT-most (highest z), layersReversed[last] = BACK-most (lowest z)
            // So z-index should DECREASE with index
            const zIndex = layersReversed.length - index;
            
            // Create Preview Image with correct positioning
            if (layer.thumbnail && layer.thumbnail.length > 0) {
                const img = document.createElement('img');
                img.src = "data:image/png;base64," + layer.thumbnail;
                img.className = 'preview-layer';
                img.id = `preview-layer-${layer.id}`;
                
                // Set explicit z-index based on layer order
                img.style.cssText = `
                    position: absolute;
                    left: ${scaledX}px;
                    top: ${scaledY}px;
                    width: ${scaledLayerWidth}px;
                    height: ${scaledLayerHeight}px;
                    object-fit: fill;
                    opacity: 1;
                    visibility: visible;
                    z-index: ${zIndex};
                    pointer-events: none;
                `;
                
                img.onerror = () => console.error('🕐 [时间线] 图片加载失败:', layer.name);
                img.onload = () => console.log('🕐 [时间线] 图片加载成功:', layer.name, img.naturalWidth, 'x', img.naturalHeight);
                
                previewWrapper.appendChild(img);
            } else {
                // Create placeholder for layers without thumbnail
                console.warn('🕐 [时间线] 图层无缩略图:', layer.name);
                const placeholder = document.createElement('div');
                placeholder.id = `preview-layer-${layer.id}`;
                placeholder.style.cssText = `
                    position: absolute;
                    left: ${scaledX}px;
                    top: ${scaledY}px;
                    width: ${scaledLayerWidth}px;
                    height: ${scaledLayerHeight}px;
                    background: rgba(255,100,100,0.3);
                    border: 1px dashed var(--preview-error);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 10px;
                    color: var(--preview-error);
                    overflow: hidden;
                    z-index: ${zIndex};
                `;
                placeholder.textContent = layer.name.substring(0, 10);
                previewWrapper.appendChild(placeholder);
            }
        });

        // Debug: Log final preview wrapper state
        setTimeout(() => {
            const wrapper = document.getElementById('previewWrapper');
            if (wrapper) {
                const wrapperRect = wrapper.getBoundingClientRect();
                console.log('🕐 [时间线] 预览容器实际尺寸:', wrapperRect.width.toFixed(0), 'x', wrapperRect.height.toFixed(0));
                console.log('🕐 [时间线] 预览容器子元素数:', wrapper.children.length);
                
                // Log each child's position
                Array.from(wrapper.children).forEach((child, i) => {
                    const rect = child.getBoundingClientRect();
                    const style = window.getComputedStyle(child);
                    console.log(`🕐 [时间线] 子元素[${i}] id=${child.id}: rect(${rect.left.toFixed(0)},${rect.top.toFixed(0)} ${rect.width.toFixed(0)}x${rect.height.toFixed(0)}) opacity=${style.opacity} visible=${style.visibility}`);
                });
            }
        }, 500);

        // Render track rows (in original order - top layer first)
        layers.forEach(layer => {
            const row = document.createElement('div');
            row.className = 'timeline-track-row';
            
            const label = document.createElement('div');
            label.className = 'track-label';
            label.id = `track-label-${layer.id}`;
            label.textContent = layer.name;
            label.title = layer.name;
            
            const trackArea = document.createElement('div');
            trackArea.className = 'track-area';
            
            const bar = document.createElement('div');
            bar.className = 'track-bar';
            bar.id = `track-bar-${layer.id}`;
            
            // 创建胶片帧容器 - 固定宽度，通过偏移实现裁剪效果
            const filmstrip = document.createElement('div');
            filmstrip.className = 'track-bar-filmstrip';
            filmstrip.id = `filmstrip-${layer.id}`;
            
            // 添加5个帧占位符
            for (let i = 0; i < 5; i++) {
                const frame = document.createElement('div');
                frame.className = 'track-bar-frame';
                frame.id = `frame-${layer.id}-${i}`;
                // 初始使用缩略图作为背景
                if (layer.thumbnail) {
                    frame.style.backgroundImage = `url(data:image/png;base64,${layer.thumbnail})`;
                } else {
                    frame.style.background = '#444';
                }
                filmstrip.appendChild(frame);
            }
            
            bar.appendChild(filmstrip);
            
            // Initial position
            const data = timelineData[layer.id];
            bar.style.left = `${data.start}%`;
            bar.style.width = `${data.end - data.start}%`;
            
            // 设置filmstrip宽度为track-area的100%，并偏移以保持固定位置
            // 使用延迟确保track-area已渲染
            requestAnimationFrame(() => {
                const trackAreaWidth = trackArea.offsetWidth;
                filmstrip.style.width = trackAreaWidth + 'px';
                // 偏移量 = -(bar的left百分比 * track-area宽度)
                const offsetLeft = -(data.start / 100) * trackAreaWidth;
                filmstrip.style.left = offsetLeft + 'px';
            });
            
            // Handles
            const leftHandle = document.createElement('div');
            leftHandle.className = 'track-handle left';
            
            const rightHandle = document.createElement('div');
            rightHandle.className = 'track-handle right';
            
            bar.appendChild(leftHandle);
            bar.appendChild(rightHandle);
            trackArea.appendChild(bar);
            
            row.appendChild(label);
            row.appendChild(trackArea);
            container.appendChild(row);
            
            // Add Drag Logic
            setupTrackDrag(bar, leftHandle, rightHandle, trackArea, layer.id);
        });
        
        // Update Preview based on current time (preserve position if already set)
        // Show scrubber now that tracks are rendered
        const scrubber = document.getElementById('timelineScrubber');
        if (scrubber) scrubber.style.display = 'block';
        
        // 保持当前的时间位置（如果是刷新），否则定位到有效覆盖区域的第一帧
        const preserveTime = preservedData !== null && currentScrubTime > 0;
        const coverage = getTimelineCoverageRange();
        const initialProgress = preserveTime ? currentScrubTime : coverage.start;
        updatePreview(initialProgress);
        setupScrubber();
        
        // Request frame extraction for video layers
        layerFrames = {}; // Clear previous frames
        const videoLayers = layers.filter(l => l.isVideoLayer);
        console.log('🎞️ [时间线] 视频图层检测:', {
            total: layers.length,
            videoLayers: videoLayers.length,
            details: layers.map(l => ({ name: l.name, isVideo: l.isVideoLayer, videoId: l.videoId }))
        });
        
        if (videoLayers.length > 0 && ws && ws.readyState === 1) {
            // 区分已绑定和未绑定的视频图层
            const boundLayers = videoLayers.filter(l => l.gifCacheId);
            const unboundLayers = videoLayers.filter(l => !l.gifCacheId);
            
            if (unboundLayers.length > 0) {
                console.warn('🎞️ [时间线] ⚠️ 以下视频图层缺少 gifCacheId，无法提取帧:', 
                    unboundLayers.map(l => l.name));
            }
            
            console.log('🎞️ [时间线] 请求帧提取:', boundLayers.map(l => `${l.name} (🔑${l.gifCacheId.substring(0,8)})`));
            boundLayers.forEach(layer => {
                wsSend('extract-preview-frames', {
                    layerId: layer.id,
                    layerName: layer.name,
                    originalFilename: layer.originalFilename || null,
                    gifCacheId: layer.gifCacheId,
                    frameCount: 120
                });
            });
        } else {
            console.log('🎞️ [时间线] 无视频图层或WebSocket未连接', {
                videoLayerCount: videoLayers.length,
                wsReady: ws ? ws.readyState : 'null'
            });
        }
    }
    
    // Handle preview frames response
    function handlePreviewFramesResult(data) {
        if (data.success && data.frames && data.frames.length > 0) {
            console.log(`🎞️ [时间线] 收到帧数据: layerId=${data.layerId}, 帧数=${data.frames.length}, 时长=${data.duration}s`);
            layerFrames[data.layerId] = data.frames;
            
            // 存储视频时长到图层数据
            if (data.duration) {
                const layerData = layersForTimeline.find(l => l.id === data.layerId);
                if (layerData) {
                    layerData.duration = data.duration;
                }
                
                // 更新全局时长（使用最长的视频时长）
                // 始终使用实际视频时长，覆盖默认值
                if (data.duration > 0 && (data.duration > timelineTotalDuration || timelineTotalDuration <= 0.1)) {
                    timelineTotalDuration = data.duration;
                    console.log(`🎞️ [时间线] 更新总时长: ${data.duration.toFixed(2)}秒`);
                }
            }
            
            // 更新胶片条的帧缩略图（使用5个均匀分布的帧）
            const frames = data.frames;
            const filmstripFrameCount = 5;
            for (let i = 0; i < filmstripFrameCount; i++) {
                const frameEl = document.getElementById(`frame-${data.layerId}-${i}`);
                if (frameEl && frames.length > 0) {
                    // 计算要显示的帧索引（均匀分布）
                    const targetPercent = (i / (filmstripFrameCount - 1)) * 100;
                    // 找到最接近的帧
                    let closestFrame = frames[0];
                    let minDiff = Math.abs(targetPercent - frames[0].percent);
                    for (const frame of frames) {
                        const diff = Math.abs(targetPercent - frame.percent);
                        if (diff < minDiff) {
                            minDiff = diff;
                            closestFrame = frame;
                        }
                    }
                    frameEl.style.backgroundImage = `url(data:image/png;base64,${closestFrame.data})`;
                }
            }
            
            // Update preview with new frames
            updatePreview(currentScrubTime);
        } else {
            console.warn(`🎞️ [时间线] 帧提取失败: layerId=${data.layerId}, error=${data.error}`);
        }
    }
    
    let currentScrubTime = 0; // 0-100

    // 缓存 DOM 元素引用，避免每帧重复查询
    let cachedPreviewElements = null;
    let cachedScrubberLayout = null;
    
    function invalidatePreviewCache() {
        cachedPreviewElements = null;
        cachedScrubberLayout = null;
    }
    
    function updatePreview(progress) {
        currentScrubTime = progress;
        
        // 懒加载缓存 DOM 元素
        if (!cachedPreviewElements) {
            cachedPreviewElements = {
                fullscreenFill: document.getElementById('fullscreenProgressFill'),
                fullscreenText: document.getElementById('fullscreenProgressText'),
                fullscreenThumb: document.getElementById('fullscreenProgressThumb'),
                scrubber: document.getElementById('timelineScrubber'),
                tracksScroll: document.getElementById('timelineTracksScroll'),
                layerImgs: {}
            };
            // 预缓存所有图层图片元素
            layersForTimeline.forEach(layer => {
                cachedPreviewElements.layerImgs[layer.id] = document.getElementById(`preview-layer-${layer.id}`);
            });
        }
        
        const { fullscreenFill, fullscreenText, fullscreenThumb, scrubber, tracksScroll } = cachedPreviewElements;
        
        // Update fullscreen progress if visible
        if (fullscreenFill) fullscreenFill.style.width = progress + '%';
        if (fullscreenText) {
            // Update the time display - first span is current time
            const currentTimeSpan = fullscreenText.querySelector('span:first-child');
            const totalTimeSpan = document.getElementById('fullscreenTotalTime');
            if (currentTimeSpan) currentTimeSpan.textContent = getTimeFromProgress(progress);
            if (totalTimeSpan) totalTimeSpan.textContent = formatTotalDuration();
        }
        if (fullscreenThumb) fullscreenThumb.style.left = progress + '%';
        
        // Move scrubber line - 只在布局变化时重新计算
        if (scrubber) {
            const firstTrackArea = document.querySelector('.track-area');
            if (firstTrackArea && tracksScroll) {
                const scrollRect = tracksScroll.getBoundingClientRect();
                const trackRect = firstTrackArea.getBoundingClientRect();
                
                // 如果 track area 已渲染且有宽度
                if (trackRect.width > 0) {
                    // 尝试使用缓存，或者直接计算
                    let trackLeftOffset, trackWidth;
                    
                    if (cachedScrubberLayout && cachedScrubberLayout.trackWidth > 0) {
                        trackLeftOffset = cachedScrubberLayout.trackLeftOffset;
                        trackWidth = cachedScrubberLayout.trackWidth;
                    } else {
                        // 计算并缓存
                        trackLeftOffset = trackRect.left - scrollRect.left;
                        trackWidth = trackRect.width;
                        cachedScrubberLayout = { trackLeftOffset, trackWidth };
                    }
                    
                    const scrubberLeft = trackLeftOffset + (progress / 100) * trackWidth;
                    scrubber.style.left = scrubberLeft + 'px';
                }
            }
        }

        // Update layer visibility and frames based on timeline
        const layerCount = layersForTimeline.length;
        for (let i = 0; i < layerCount; i++) {
            const layer = layersForTimeline[i];
            const range = timelineData[layer.id];
            if (!range) continue;
            
            const img = cachedPreviewElements.layerImgs[layer.id];
            if (!img) continue;
            
            // If current progress is within start and end, show it
            const shouldShow = progress >= range.start && progress <= range.end;
            
            // Update visibility - 使用 CSS class 切换代替直接样式操作
            if (shouldShow) {
                if (img.style.visibility !== 'visible') {
                    img.style.opacity = '1';
                    img.style.visibility = 'visible';
                }
                
                // Update frame for video layers - 使用二分查找
                const frames = layerFrames[layer.id];
                if (layer.isVideoLayer && frames && frames.length > 0) {
                    // 二分查找最近的帧
                    const closestFrame = findClosestFrame(frames, progress);
                    
                    // 只在帧变化时更新 src（避免重复设置相同图片）
                    if (img._currentFrameIndex !== closestFrame.index) {
                        img._currentFrameIndex = closestFrame.index;
                        img.src = "data:image/png;base64," + closestFrame.data;
                    }
                }
            } else {
                if (img.style.visibility !== 'hidden') {
                    img.style.opacity = '0';
                    img.style.visibility = 'hidden';
                }
            }
        }
    }
    
    // 二分查找最近的帧（O(log n) 复杂度）
    function findClosestFrame(frames, targetPercent) {
        if (frames.length === 1) return { ...frames[0], index: 0 };
        
        let left = 0;
        let right = frames.length - 1;
        
        while (left < right - 1) {
            const mid = Math.floor((left + right) / 2);
            if (frames[mid].percent <= targetPercent) {
                left = mid;
            } else {
                right = mid;
            }
        }
        
        // 比较 left 和 right 哪个更近
        const leftDiff = Math.abs(frames[left].percent - targetPercent);
        const rightDiff = Math.abs(frames[right].percent - targetPercent);
        
        if (leftDiff <= rightDiff) {
            return { ...frames[left], index: left };
        } else {
            return { ...frames[right], index: right };
        }
    }

    // 更新 scrubber 高度以覆盖所有图层（全局函数，可在图层变化时调用）
    function updateScrubberHeight() {
        const scrubber = document.getElementById('timelineScrubber');
        const timelineTracks = document.getElementById('timelineTracks');
        if (scrubber && timelineTracks) {
            // 使用 timelineTracks 的实际高度（包括所有图层）
            const tracksHeight = timelineTracks.scrollHeight;
            scrubber.style.height = Math.max(tracksHeight, 100) + 'px';
        }
    }
    
    function setupScrubber() {
        const scrubber = document.getElementById('timelineScrubber');
        const scrubberHandle = document.getElementById('timelineScrubberHandle');
        const tracksScroll = document.getElementById('timelineTracksScroll');
        
        let isDraggingScrubber = false;

        function onHandleMouseDown(e) {
            isDraggingScrubber = true;
            updateScrubberFromEvent(e);
            document.body.style.cursor = 'ew-resize';
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            e.preventDefault();
            e.stopPropagation();
        }
        
        function onTrackAreaMouseDown(e) {
            // 检查是否点击在拖拽条或其子元素上
            const target = e.target;
            const isOnBar = target.classList.contains('track-bar') || 
                           target.classList.contains('track-handle') ||
                           target.classList.contains('track-bar-filmstrip') ||
                           target.classList.contains('track-bar-frame') ||
                           target.closest('.track-bar');
            
            // 只在非拖拽条区域响应（track-area 空白处、容器等）
            if (!isOnBar) {
                isDraggingScrubber = true;
                updateScrubberFromEvent(e);
                document.body.style.cursor = 'ew-resize';
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
                e.preventDefault();
            }
        }

        function onMouseMove(e) {
            if (!isDraggingScrubber) return;
            e.preventDefault();
            updateScrubberFromEvent(e);
        }

        function onMouseUp() {
            isDraggingScrubber = false;
            document.body.style.cursor = '';
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        }

        function updateScrubberFromEvent(e) {
            const firstRow = document.querySelector('.track-area');
            if (!firstRow) return;
            
            const trackRect = firstRow.getBoundingClientRect();
            let relativeX = e.clientX - trackRect.left;
            let percent = (relativeX / trackRect.width) * 100;
            
            // 🎬 限制在有效覆盖范围内（不允许滑到没有图层的空白区域）
            const coverage = getTimelineCoverageRange();
            percent = Math.max(coverage.start, Math.min(coverage.end, percent));
            updatePreview(percent);
        }

        // 只给 handle 添加拖拽事件
        if (scrubberHandle) {
            if (scrubberHandle._abortController) {
                scrubberHandle._abortController.abort();
            }
            scrubberHandle._abortController = new AbortController();
            
            scrubberHandle.addEventListener('mousedown', onHandleMouseDown, { signal: scrubberHandle._abortController.signal });
        }
        
        // 更新 scrubber 高度
        if (scrubber) {
            requestAnimationFrame(() => {
                updateScrubberHeight();
                requestAnimationFrame(updateScrubberHeight);
            });
            
            invalidatePreviewCache();
        }
        
        // 在 tracksScroll 上监听 mousedown，只在非拖拽条区域响应
        if (tracksScroll) {
            if (tracksScroll._mouseAbortController) {
                tracksScroll._mouseAbortController.abort();
            }
            tracksScroll._mouseAbortController = new AbortController();
            
            tracksScroll.addEventListener('mousedown', onTrackAreaMouseDown, { signal: tracksScroll._mouseAbortController.signal });
        }
    }
    
    // ==========================================
    // 时间线播放控制
    // ==========================================
    let isTimelinePlaying = false;
    let playbackAnimationId = null;
    const DEFAULT_FRAME_RATE = 60; // 默认帧率提升到60fps
    let timelineFrameRate = DEFAULT_FRAME_RATE;
    let timelineTotalDuration = 0; // 总时长（秒），0 表示尚未获取到实际时长
    
    function getTimelineFrameRate() {
        return timelineFrameRate;
    }
    
    // 格式化时间为 MM:SS:FF 格式（帧率假设为30fps）
    function formatTimeCode(seconds, fps = 30) {
        const totalFrames = Math.round(seconds * fps);
        const frames = totalFrames % fps;
        const totalSeconds = Math.floor(totalFrames / fps);
        const secs = totalSeconds % 60;
        const mins = Math.floor(totalSeconds / 60);
        
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}:${frames.toString().padStart(2, '0')}`;
    }
    
    // 根据进度百分比计算当前时间
    function getTimeFromProgress(progress) {
        const currentSeconds = (progress / 100) * timelineTotalDuration;
        return formatTimeCode(currentSeconds);
    }
    
    // 格式化总时长显示
    function formatTotalDuration() {
        return formatTimeCode(timelineTotalDuration);
    }
    
    // 🎬 计算所有图层的有效覆盖范围（最小 start ~ 最大 end）
    // 用于播放裁剪和导出裁剪
    function getTimelineCoverageRange() {
        let minStart = 100;
        let maxEnd = 0;
        const layerIds = Object.keys(timelineData);
        
        if (layerIds.length === 0) return { start: 0, end: 100 };
        
        for (const id of layerIds) {
            const range = timelineData[id];
            if (range) {
                minStart = Math.min(minStart, range.start);
                maxEnd = Math.max(maxEnd, range.end);
            }
        }
        
        // 安全检查
        if (minStart >= maxEnd) return { start: 0, end: 100 };
        return { start: minStart, end: maxEnd };
    }
    
    function startTimelinePlayback() {
        if (isTimelinePlaying) return;
        isTimelinePlaying = true;
        
        // 使用已经从服务器获取的实际时长
        // 如果还没有获取到（仍然是默认值），尝试从图层数据中获取
        let estimatedDuration = 0;
        
        // 检查是否有视频图层的时长信息
        for (const layer of layersForTimeline) {
            if (layer.isVideoLayer && layer.duration && layer.duration > 0) {
                estimatedDuration = Math.max(estimatedDuration, layer.duration);
            }
        }
        
        // 如果没有找到视频时长，使用已有的全局时长（可能已被 preview-frames-result 更新）
        if (estimatedDuration <= 0) {
            estimatedDuration = timelineTotalDuration > 0 && timelineTotalDuration !== 10 
                ? timelineTotalDuration 
                : 3; // 最终兜底：3秒（GIF通常较短）
        }
        
        // 更新全局时长变量
        timelineTotalDuration = estimatedDuration;
        
        // 🎬 计算有效播放范围（跳过所有图层都不覆盖的头尾空白）
        const coverage = getTimelineCoverageRange();
        const playStart = coverage.start;  // 播放起点（百分比）
        const playEnd = coverage.end;      // 播放终点（百分比）
        const playRange = playEnd - playStart; // 有效播放范围宽度
        
        // 基于有效范围计算播放速度
        // 有效时长 = 总时长 × (有效范围 / 100)
        const effectiveDuration = estimatedDuration * (playRange / 100);
        const progressPerSecond = playRange / effectiveDuration; // 等效于 100 / estimatedDuration
        
        // 如果当前位置不在有效范围内，跳到起点
        if (currentScrubTime < playStart || currentScrubTime > playEnd) {
            currentScrubTime = playStart;
        }
        
        let lastTimestamp = null;
        
        function animate(timestamp) {
            if (!isTimelinePlaying) return;
            
            if (lastTimestamp === null) {
                lastTimestamp = timestamp;
            }
            
            // 计算时间差（毫秒转秒）
            const deltaSeconds = (timestamp - lastTimestamp) / 1000;
            lastTimestamp = timestamp;
            
            // 更新进度
            let newProgress = currentScrubTime + (progressPerSecond * deltaSeconds);
            
            // 🎬 循环播放：超过有效终点时回到有效起点
            if (newProgress >= playEnd) {
                newProgress = playStart;
                lastTimestamp = timestamp;
            }
            
            updatePreview(newProgress);
            
            // 继续下一帧
            playbackAnimationId = requestAnimationFrame(animate);
        }
        
        playbackAnimationId = requestAnimationFrame(animate);
    }
    
    function stopTimelinePlayback() {
        isTimelinePlaying = false;
        if (playbackAnimationId) {
            cancelAnimationFrame(playbackAnimationId);
            playbackAnimationId = null;
        }
    }
    
    function toggleTimelinePlayback() {
        if (isTimelinePlaying) {
            stopTimelinePlayback();
        } else {
            startTimelinePlayback();
        }
    }
    
    // 空格键播放/暂停
    document.addEventListener('keydown', (e) => {
        // 检查时间线编辑器或全屏预览是否打开
        const timelineOverlay = document.getElementById('timelineEditorOverlay');
        const fullscreenOverlay = document.getElementById('timelineFullscreenOverlay');
        
        const isTimelineOpen = timelineOverlay && timelineOverlay.classList.contains('show');
        const isFullscreenOpen = fullscreenOverlay && fullscreenOverlay.classList.contains('show');
        
        // 空格键：支持 e.code 和 e.key 两种方式，兼容不同键盘布局
        const isSpaceKey = e.code === 'Space' || e.key === ' ' || e.keyCode === 32;
        
        if ((isTimelineOpen || isFullscreenOpen) && isSpaceKey) {
            // 如果焦点在输入框，不拦截空格
            const activeEl = document.activeElement;
            if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) {
                return;
            }
            
            e.preventDefault();
            e.stopPropagation();
            toggleTimelinePlayback();
        }
        
        // 左右方向键：逐帧前进/后退
        const isLeftKey = e.code === 'ArrowLeft' || e.key === 'ArrowLeft';
        const isRightKey = e.code === 'ArrowRight' || e.key === 'ArrowRight';
        
        if ((isTimelineOpen || isFullscreenOpen) && (isLeftKey || isRightKey)) {
            const activeEl = document.activeElement;
            if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) {
                return;
            }
            
            e.preventDefault();
            e.stopPropagation();
            
            // 如果正在播放，先暂停
            if (isTimelinePlaying) {
                stopTimelinePlayback();
            }
            
            // 计算一帧对应的百分比步长
            const fps = getTimelineFrameRate() || 30;
            const duration = timelineTotalDuration || 1;
            const frameStep = (1 / fps / duration) * 100;
            
            const coverage = getTimelineCoverageRange();
            let newProgress = currentScrubTime + (isRightKey ? frameStep : -frameStep);
            newProgress = Math.max(coverage.start, Math.min(coverage.end, newProgress));
            
            updatePreview(newProgress);
        }
        
        // ESC 关闭全屏
        if (isFullscreenOpen && (e.code === 'Escape' || e.key === 'Escape')) {
            e.preventDefault();
            closeFullscreenPreview();
        }
    }, true); // 使用捕获阶段，优先处理
    
    // ==========================================
    // 全屏预览功能
    // ==========================================
    let fullscreenFrameWidth = 0;
    let fullscreenFrameHeight = 0;
    
    function openFullscreenPreview() {
        // 清除全屏预览缓存
        invalidateFullscreenCache();
        
        const overlay = document.getElementById('timelineFullscreenOverlay');
        const container = document.getElementById('fullscreenPreviewContainer');
        
        if (!overlay || !container) return;
        
        // 复制预览内容到全屏容器
        const previewWrapper = document.getElementById('previewWrapper');
        if (previewWrapper) {
            // 获取原始尺寸
            const originalWidth = parseFloat(previewWrapper.style.width) || 100;
            const originalHeight = parseFloat(previewWrapper.style.height) || 100;
            
            // 计算全屏缩放
            const maxWidth = window.innerWidth * 0.85;
            const maxHeight = window.innerHeight * 0.75;
            const scale = Math.min(maxWidth / originalWidth, maxHeight / originalHeight, 3);
            
            fullscreenFrameWidth = originalWidth * scale;
            fullscreenFrameHeight = originalHeight * scale;
            
            // 创建全屏预览包装器
            container.innerHTML = '';
            const fullscreenWrapper = document.createElement('div');
            fullscreenWrapper.id = 'fullscreenPreviewWrapper';
            fullscreenWrapper.style.cssText = `
                position: relative;
                width: ${fullscreenFrameWidth}px;
                height: ${fullscreenFrameHeight}px;
                background: var(--track-bar-bg);
                overflow: hidden;
                box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            `;
            
            // 复制每个图层
            layersForTimeline.forEach((layer, index) => {
                const originalImg = document.getElementById(`preview-layer-${layer.id}`);
                if (originalImg) {
                    const clonedImg = originalImg.cloneNode(true);
                    clonedImg.id = `fullscreen-layer-${layer.id}`;
                    
                    // 重新计算位置和尺寸
                    const origLeft = parseFloat(originalImg.style.left) || 0;
                    const origTop = parseFloat(originalImg.style.top) || 0;
                    const origWidth = parseFloat(originalImg.style.width) || 50;
                    const origHeight = parseFloat(originalImg.style.height) || 50;
                    
                    const scaleRatio = fullscreenFrameWidth / originalWidth;
                    clonedImg.style.left = (origLeft * scaleRatio) + 'px';
                    clonedImg.style.top = (origTop * scaleRatio) + 'px';
                    clonedImg.style.width = (origWidth * scaleRatio) + 'px';
                    clonedImg.style.height = (origHeight * scaleRatio) + 'px';
                    
                    fullscreenWrapper.appendChild(clonedImg);
                }
            });
            
            container.appendChild(fullscreenWrapper);
        }
        
        // 更新进度条和滑块
        const fill = document.getElementById('fullscreenProgressFill');
        const text = document.getElementById('fullscreenProgressText');
        const thumb = document.getElementById('fullscreenProgressThumb');
        if (fill) fill.style.width = currentScrubTime + '%';
        if (text) {
            const currentTimeSpan = text.querySelector('span:first-child');
            const totalTimeSpan = document.getElementById('fullscreenTotalTime');
            if (currentTimeSpan) currentTimeSpan.textContent = getTimeFromProgress(currentScrubTime);
            if (totalTimeSpan) totalTimeSpan.textContent = formatTotalDuration();
        }
        if (thumb) thumb.style.left = currentScrubTime + '%';
        
        overlay.classList.add('show');
    }
    
    function closeFullscreenPreview() {
        stopTimelinePlayback();
        const overlay = document.getElementById('timelineFullscreenOverlay');
        if (overlay) {
            overlay.classList.remove('show');
        }
    }
    
    // 缓存全屏预览的 DOM 元素
    let cachedFullscreenElements = null;
    
    function invalidateFullscreenCache() {
        cachedFullscreenElements = null;
    }
    
    function updateFullscreenPreview(progress) {
        // 懒加载缓存
        if (!cachedFullscreenElements) {
            cachedFullscreenElements = {};
            layersForTimeline.forEach(layer => {
                cachedFullscreenElements[layer.id] = document.getElementById(`fullscreen-layer-${layer.id}`);
            });
        }
        
        // 更新全屏预览中的图层可见性
        const layerCount = layersForTimeline.length;
        for (let i = 0; i < layerCount; i++) {
            const layer = layersForTimeline[i];
            const range = timelineData[layer.id];
            if (!range) continue;
            
            const fullscreenImg = cachedFullscreenElements[layer.id];
            if (!fullscreenImg) continue;
            
            const shouldShow = progress >= range.start && progress <= range.end;
            
            if (shouldShow) {
                if (fullscreenImg.style.visibility !== 'visible') {
                    fullscreenImg.style.opacity = '1';
                    fullscreenImg.style.visibility = 'visible';
                }
                
                // 更新帧（如果有帧数据）- 使用二分查找
                const frames = layerFrames[layer.id];
                if (layer.isVideoLayer && frames && frames.length > 0) {
                    const closestFrame = findClosestFrame(frames, progress);
                    
                    if (fullscreenImg._currentFrameIndex !== closestFrame.index) {
                        fullscreenImg._currentFrameIndex = closestFrame.index;
                        fullscreenImg.src = "data:image/png;base64," + closestFrame.data;
                    }
                }
            } else {
                if (fullscreenImg.style.visibility !== 'hidden') {
                    fullscreenImg.style.opacity = '0';
                    fullscreenImg.style.visibility = 'hidden';
                }
            }
        }
    }
    
    // 修改 updatePreview 也更新全屏预览
    const originalUpdatePreview = updatePreview;
    updatePreview = function(progress) {
        originalUpdatePreview(progress);
        
        // 如果全屏预览打开，也更新它
        const fullscreenOverlay = document.getElementById('timelineFullscreenOverlay');
        if (fullscreenOverlay && fullscreenOverlay.classList.contains('show')) {
            updateFullscreenPreview(progress);
        }
    };
    
    // 点击预览区进入全屏
    document.getElementById('timelinePreviewArea').onclick = openFullscreenPreview;
    document.getElementById('timelineFullscreenClose').onclick = closeFullscreenPreview;
    
    // 全屏进度条点击跳转
    document.getElementById('fullscreenProgressBar').onclick = function(e) {
        // 如果点击的是滑块本身，不处理（由拖拽逻辑处理）
        if (e.target.id === 'fullscreenProgressThumb') return;
        
        const rect = this.getBoundingClientRect();
        let percent = ((e.clientX - rect.left) / rect.width) * 100;
        // 🎬 限制在有效覆盖范围内
        const coverage = getTimelineCoverageRange();
        percent = Math.max(coverage.start, Math.min(coverage.end, percent));
        updatePreview(percent);
    };
    
    // 全屏进度条滑块拖拽
    (function() {
        const thumb = document.getElementById('fullscreenProgressThumb');
        const progressBar = document.getElementById('fullscreenProgressBar');
        let isDragging = false;
        
        function updateFromEvent(e) {
            const rect = progressBar.getBoundingClientRect();
            let percent = ((e.clientX - rect.left) / rect.width) * 100;
            // 🎬 限制在有效覆盖范围内
            const coverage = getTimelineCoverageRange();
            percent = Math.max(coverage.start, Math.min(coverage.end, percent));
            updatePreview(percent);
        }
        
        thumb.addEventListener('mousedown', function(e) {
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            thumb.style.cursor = 'grabbing';
            thumb.style.transform = 'translate(-50%, -50%) scale(1.2)';
            document.body.style.cursor = 'grabbing';
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });
        
        function onMouseMove(e) {
            if (!isDragging) return;
            e.preventDefault();
            updateFromEvent(e);
        }
        
        function onMouseUp(e) {
            if (!isDragging) return;
            isDragging = false;
            thumb.style.cursor = 'grab';
            thumb.style.transform = 'translate(-50%, -50%)';
            document.body.style.cursor = '';
            
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        }
        
        // 悬停效果
        thumb.addEventListener('mouseenter', function() {
            if (!isDragging) {
                thumb.style.transform = 'translate(-50%, -50%) scale(1.1)';
            }
        });
        
        thumb.addEventListener('mouseleave', function() {
            if (!isDragging) {
                thumb.style.transform = 'translate(-50%, -50%)';
            }
        });
    })();
    
    // 5. Handle messages from code.js
    window.addEventListener('message', (event) => {
        const msg = event.data.pluginMessage;
        if (msg && msg.type === 'timeline-layers-response') {
            // 存储 Frame ID 供导出时使用
            if (msg.frameId) {
                timelineFrameId = msg.frameId;
            }
            // Updated to handle frame dimensions if needed
            renderTimeline(msg.layers, msg.frameWidth, msg.frameHeight);
        }
        
        // 处理图层位置实时更新
        if (msg && msg.type === 'timeline-layer-positions-updated') {
            updatePreviewLayerPositions(msg.updates, msg.frameWidth, msg.frameHeight);
        }
        
        // 处理图层缩略图实时更新（样式变化后）
        if (msg && msg.type === 'timeline-layer-thumbnails-updated') {
            updateLayerThumbnails(msg.updates);
        }
        
        // 处理图层名称实时更新（用户重命名图层）
        if (msg && msg.type === 'timeline-layer-names-updated') {
            updateTimelineLayerNames(msg.updates);
        }
        
        // 处理图层增删/重排序（实时刷新整个时间线）
        if (msg && msg.type === 'timeline-layers-refresh') {
            refreshTimelineWithNewLayers(msg.layers, msg.frameWidth, msg.frameHeight);
        }
    });
    
    // 更新预览区图层位置（实时响应 Figma 画板中的移动）
    function updatePreviewLayerPositions(updates, frameWidth, frameHeight) {
        const previewWrapper = document.getElementById('previewWrapper');
        if (!previewWrapper) return;
        
        // 获取当前预览区的缩放比例
        const previewArea = document.getElementById('timelinePreviewArea');
        if (!previewArea) return;
        
        const previewAreaRect = previewArea.getBoundingClientRect();
        const availableWidth = Math.max(previewAreaRect.width - 40, 100);
        const availableHeight = Math.max(previewAreaRect.height - 20, 100);
        
        const scaleX = availableWidth / (frameWidth || 1);
        const scaleY = availableHeight / (frameHeight || 1);
        const scale = Math.min(scaleX, scaleY, 1);
        
        // 获取全屏预览的缩放比例（如果全屏预览已打开）
        const fullscreenWrapper = document.getElementById('fullscreenPreviewWrapper');
        let fullscreenScale = 1;
        if (fullscreenWrapper && previewWrapper) {
            const fullscreenWidth = parseFloat(fullscreenWrapper.style.width) || 1;
            const previewWidth = parseFloat(previewWrapper.style.width) || 1;
            fullscreenScale = fullscreenWidth / previewWidth;
        }
        
        // 更新每个图层的位置
        for (const update of updates) {
            const layerEl = document.getElementById(`preview-layer-${update.id}`);
            if (layerEl) {
                const scaledX = (update.x || 0) * scale;
                const scaledY = (update.y || 0) * scale;
                const scaledWidth = Math.max((update.width || 50) * scale, 1); // Min 1px to allow compression
                const scaledHeight = Math.max((update.height || 50) * scale, 1); // Min 1px to allow compression
                
                layerEl.style.left = scaledX + 'px';
                layerEl.style.top = scaledY + 'px';
                layerEl.style.width = scaledWidth + 'px';
                layerEl.style.height = scaledHeight + 'px';
                
                // 同步更新全屏预览图层（如果存在）
                const fullscreenEl = document.getElementById(`fullscreen-layer-${update.id}`);
                if (fullscreenEl) {
                    fullscreenEl.style.left = (scaledX * fullscreenScale) + 'px';
                    fullscreenEl.style.top = (scaledY * fullscreenScale) + 'px';
                    fullscreenEl.style.width = (scaledWidth * fullscreenScale) + 'px';
                    fullscreenEl.style.height = (scaledHeight * fullscreenScale) + 'px';
                }
            }
            
            // 同时更新 layersForTimeline 中的数据
            const layerData = layersForTimeline.find(l => l.id === update.id);
            if (layerData) {
                layerData.x = update.x;
                layerData.y = update.y;
                layerData.width = update.width;
                layerData.height = update.height;
            }
        }
    }
    
    // 刷新时间线（图层增删/重排序后调用）
    function refreshTimelineWithNewLayers(newLayers, frameWidth, frameHeight) {
        console.log('🕐 [时间线] 图层结构变化，刷新时间线，新图层数:', newLayers.length);
        
        // 保存现有的时间线数据（开始/结束时间）
        const preservedTimelineData = { ...timelineData };
        
        // 清除所有缓存
        invalidatePreviewCache();
        invalidateFullscreenCache();
        
        // 更新全局变量
        layersForTimeline = newLayers;
        
        // 重新渲染整个时间线，但保留已有图层的时间数据
        renderTimeline(newLayers, frameWidth, frameHeight, preservedTimelineData);
        
        // 如果全屏预览正在显示，也需要刷新
        const fullscreenOverlay = document.getElementById('timelineFullscreenOverlay');
        if (fullscreenOverlay && fullscreenOverlay.classList.contains('show')) {
            // 延迟刷新全屏预览，确保主预览已渲染完成
            requestAnimationFrame(() => {
                openFullscreenPreview();
            });
        }
    }
    
    // 更新图层缩略图（样式变化后实时更新）
    function updateLayerThumbnails(updates) {
        for (const update of updates) {
            const thumbDataUrl = `data:image/png;base64,${update.thumbnail}`;
            
            // 1. 更新预览区的图层图片
            const previewImg = document.getElementById(`preview-layer-${update.id}`);
            if (previewImg && previewImg.tagName === 'IMG') {
                previewImg.src = thumbDataUrl;
            }
            
            // 2. 更新拖拽条的胶片帧
            for (let i = 0; i < 5; i++) {
                const frame = document.getElementById(`frame-${update.id}-${i}`);
                if (frame) {
                    frame.style.backgroundImage = `url(${thumbDataUrl})`;
                }
            }
            
            // 3. 更新 layersForTimeline 中的缩略图数据
            const layerData = layersForTimeline.find(l => l.id === update.id);
            if (layerData) {
                layerData.thumbnail = update.thumbnail;
            }
            
            // 4. 更新全屏预览（如果已打开）
            const fullscreenImg = document.getElementById(`fullscreen-layer-${update.id}`);
            if (fullscreenImg && fullscreenImg.tagName === 'IMG') {
                fullscreenImg.src = thumbDataUrl;
            }
        }
    }

    // 更新图层名称（用户重命名图层后实时更新）
    function updateTimelineLayerNames(updates) {
        for (const update of updates) {
            // 1. 更新轨道行的标签
            const label = document.getElementById(`track-label-${update.id}`);
            if (label) {
                label.textContent = update.name;
                label.title = update.name;
            }
            
            // 2. 更新 layersForTimeline 缓存中的名称（保留 originalFilename 不变）
            const layerData = layersForTimeline.find(l => l.id === update.id);
            if (layerData) {
                layerData.name = update.name;
            }
            
            // 3. 更新全屏预览中的图层名称（如果已打开）
            const fullscreenLabel = document.querySelector(`#fullscreenPreviewWrapper [data-layer-id="${update.id}"]`);
            if (fullscreenLabel) {
                fullscreenLabel.textContent = update.name;
            }
        }
        
        // 4. 刷新 DOM 缓存并强制重绘预览，防止多次改名后缓存引用过期
        invalidatePreviewCache();
        updatePreview(currentScrubTime);
    }
    
    // 吸附阈值（百分比）
    const SNAP_THRESHOLD = 2.5;
    
    // 检查是否应该吸附到时间线位置
    function snapToPlayhead(value) {
        const scrubberPos = currentScrubTime;
        if (Math.abs(value - scrubberPos) <= SNAP_THRESHOLD) {
            return { snapped: true, value: scrubberPos };
        }
        return { snapped: false, value: value };
    }
    
    function setupTrackDrag(bar, leftHandle, rightHandle, trackArea, layerId) {
        let isDraggingBar = false;
        let isDraggingLeft = false;
        let isDraggingRight = false;
        let startX = 0;
        let initialLeft = 0;
        let initialWidth = 0;
        
        function onMouseDown(e) {
            if (e.target === leftHandle) isDraggingLeft = true;
            else if (e.target === rightHandle) isDraggingRight = true;
            else if (e.target === bar) isDraggingBar = true;
            else return;
            
            e.preventDefault(); // Prevent text selection
            startX = e.clientX;
            
            // Get percentage values from style (handled by renderTimeline)
            // Note: We need to parse styles or calculate from bounding rect
            // Using bounding rect is safer
            const trackRect = trackArea.getBoundingClientRect();
            const barRect = bar.getBoundingClientRect();
            
            initialLeft = ((barRect.left - trackRect.left) / trackRect.width) * 100;
            initialWidth = (barRect.width / trackRect.width) * 100;
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }
        
        function onMouseMove(e) {
            const trackRect = trackArea.getBoundingClientRect();
            const width = trackRect.width;
            if (width === 0) return;

            const deltaX = e.clientX - startX;
            const deltaPercent = (deltaX / width) * 100;
            
            let newStart = initialLeft;
            let newEnd = initialLeft + initialWidth;
            
            if (isDraggingBar) {
                const currentWidth = initialWidth;
                let rawStart = initialLeft + deltaPercent;
                let rawEnd = rawStart + currentWidth;
                
                // 检查左边缘吸附
                const snapLeft = snapToPlayhead(rawStart);
                // 检查右边缘吸附
                const snapRight = snapToPlayhead(rawEnd);
                
                if (snapLeft.snapped) {
                    newStart = snapLeft.value;
                    newEnd = newStart + currentWidth;
                } else if (snapRight.snapped) {
                    newEnd = snapRight.value;
                    newStart = newEnd - currentWidth;
                } else {
                    newStart = rawStart;
                    newEnd = rawEnd;
                }
                
                // 边界限制
                newStart = Math.max(0, Math.min(100 - currentWidth, newStart));
                newEnd = newStart + currentWidth;
            } else if (isDraggingLeft) {
                let rawStart = initialLeft + deltaPercent;
                const snapResult = snapToPlayhead(rawStart);
                newStart = snapResult.snapped ? snapResult.value : rawStart;
                // 边界限制：最小5%宽度
                newStart = Math.max(0, Math.min(newEnd - 5, newStart));
            } else if (isDraggingRight) {
                let rawEnd = initialLeft + initialWidth + deltaPercent;
                const snapResult = snapToPlayhead(rawEnd);
                newEnd = snapResult.snapped ? snapResult.value : rawEnd;
                // 边界限制：最小5%宽度
                newEnd = Math.max(newStart + 5, Math.min(100, newEnd));
            }
            
            // Update Data
            timelineData[layerId] = { start: newStart, end: newEnd };
            
            // Update UI
            bar.style.left = `${newStart}%`;
            bar.style.width = `${newEnd - newStart}%`;
            
            // 更新filmstrip偏移量，保持缩略图固定位置
            const filmstrip = document.getElementById(`filmstrip-${layerId}`);
            if (filmstrip) {
                const offsetLeft = -(newStart / 100) * width;
                filmstrip.style.left = offsetLeft + 'px';
            }
            
            // Update preview to reflect changes
            updatePreview(currentScrubTime);
        }
        
        function onMouseUp() {
            isDraggingBar = false;
            isDraggingLeft = false;
            isDraggingRight = false;
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        }
        
        bar.addEventListener('mousedown', onMouseDown);
    }
  </script>
</html>
